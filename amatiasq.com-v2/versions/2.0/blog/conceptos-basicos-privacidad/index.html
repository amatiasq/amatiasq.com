<!DOCTYPE html><html lang="en" class="astro-ydck33jo"><head><meta charset="utf-8"><link rel="icon" type="image/svg+xml" href="/favicon.svg"><meta name="viewport" content="width=device-width"><meta name="generator" content="Astro v3.4.0"><title>A. Mat√≠as Quezada</title><style>pre code.hljs{display:block;overflow-x:auto;padding:1em}code.hljs{padding:3px 5px}/*!
  Theme: GitHub Dark
  Description: Dark theme as seen on github.com
  Author: github.com
  Maintainer: @Hirse
  Updated: 2021-05-15

  Outdated base version: https://github.com/primer/github-syntax-dark
  Current colors taken from GitHub's CSS
*/.hljs{color:#c9d1d9;background:#0d1117}.hljs-doctag,.hljs-keyword,.hljs-meta .hljs-keyword,.hljs-template-tag,.hljs-template-variable,.hljs-type,.hljs-variable.language_{color:#ff7b72}.hljs-title,.hljs-title.class_,.hljs-title.class_.inherited__,.hljs-title.function_{color:#d2a8ff}.hljs-attr,.hljs-attribute,.hljs-literal,.hljs-meta,.hljs-number,.hljs-operator,.hljs-variable,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-id{color:#79c0ff}.hljs-regexp,.hljs-string,.hljs-meta .hljs-string{color:#a5d6ff}.hljs-built_in,.hljs-symbol{color:#ffa657}.hljs-comment,.hljs-code,.hljs-formula{color:#8b949e}.hljs-name,.hljs-quote,.hljs-selector-tag,.hljs-selector-pseudo{color:#7ee787}.hljs-subst{color:#c9d1d9}.hljs-section{color:#1f6feb;font-weight:700}.hljs-bullet{color:#f2cc60}.hljs-emphasis{color:#c9d1d9;font-style:italic}.hljs-strong{color:#c9d1d9;font-weight:700}.hljs-addition{color:#aff5b4;background-color:#033a16}.hljs-deletion{color:#ffdcd7;background-color:#67060c}pre code.hljs{--_code-margin: var(--code-margin, 1.5em);white-space:pre;background-color:#000;margin:var(--_code-margin) calc(var(--_code-margin) * -1);padding:var(--_code-margin);border-radius:8px}pre code.hljs>.hljs-comment{color:#999}code:not(.hljs){padding:0 .3em .1em;border-radius:5px;background-color:#0000004d}.md li{list-style:initial}.md ul,.md ol{margin:20px 0;padding:reset}.md p{text-align:justify}.md blockquote{border-left:5px solid var(--color-foreground);margin-left:0;padding-left:1em}.md :is(h1,h2,h3,h4,h5,h6){margin-top:2em}
</style>
<link rel="stylesheet" href="/v2.0/_astro/_slug_.04db7373.css" />
<style>.tag-list{display:flex;gap:.5em;flex-wrap:wrap;list-style:none;margin:0;padding:0}
</style></head><body class="astro-ydck33jo"><header class="amq-header"><div class="container"><h2 class="amq"><a class="name" href="../../../"><span>{</span><abbr>Adrian</abbr><span class="dot">.</span><span>Mat√≠as Quezada</span><span>}</span></a></h2><nav><a href="../../../blog/">Blog</a><a href="../../../projects/">Projects</a><a href="../../../career/">Career</a><!-- <div class="lang-selector"> --><a href="../../../es/v2.0/blog/conceptos-basicos-privacidad/">
üá™üá∏
</a><!-- </div> --></nav></div></header><main class="astro-ydck33jo"><div class="container"><h1>Basic Javascript Concepts: Privacy (spanish)</h1><ul class="tag-list md-tags"></ul><article class="md"><h3>Introducci√≥n</h3>
<p>Uno de los temas m√°s frecuentes cuando uno se inicia en Javascript es la privacidad, principalmente viniendo de <strong>lenguajes como Java, C# o C++; donde publican o se ocultan propiedades de los objetos mediante modificadores. Javascript</strong> no posee dichos modificadores sino que <strong>todas las propiedades de los objetos son p√∫blicas</strong> lo que puede ser muy confuso para una persona poco diestra en √©sta t√©cnica, entre los que me incluyo.</p>
<p>Personalmente cuando dise√±o un componente (objeto/clase/librer√≠a), es porque quiero que ese componente cumpla una funcionalidad, por ejemplo, si yo quiero tener una clase que represente a una impresora necesito enviarle datos y que los imprima; <strong>mi prioridad es que dicho componente sea sencillo de utilizar, lo que facilita la reutilizaci√≥n del componente</strong>. Por lo que primero imagino c√≥mo me gustar√≠a usarlo:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">var</span> impresora = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Impresora</span>();
impresora.<span class="hljs-title function_">encender</span>();
impresora.<span class="hljs-title function_">imprimir</span>(datos);
impresora.<span class="hljs-title function_">apagar</span>();
</code></pre>
<p>Como se ve, para cumplir la funcionalidad me basta con tres m√©todos, pero si yo escribo mi clase impresora con solo tres m√©todos probablemente duplicar√≠a mucho c√≥digo, por ejemplo, que <code>.imprimir()</code> y <code>.apagar()</code> deban comprobar si hay papel en la impresora.</p>
<h3>Soluciones</h3>
<h4>Hacer toda la interfaz p√∫blica</h4>
<p>Podr√≠amos crear in m√©todo p√∫blico <code>.hayPapel()</code>, pero personalmente prefiero que la API, la interfaz p√∫blica de mi componente sea tan sencilla como sea posible por lo que no quiero hacer √©se m√©todo p√∫blico. <strong>Cuando tengo que usar una librer√≠a ajena no quiero saber c√≥mo est√° hecha, quiero saber como usarla</strong>. Por ello si √©sta clase tiene el m√©todo <code>.hayPapel()</code> le estoy diciendo al programador que ese m√©todo est√° ah√≠ para usarlo, cuando en realidad no es as√≠, ese m√©todo est√° ah√≠ para ayudarme a mi como desarrollador de la clase a no duplicar c√≥digo.</p>
<h4>Usar la convenci√≥n de Barra Baja (Underscore, '<code>_</code>')</h4>
<p>Una pr√°ctica muy com√∫n en Javascript es a√±adir al principio o al final del nombre de la propiedad el s√≠mbolo barra baja con lo que la propiedad es p√∫blica, pero <strong>por convenci√≥n las propiedades que empiezan o finalizan con barra baja no deben ser llamadas desde fuera del componente</strong>:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Impresora</span>(<span class="hljs-params"></span>) { }
<span class="hljs-title class_">Impresora</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = {
    <span class="hljs-attr">encender</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) { ... },
    <span class="hljs-attr">apagar</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) { ... },
    <span class="hljs-attr">imprimir</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">datos</span>) { ... },
    <span class="hljs-attr">_hayPapel</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) { ... }
};
</code></pre>
<p>Este es el m√©todo m√°s extendido que he visto en Javascript, porque es una soluci√≥n que <strong>no afecta al tiempo de ejecuci√≥n del programa</strong>. Javascript simplemente accede a una propiedad p√∫blica sin p√©rdida de rendimiento. Es una buena soluci√≥n siempre que se respete la convenci√≥n, de lo contrario estar√≠amos acoplando componentes. Eso quiere decir que si quiero hacer p√∫blica una propiedad tengo que cambiarle el nombre en todos los puntos en que la utilizo? Desgraciadamente si, pero siempre tienes el consuelo de que ser√° dentro de tu propia librer√≠a, ya que si cambias una variable de privada a p√∫blica no deber√≠a haber ning√∫n punto fuera de tu c√≥digo que accediera a √©sa propiedad, y si lo que est√°s haciendo es cambiarla de p√∫blica a privada... bueno, evidentemente hay que refactorizar el c√≥digo que utilizara tu librer√≠a de cualquier forma.</p>
<h4>Privacidad por constructor</h4>
<p>Los closures son un curioso m√©todo de privacidad, cuando creamos una funci√≥n dentro de otra, <strong>la funci√≥n hija puede acceder a las variables de la funci√≥n padre, pero no al rev√©s</strong>:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">5</span>;

<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">var</span> b = <span class="hljs-number">6</span>;

    <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
        <span class="hljs-keyword">var</span> c = <span class="hljs-number">7</span>;
        <span class="hljs-comment">// Desde aqu√≠ puedo acceder a 'a', 'b' y 'c'</span>
    }

    <span class="hljs-comment">// Desde aqu√≠ puedo acceder a 'a' y 'b'.</span>
    <span class="hljs-comment">// 'c' no existe</span>
}

<span class="hljs-comment">// Desde aqu√≠ solo puedo acceder a 'a'.</span>
<span class="hljs-comment">// 'b' y 'c' no existen</span>
</code></pre>
<p>Con √©sto podemos buscar la privacidad, si analizamos el constructor de la clase <code>Impresora</code> veremos que es una funci√≥n, igual que las del ejemplo. De alguna forma <strong>podemos crear variables privadas ah√≠</strong>.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Impresora</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">var</span> a = <span class="hljs-string">'Privada!'</span>;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Accediendo desde dentro:'</span> + a);
}

<span class="hljs-keyword">var</span> temp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Impresora</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Intentando acceder desde fuera usando 'temp.a': "</span> + temp.<span class="hljs-property">a</span>);

<span class="hljs-comment">// Esta l√≠nea no se ejecuta porque 'a' no existe aqu√≠ y falla.</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Intentando acceder desde fuera usando 'a': "</span> + a);
</code></pre>
<p>Pru√©bame</p>
<p>Funciona! Ahora a√±adamos los m√©todos:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Impresora</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">var</span> a = <span class="hljs-string">'Privada!'</span>;
}

<span class="hljs-title class_">Impresora</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = {
  <span class="hljs-attr">probando</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Intentando acceder desde un m√©todo usando 'this.a': "</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>);

    <span class="hljs-comment">// Esta l√≠nea no se ejecuta porque 'a' no existe aqu√≠ y falla.</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Intentando acceder desde un m√©todo usando 'a': "</span> + a);
  },
};

<span class="hljs-keyword">var</span> temp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Impresora</span>();
temp.<span class="hljs-title function_">probando</span>();
</code></pre>
<p>Pru√©bame</p>
<p>Pero no podemos acceder desde los m√©todos! <strong>Porque no est√°n dentro del closure</strong>, de que nos sirve una variable privada si no podemos acceder a ella desde los m√©todos p√∫blicos? Hay una soluci√≥n: el closure en el que hemos guardado la variable privada es el constructor del objeto, por lo que podr√≠amos aprovechar el dinamismo de Javascript e injectar los m√©todos en el objeto dentro del constructor, as√≠ los m√©todos podr√≠an acceder a las variables privadas:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Impresora</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">var</span> a = <span class="hljs-string">'Privada!'</span>;

  <span class="hljs-comment">// This es el objeto que √©ste constructor est√° creando</span>
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">probando</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Intentando acceder desde un m√©todo usando 'this.a': "</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Intentando acceder desde un m√©todo usando 'a': "</span> + a);
  };
}

<span class="hljs-keyword">var</span> temp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Impresora</span>();
temp.<span class="hljs-title function_">probando</span>();
</code></pre>
<p>Pru√©bame</p>
<p>Bien! √©ste sistema funciona, verdad? No tiene ning√∫n inconveniente? Bueno, tiene uno, pero no es visible a simple vista porque nuestro cerebro y el int√©rprete de Javascript funcionan de forma distinta. <strong>Para nosotros <code>this.probando = function() { ... }</code> es crear una funci√≥n y a√±adirla a todos las instancias de <code>Impresora</code></strong> pero el int√©rprete no lo ve as√≠, para la m√°quina Javascript <strong>estamos creando una funci√≥n por cada m√©todo para cada instancia</strong> y tiene sentido, si la primera funci√≥n <code>probando</code> que creamos accede a la variable privada <code>a</code> de la primera instancia que creamos necesitaremos una funci√≥n distinta para acceder a la variable privada de la segunda instancia que creemos.</p>
<p>Eso quiere decir que <strong>si creamos 10.000 instancias de <code>Impresora</code> tendremos 10.000 funciones que hacen casi lo mismo en la memoria? Si.</strong> Con las computadoras actuales es casi despreciable, pero si estamos manejando un proyecto en Javascript que puede estar creando y borrando instancias de la clase durante d√≠as (por ejemplo un programa de servidor o una RIA), tendremos un problema a medio plazo.</p>
<h3>Privacidad de librer√≠a</h3>
<p>Ahora tengo que confesar que he hecho trampas, todos los patrones descritos son para hacer privacidad a nivel de clase, pero <strong>hay una forma m√°s sencilla de hacer privada una clase entera, los closures</strong>. Ahora pensar√°s "pero me acabas de decir que los closures volv√≠an a crear los m√©todos por cada instancia!" si, cuando el closure es el constructor. <strong>Pero si englobamos toda la clase en un closure podemos tener privacidad a nivel de librer√≠a:</strong></p>
<pre><code class="hljs language-js"><span class="hljs-comment">// funci√≥n de ejecuci√≥n inmediata, se crea, se ejecuta y no se vuelve a utilizar</span>
<span class="hljs-comment">// es el closure que guardar√° la privacidad</span>
(<span class="hljs-keyword">function</span> (<span class="hljs-params"><span class="hljs-variable language_">global</span></span>) {
  <span class="hljs-keyword">var</span> contador = <span class="hljs-number">0</span>;

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">Impresora</span>(<span class="hljs-params"></span>) {
    contador++;
  }

  <span class="hljs-comment">// Creamos un m√©todo est√°tico</span>
  <span class="hljs-title class_">Impresora</span>.<span class="hljs-property">cantidadDeInstancias</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> contador;
  };

  <span class="hljs-variable language_">global</span>.<span class="hljs-property">Impresora</span> = <span class="hljs-title class_">Impresora</span>;
})(<span class="hljs-variable language_">this</span>);

<span class="hljs-keyword">var</span> temp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Impresora</span>();
<span class="hljs-keyword">var</span> temp2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Impresora</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Impresora</span>.<span class="hljs-title function_">cantidadDeInstancias</span>());
</code></pre>
<p>Pru√©bame</p>
<p>La variable <code>contador</code> es <strong>privada a nivel de librer√≠a</strong>, significa que <strong>todo lo que est√© dentro del closure accede a ella</strong> y como podemos ver todo el c√≥digo dentro del closure accede a la misma variable, lo que significa que todas las instancias de <code>Impresora</code> comparten la misma variable. Tambi√©n podemos usar √©ste patr√≥n para ocultar clases y funciones, <strong>lo √∫nico que ser√° publicado de dentro del closure ser√° lo que guardemos en la variable <code>global</code>.</strong></p>
<pre><code class="hljs language-js"><span class="hljs-comment">// funci√≥n de ejecuci√≥n inmediata, se crea, se ejecuta y no se vuelve a utilizar</span>
<span class="hljs-comment">// es el closure que guardar√° la privacidad</span>
(<span class="hljs-keyword">function</span> (<span class="hljs-params"><span class="hljs-variable language_">global</span></span>) {
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">Papel</span>(<span class="hljs-params"></span>) {}
  <span class="hljs-title class_">Papel</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = {
    <span class="hljs-attr">hayPapelEn</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">impresora</span>) {
      <span class="hljs-comment">// no hay papel</span>
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    },
    <span class="hljs-attr">pedirAlUsuario</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Oye tu! ponme papel!'</span>);
    },
  };

  <span class="hljs-keyword">var</span> papel = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Papel</span>();

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">Impresora</span>(<span class="hljs-params"></span>) {}
  <span class="hljs-title class_">Impresora</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = {
    <span class="hljs-attr">imprimir</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">datos</span>) {
      <span class="hljs-keyword">if</span> (!papel.<span class="hljs-title function_">hayPapelEn</span>(<span class="hljs-variable language_">this</span>)) papel.<span class="hljs-title function_">pedirAlUsuario</span>();
      <span class="hljs-comment">// imprimir</span>
    },
  };

  <span class="hljs-variable language_">global</span>.<span class="hljs-property">Impresora</span> = <span class="hljs-title class_">Impresora</span>;
})(<span class="hljs-variable language_">this</span>);

<span class="hljs-keyword">var</span> temp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Impresora</span>();
temp.<span class="hljs-title function_">imprimir</span>();
</code></pre>
<p>Pru√©bame</p>
<p>Este es un patr√≥n muy recomendable, ya que mediante una funci√≥n autoejecutable ocultamos todo lo que el usuario de nuestra librer√≠a no necesita conocer. Por poner un ejemplo, <a href="http://nodejs.org/">node.js</a> utiliza un patr√≥n similar para generar librer√≠as, en las que todas las variables que creamos en el archivo .js quedan ocultas y solo se exponen las propiedades que a√±adimos al objeto global <code>exports</code>. Ejemplo de saludo.js:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">var</span> saludo = <span class="hljs-string">'Hola!'</span>;
<span class="hljs-keyword">function</span> <span class="hljs-title function_">saludar</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(saludo);
}
<span class="hljs-built_in">exports</span>.<span class="hljs-property">saludar</span> = saludar;
</code></pre>
<p>Si tuviera que decir un defecto de √©ste patr√≥n, es que <strong>todo lo que queramos englobar dentro del closure deber√° estar en el mismo archivo</strong>, ya que el c√≥digo debe estar dentro del closure y √©ste no puede estar repartido entre archivos. √âsto es un problema si queremos que dos clases con mucha l√≥gica se comuniquen y no queremos acabar con un archivo de 1.000 l√≠neas de c√≥digo.</p>
<h3>Resumen</h3>
<p>No voy a opinar si la decisi√≥n de hacer todo p√∫blico al crear Javascript es buena o mala porque en mi opini√≥n <strong>no es que hacer todo p√∫blico sea malo, sino que no estamos acostrumbrados a utilizarlo</strong>. Por ello, porque la mayor√≠a de los programadores estamos acostumbrado a tener privacidad en los componentes, buscamos entre las opciones que nos da el lenguaje para simularlo.</p>
<p>En cuanto a mi, me parece interesante las posibilidades de un lenguaje tan flexible como Javascript a nivel acad√©mico, al fin y al cabo el objetivo de la investigaci√≥n es tener la mente flexible para que a la hora de la verdad podamos ver caminos alternativos que nos ofrecen una mejor soluci√≥n para un problema en particular. Un ejemplo de √©sto es un patr√≥n de privacidad por instancia que descubr√≠ recientemente, hablar√© de √©l en el <a href="http://www.amatiasq.com/?p=208" title="Experimento: Privacidad por instancias">pr√≥ximo post</a>.</p></article></div><footer class="amq-footer"><span>Created by A. Mat√≠as Quezada</span><!-- <span>Copyright 2023</span> --></footer></main></body></html>