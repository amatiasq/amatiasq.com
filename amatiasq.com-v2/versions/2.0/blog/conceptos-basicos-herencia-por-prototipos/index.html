<!DOCTYPE html><html lang="en" class="astro-ydck33jo"><head><meta charset="utf-8"><link rel="icon" type="image/svg+xml" href="/favicon.svg"><meta name="viewport" content="width=device-width"><meta name="generator" content="Astro v3.4.0"><title>A. Mat√≠as Quezada</title><style>pre code.hljs{display:block;overflow-x:auto;padding:1em}code.hljs{padding:3px 5px}/*!
  Theme: GitHub Dark
  Description: Dark theme as seen on github.com
  Author: github.com
  Maintainer: @Hirse
  Updated: 2021-05-15

  Outdated base version: https://github.com/primer/github-syntax-dark
  Current colors taken from GitHub's CSS
*/.hljs{color:#c9d1d9;background:#0d1117}.hljs-doctag,.hljs-keyword,.hljs-meta .hljs-keyword,.hljs-template-tag,.hljs-template-variable,.hljs-type,.hljs-variable.language_{color:#ff7b72}.hljs-title,.hljs-title.class_,.hljs-title.class_.inherited__,.hljs-title.function_{color:#d2a8ff}.hljs-attr,.hljs-attribute,.hljs-literal,.hljs-meta,.hljs-number,.hljs-operator,.hljs-variable,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-id{color:#79c0ff}.hljs-regexp,.hljs-string,.hljs-meta .hljs-string{color:#a5d6ff}.hljs-built_in,.hljs-symbol{color:#ffa657}.hljs-comment,.hljs-code,.hljs-formula{color:#8b949e}.hljs-name,.hljs-quote,.hljs-selector-tag,.hljs-selector-pseudo{color:#7ee787}.hljs-subst{color:#c9d1d9}.hljs-section{color:#1f6feb;font-weight:700}.hljs-bullet{color:#f2cc60}.hljs-emphasis{color:#c9d1d9;font-style:italic}.hljs-strong{color:#c9d1d9;font-weight:700}.hljs-addition{color:#aff5b4;background-color:#033a16}.hljs-deletion{color:#ffdcd7;background-color:#67060c}pre code.hljs{--_code-margin: var(--code-margin, 1.5em);white-space:pre;background-color:#000;margin:var(--_code-margin) calc(var(--_code-margin) * -1);padding:var(--_code-margin);border-radius:8px}pre code.hljs>.hljs-comment{color:#999}code:not(.hljs){padding:0 .3em .1em;border-radius:5px;background-color:#0000004d}.md li{list-style:initial}.md ul,.md ol{margin:20px 0;padding:reset}.md p{text-align:justify}.md blockquote{border-left:5px solid var(--color-foreground);margin-left:0;padding-left:1em}.md :is(h1,h2,h3,h4,h5,h6){margin-top:2em}
</style>
<link rel="stylesheet" href="/v2.0/_astro/_slug_.04db7373.css" />
<style>.tag-list{display:flex;gap:.5em;flex-wrap:wrap;list-style:none;margin:0;padding:0}
</style></head><body class="astro-ydck33jo"><header class="amq-header"><div class="container"><h2 class="amq"><a class="name" href="../../../"><span>{</span><abbr>Adrian</abbr><span class="dot">.</span><span>Mat√≠as Quezada</span><span>}</span></a></h2><nav><a href="../../../blog/">Blog</a><a href="../../../projects/">Projects</a><a href="../../../career/">Career</a><!-- <div class="lang-selector"> --><a href="../../../es/v2.0/blog/conceptos-basicos-herencia-por-prototipos/">
üá™üá∏
</a><!-- </div> --></nav></div></header><main class="astro-ydck33jo"><div class="container"><h1>Basic Javascript Concepts: Prototypal inheritance (spanish)</h1><ul class="tag-list md-tags"></ul><article class="md"><p>Lleg√≥ la hora de entrar el en tema que realmente confunde a los reci√©n llegados a Javascript, principalmente para quienes vienen de lenguajes que implementan la orientaci√≥n a objetos mediante clases, que son la gran mayor√≠a.</p>
<h3>Orientaci√≥n a Objetos</h3>
<p>Primero deberemos aclarar que significa Programaci√≥n Orientada a Objetos (POO u OOP en ing√©s).</p>
<p><a href="https://es.wikipedia.org/wiki/Programaci%C3%B3n_orientada_a_objetos">Seg√∫n la Wikipedia</a>, la descripci√≥n es:</p>
<blockquote>
<p>es un paradigma de programaci√≥n que usa objetos y sus interacciones, para dise√±ar aplicaciones y programas inform√°ticos. Est√° basado en varias t√©cnicas, incluyendo herencia, abstracci√≥n, polimorfismo y encapsulamiento.</p>
</blockquote>
<p>Como vemos un lenguaje orientado a objetos <strong>no necesariamente tiene que implementarse mediante clases</strong>, cualquier sistema que proporcione <a href="https://es.wikipedia.org/wiki/Herencia_(programaci%C3%B3n_orientada_a_objetos)">herencia</a>, <a href="https://es.wikipedia.org/wiki/Abstracci%C3%B3n_(programaci%C3%B3n_orientada_a_objetos)">abstracci√≥n</a>, <a href="https://es.wikipedia.org/wiki/Polimorfismo_(programaci%C3%B3n_orientada_a_objetos)">polimorfismo</a>¬†y <a href="https://es.wikipedia.org/wiki/Encapsulamiento_(programaci%C3%B3n_orientada_a_objetos)">encapsulamiento</a>¬†es una implementaci√≥n de orientaci√≥n a objetos v√°lida. Como ya dijimos, el sistema de clases es el m√°s extendido, utilizado por C++, Java, C#, PHP, Python, ActionScript3, Perl, Objective-C, Ruby, etc... <strong>Javascript no tiene clases, utiliza el sistema de herencia por prototipos</strong>, veamos la diferencia:</p>
<p><strong>En un lenguaje basado en clases</strong> tenemos dos tipos de conceptos, los objetos en s√≠, referencias que pueden ser almacenadas, modificadas y pasadas como argumentos. Y por otro lado <strong>las clases, objetos intangibles, no podemos guardarlos en variables ni pasar como argumento</strong>, no podemos manipularlos ni comprobar si existen excepto por reflexi√≥n, que consiste en herramientas del lenguaje para obtener objetos (tangibles, del tipo anterior) que <strong>representan a las clases</strong> a las que no podemos acceder. En un lenguaje de √©ste tipo las clases est√°n una capa por encima de los objetos y definen la herencia, abstracci√≥n, encapsulamiento y polimorfismo de los objetos que se obtendr√°n a partir de ellas, tienen una funci√≥n de plantillas para crear objetos definidas antes de ejecutarse el c√≥digo del programa.</p>
<p><strong>En un lenguaje orientado a prototipos</strong> no hay clases que definan la herencia, los objetos mismos heredan de otros objetos. No hay clases cuando el programa se inicia, sino que se crean objetos y se le ordena a otros objetos que hereden de ellos. Por ejemplo, si tenemos un objeto eventEmitter y queremos crear instancias creamos nuevos objetos y hacemos que hereden de eventEmitter.</p>
<h3>[[Prototype]]</h3>
<p>Una vez entendido el concepto podemos pasar a la pr√°ctica, sabemos que para crear instancias de clases hacemos <code>new MyClass()</code> pero c√≥mo hacemos que objetos hereden de objetos? Aqu√≠ entran los prototipos. <strong>Todos los objetos Javascript tienen una propiedad oculta que llamaremos <code>[[Prototype]]</code></strong>, con corchetes (aunque en algunos navegadores es posible acceder a ella mediante la propiedad <code>.__proto__</code>, con dos barras bajas a cada lado, pero no es est√°ndar) <strong>que es un puntero al objeto del cual hereda</strong>. Y que significa que hereda? Podr√≠amos resumir la herencia en que un objeto tiene las mismas propiedades que otro.</p>
<p>Con √©sto nos ahorramos tener que poner las mismas propiedades en m√°s de un objeto. Esto trae un nuevo concepto que puede confundir a muchos: <strong>en Javascript todo es una instancia, y cuando heredamos de un objeto tambi√©n se puede decir que estamos creando una instancia de √©se objeto</strong>, para evitar confunsiones <strong>suele decirse que un objeto "extiende" otro</strong>. Imaginemos que tenemos un objeto perro que hereda de animal. Que significa √©sto? que la propiedad <code>[[Prototype]]</code> de perro es animal, o lo que es lo mismo:</p>
<pre><code class="hljs language-js">perro.<span class="hljs-property">__proto__</span> == animal; <span class="hljs-comment">// true</span>
</code></pre>
<p>El c√≥digo de ejemplo es el siguiente:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">var</span> animal = {};
animal.<span class="hljs-property">estaVivo</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
};

<span class="hljs-keyword">var</span> perro = {};
perro.<span class="hljs-property">__proto__</span> = animal;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(perro.<span class="hljs-property">estaVivo</span>);
</code></pre>
<p>Pru√©bame</p>
<p>Vemos que <code>perro.estaVivo</code> es la funci√≥n que asignamos a <code>animal</code> c√≥mo puede ser √©sto? Por la herencia por prototipos. <strong>Javascript ha buscado la propiedad <code>estaVivo</code> en <code>perro</code> pero no la ha encontrado, entonces accede a su propiedad <code>[[Prototype]]</code> (o <code>__proto__</code>)</strong> donde nosotros guardamos <code>animal</code>. Entonces busca <code>estaVivo</code> en <code>animal</code> y lo encuentra. Por eso <code>perro.estaVivo</code> nos devuelve el m√©todo de <code>animal</code>. Podr√≠amos representarlo as√≠:</p>
<p><img src="/wp-content/uploads/2012/01/prototype.png" alt="Diagrama"></p>
<p>Y si animal no hubiese tenido la propiedad <code>estaVivo</code>? En ese caso debemos tener en cuenta que animal tambi√©n es un objeto y que todos los objetos tienen prototipo, en caso de que no le asignemos ninguno su prototipo es <code>Object.prototype</code>. Es otra forma de decir que <strong>en Javascript todos los objetos extienden <code>Object.prototype</code></strong>. <code>Object.prototype</code> es el equivalente a la clase <code>Object</code> de Java o C#.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">var</span> animal = {};
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(animal.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);
</code></pre>
<p>Pru√©bame</p>
<p>Y si tampoco encuentra la propiedad en <code>Object.prototype</code>? lo busca en el <code>[[Prototype]]</code> de <code>Object.prototype</code> pero sorpresa! <strong><code>Object.prototype.__proto__</code> es <code>null</code></strong>. Eso significa que <strong>es el √∫ltimo objeto de la jerarqu√≠a de herencia</strong>, si llegado a √©ste punto Javascript no encuentra la propiedad que le pedimos devuelve <code>undefined</code>.</p>
<p>Esta jerarqu√≠a de prototipos suele llamarse <strong>cadena de prototipos</strong> del objeto. Por ejemplo, <code>Object.prototype</code> tiene la propiedad <code>.toString()</code>, entonces si volvemos a crear <code>perro</code> heredando de <code>animal</code>, su propiedad <code>.toString()</code> que ser√°? Javascript recorrer√° la jerarqu√≠a de prototipos de <code>perro</code> hasta encontrar <code>.toString()</code> que est√° en <code>Object.prototype</code>.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">var</span> animal = {};
animal.<span class="hljs-property">estaVivo</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
};

<span class="hljs-keyword">var</span> perro = {};
perro.<span class="hljs-property">__proto__</span> = animal;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(perro.<span class="hljs-property">toString</span> === <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>);
</code></pre>
<p>Pru√©bame</p>
<h3>Como modificar una propidad inaccesible?</h3>
<p>Bien, la teor√≠a ha ido correctamente, pero como ya dijimos, <strong><code>__proto__</code> no es est√°ndar</strong>, y por lo tanto no podemos contar con que funcione en cualquier motor de Javascript, <strong>entonces c√≥mo se supone que vamos a implementar herencia en Javascript?</strong> Para ello Javascript provee de una funcionalidad un tanto dif√≠cil de entender as√≠ que intentaremos ir poco a poco.</p>
<p><strong>Toda funci√≥n, creada en Javascript tiene una propiedad llamada <code>.prototype</code> que no debe confundirse con <code>[[Prototype]]</code></strong>, el <code>[[Prototype]]</code> de las funciones apunta a <code>Function.prototype</code> que es un objeto que tiene funciones como <code>.call()</code>, <code>.apply()</code> y <code>.bind()</code>. No, en √©ste caso nos referimos a que todas las funciones tienen una propiedad llamada <code>prototype</code> que es un objeto vac√≠o. Y porqu√© se llama <code>prototype</code> si no tiene nada que ver con el <code>[[Prototype]]</code> de la funci√≥n? <strong>Porque los objetos que creemos llamando a √©sa funci√≥n con <code>new</code> tendr√°n su <code>[[Prototype]]</code> apuntando a la propiedad <code>prototype</code> de la funci√≥n:</strong></p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myFunct</span>(<span class="hljs-params"></span>) {}
<span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title function_">myFunct</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">__proto__</span> === myFunct.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);
</code></pre>
<p>Pru√©bame</p>
<p>Sorpresa! <strong>Hemos modificado la propiedad oculta <code>[[Prototype]]</code> de <code>obj</code>!</strong> Quiz√°s te preguntes porqu√© no se estandariza la propiedad accesible <code>__proto__</code>? Porque con el sistema de las funciones el lenguaje se asegura que <strong>s√≥lo podemos modificar la propiedad <code>[[Prototype]]</code> de objetos nuevos</strong>, no de existentes. De √©sta forma, en las implementaciones est√°ndar donde no podemos acceder a la propiedad <code>__proto__</code> no podemos modificar el prototipo de una funci√≥n o de <code>Object.prototype</code> ni podemos evitar que un objeto extienda de <code>Object.prototype</code>, poniendo su propiedad <code>__proto__</code> a <code>null</code> romper√≠amos √©sta regla del lenguaje.</p>
<p>Pero <strong>entonces <code>myFunct</code> es una clase? Podr√≠a decirse que si, pero no es una clase como las que estamos acostumbrados a ver, es una funci√≥n, es un objeto y es tangible</strong>, el hecho de crear nuevos objetos con <code>new</code> seguido de una funci√≥n es solo una sintaxis que se a√±adi√≥ a Javascript para parecerse a Java, lenguaje en plena expansi√≥n cuando Javascript fue dise√±ado. Ahora que entendemos que <code>myFunct.prototype</code> es igual al <code>[[Prototype]]</code> de los objetos que creemos con la funci√≥n podemos crear objetos que extiendan del mismo objeto:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myFunct</span>(<span class="hljs-params"></span>) {}
myFunct.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">'Alice'</span>,
  <span class="hljs-attr">lastname</span>: <span class="hljs-string">'Smith'</span>,
  <span class="hljs-attr">fullname</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">' '</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">lastname</span>;
  },
};

<span class="hljs-keyword">var</span> instancia1 = <span class="hljs-keyword">new</span> <span class="hljs-title function_">myFunct</span>();
<span class="hljs-keyword">var</span> instancia2 = <span class="hljs-keyword">new</span> <span class="hljs-title function_">myFunct</span>();

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(instancia1.<span class="hljs-title function_">fullname</span>() + <span class="hljs-string">'n'</span> + instancia2.<span class="hljs-title function_">fullname</span>());
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(instancia1.<span class="hljs-property">__proto__</span> == instancia2.<span class="hljs-property">__proto__</span>);
</code></pre>
<p>Pru√©bame</p>
<p>E incluso podemos crear un objeto que extienda de una instancia de myFunct!</p>
<pre><code class="hljs language-js">instancia1.<span class="hljs-property">name</span> = <span class="hljs-string">'Bob'</span>;
<span class="hljs-keyword">function</span> <span class="hljs-title function_">extenderInstancia1</span>(<span class="hljs-params"></span>) {}
extenderInstancia1.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = instancia1;
<span class="hljs-keyword">var</span> subInstancia = <span class="hljs-keyword">new</span> <span class="hljs-title function_">extenderInstancia1</span>();

<span class="hljs-keyword">var</span> texto = <span class="hljs-string">'Fullname: '</span> + subInstancia.<span class="hljs-title function_">fullname</span>() + <span class="hljs-string">'n'</span>;
texto += <span class="hljs-string">'Es instancia de extenderInstancia1? '</span> + (subInstancia <span class="hljs-keyword">instanceof</span> extenderInstancia1) + <span class="hljs-string">'n'</span>;
texto += <span class="hljs-string">'Es instancia de myFunct? '</span> + (subInstancia <span class="hljs-keyword">instanceof</span> myFunct) + <span class="hljs-string">'n'</span>;
texto += <span class="hljs-string">'Es instancia de Object? '</span> + (subInstancia <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span>);

<span class="hljs-title function_">alert</span>(texto);
</code></pre>
<p>Pru√©bame</p>
<h3><code>extend()</code></h3>
<p>Pero √©ste l√≠o de tener funciones que parecen clases pero no son clases exactamente y crean instancias y tener que crear funciones para extender es bastante confuso, por ello, los defensores de no mezclar la herencia por prototipos con √©stas falsas clases proponen usar la funci√≥n <code>extend</code>:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">extend</span>(<span class="hljs-params">proto</span>) {
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">intermediario</span>(<span class="hljs-params"></span>) {}
  intermediario.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = proto;
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">intermediario</span>();
}
</code></pre>
<p>Y con √©sta funci√≥n podemos extender objetos sin necesidad de crear funciones intermedias:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">var</span> base = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">'Alice'</span>,
  <span class="hljs-attr">lastname</span>: <span class="hljs-string">'Smith'</span>,
  <span class="hljs-attr">fullname</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">' '</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">lastname</span>;
  },
};

<span class="hljs-keyword">var</span> instancia1 = <span class="hljs-title function_">extend</span>(base);
<span class="hljs-keyword">var</span> instancia2 = <span class="hljs-title function_">extend</span>(base);

instancia1.<span class="hljs-property">name</span> = <span class="hljs-string">'Bob'</span>;
<span class="hljs-keyword">var</span> subInstancia = <span class="hljs-title function_">extend</span>(instancia1);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(subInstancia.<span class="hljs-title function_">fullname</span>());
</code></pre>
<p>Pru√©bame</p>
<p>Como vemos, el c√≥digo queda bastante m√°s claro, es por √©sto que en la 5¬™ edici√≥n de ECMAScript (el est√°ndar en el que est√° basado Javascript), se decidi√≥ a√±adir <code>Object.create()</code> que <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/create">cumple la misma funcionalidad</a> que la funci√≥n <code>extend()</code> que hemos creado.</p>
<h3>Resumen</h3>
<p>Es un camino duro pasar de un lenguaje basado en clases a uno basado en prototipos, requiere mucha pr√°ctica, una mente abierta y muchas ganas de aprender. Pero las ganancias son grandes, incluso para desarrolladores que no necesiten tocar Javascript considero que aprender √©ste patr√≥n aporta ventajas porque <strong>entender ambos patrones en mente nos abre a nuevas ideas, nos ayuda a tener siempre presente que las cosas no tienen porque ser como estamos acostumbrados a que sean, y a buscar nuevas soluciones a nuevos problemas y por √∫ltimo pero no menos importante, nos mantiene activos</strong>. Espero que sea f√°cil seguir el post aunque se que ha crecido m√°s all√° de lo deseado, pido comprensi√≥n ya que escribir no es mi punto fuerte, pero para eso est√° la pr√°ctica, para mejorar ;)</p></article></div><footer class="amq-footer"><span>Created by A. Mat√≠as Quezada</span><!-- <span>Copyright 2023</span> --></footer></main></body></html>