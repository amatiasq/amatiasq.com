<!DOCTYPE html><html lang="en"><head><meta charSet="UTF-8"/><meta name="description" content="A. Matías Quezada&#x27;s personal website"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Promise pattern: Implementation (spanish) | A. Matías Quezada</title><style> *, ::before, ::after { box-sizing: border-box; } html { line-sizing: normal; } body { margin: 0; } [hidden] { display: none; } h1 { font-size: 2rem; } h2 { font-size: 1.5rem; } h3 { font-size: 1.17rem; } h4 { font-size: 1.00rem; } h5 { font-size: 0.83rem; } h6 { font-size: 0.67rem; } h1 { margin: 0.67em 0; } pre { white-space: pre-wrap; } hr { border-style: solid; border-width: 1px 0 0; color: inherit; height: 0; overflow: visible; } img, svg, video, canvas, audio, iframe, embed, object { display: block; vertical-align: middle; max-width: 100%; } audio:not([controls]) { display:none; } picture { display: contents; } source { display: none; } img, svg, video, canvas { height: auto; } audio { width: 100%; } img { border-style: none; } svg { overflow: hidden; } article, aside, details, figcaption, figure, footer, header, hgroup, main, nav, section { display: block; } [type='checkbox'], [type='radio'] { box-sizing: border-box; padding: 0; } @media (prefers-reduced-motion: reduce) { *, ::before, ::after { animation-name: none !important; transition: none !important; } } </style><style>@font-face { font-family: 'Inconsolata'; font-style: normal; font-weight: 400; font-stretch: normal; font-display: swap; src: url(https://fonts.gstatic.com/s/inconsolata/v30/QldgNThLqRwH-OJ1UHjlKENVzkWGVkL3GZQmAwLYxYWI2qfdm7Lpp4U8aRo.ttf) format('truetype'); } @font-face { font-family: 'Inconsolata'; font-style: normal; font-weight: 700; font-stretch: normal; font-display: swap; src: url(https://fonts.gstatic.com/s/inconsolata/v30/QldgNThLqRwH-OJ1UHjlKENVzkWGVkL3GZQmAwLYxYWI2qfdm7Lpp2I7aRo.ttf) format('truetype'); } @font-face { font-family: 'Nunito'; font-style: normal; font-weight: 400; font-display: swap; src: url(https://fonts.gstatic.com/s/nunito/v24/XRXI3I6Li01BKofiOc5wtlZ2di8HDLshRTM.ttf) format('truetype'); } @font-face { font-family: 'Nunito'; font-style: normal; font-weight: 700; font-display: swap; src: url(https://fonts.gstatic.com/s/nunito/v24/XRXI3I6Li01BKofiOc5wtlZ2di8HDFwmRTM.ttf) format('truetype'); } @font-face { font-family: 'Nunito Sans'; font-style: normal; font-weight: 400; font-display: swap; src: url(https://fonts.gstatic.com/s/nunitosans/v12/pe0qMImSLYBIv1o4X1M8cfe6.ttf) format('truetype'); } @font-face { font-family: 'Nunito Sans'; font-style: normal; font-weight: 700; font-display: swap; src: url(https://fonts.gstatic.com/s/nunitosans/v12/pe03MImSLYBIv1o4X1M8cc8GBv5q.ttf) format('truetype'); } </style><style> :root { background-color: #263238; color: #FDFBF8; font-family: Nunito Sans, sans-serif; font-size: 18px; line-height: 1.5; letter-spacing: 0.5px; --color-primary: #8BB9F8; /* azul */ --color-primary: #8BA9FF; /* French Sky Blue */ --color-primary: #70ACFF; /* French Sky Blue 2 */ --color-primary: #FC9173; /* Dark Salmom */ --color-primary: #00ff01; /* Verde familia */ --color-primary: #00ffe1; /* Cyan Romi */ --color-primary: #EFE751; } header, h1, h2, h3, h4, h5, h6 { font-family: Nunito, sans-serif; } a { color: var(--color-primary); text-decoration: none; } a[href^="http"]:not(.no-external)::after { content: ''; margin-left: 0.5em; width: 0.8em; height: 0.8em; display: inline-block; background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='%23EFE751' stroke='%23EFE751'%3E%3Cpath d='M6 17c2.269-9.881 11-11.667 11-11.667v-3.333l7 6.637-7 6.696v-3.333s-6.17-.171-11 5zm12 .145v2.855h-16v-12h6.598c.768-.787 1.561-1.449 2.339-2h-10.937v16h20v-6.769l-2 1.914z'/%3E%3C/svg%3E"); background-repeat: no-repeat; background-position: center; background-size: contain; } :where(.bouncy-box, article a) { position: relative; display: inline-block; --underline-width: 1px; --padding: 8; transform: scale(1) rotate(0); transition: transform 0.3s cubic-bezier(0.25, 0.1, 0, 2.05); } :where(.bouncy-box, article a):hover { transform: scale(1.1) rotate(0); } :where(.bouncy-box, article a):before { content: ''; position: absolute; z-index: -1; border-radius: 8px; opacity: 1; background: var(--color-primary); inset: calc(100% - var(--underline-width)) 0 0 0; height: var(--underline-width); transition-property: inset, opacity, height, background; transition-duration: 0.3s; transition-timing-function: cubic-bezier(0,.5,0,1); } :where(.bouncy-box, article a):hover:before { inset: calc(var(--padding) * -1px) calc(var(--padding) * -2px); background: black; opacity: 0.8; height: calc(100% + calc(var(--padding) * 2px)); } ol { padding: 0; } li { list-style: none; } code { font-family: Inconsolata, monospace; } svg { fill: #FDFBF8; } </style><style>.css-1ljukny{position:fixed;bottom:1rem;right:1rem;background-color:black;}.css-1ljukny input{border:none;width:3rem;height:3rem;}
.css-5a8vm2 .shj-inline{margin:0;padding:2px 5px;display:inline-block;border-radius:5px;}.css-5a8vm2 [class*=shj-lang-]::selection,.css-5a8vm2 [class*=shj-lang-] ::selection{background:#bdf5;}.css-5a8vm2 [class*=shj-lang-]>div{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;overflow:auto;}.css-5a8vm2 [class*=shj-lang-]>div :last-child{-webkit-flex:1;-ms-flex:1;flex:1;outline:none;}.css-5a8vm2 .shj-syn-cmnt{font-style:italic;}.css-5a8vm2 .shj-syn-err,.css-5a8vm2 .shj-syn-kwd{color:#e16;}.css-5a8vm2 .shj-syn-num,.css-5a8vm2 .shj-syn-class{color:#f60;}.css-5a8vm2 .shj-numbers,.css-5a8vm2 .shj-syn-cmnt{color:#999;}.css-5a8vm2 .shj-syn-insert,.css-5a8vm2 .shj-syn-str{color:#7d8;}.css-5a8vm2 .shj-syn-bool{color:#3bf;}.css-5a8vm2 .shj-syn-type,.css-5a8vm2 .shj-syn-oper{color:#5af;}.css-5a8vm2 .shj-syn-section,.css-5a8vm2 .shj-syn-func{color:#84f;}.css-5a8vm2 .shj-syn-deleted,.css-5a8vm2 .shj-syn-var{color:#f44;}.css-5a8vm2 .shj-oneline{padding:12px 10px;}.css-5a8vm2 .shj-lang-http.shj-oneline .shj-syn-kwd{background:#25f;color:#fff;padding:5px 7px;border-radius:5px;}.css-5a8vm2 .shj-multiline.shj-mode-header{padding:20px;}.css-5a8vm2 .shj-multiline.shj-mode-header:before{content:attr(data-lang);color:#58f;display:block;padding:10px 20px;background:#58f3;border-radius:5px;margin-bottom:20px;}.css-5a8vm2 [class*=shj-lang-]:before{color:#6f9aff;}.css-5a8vm2 .shj-syn-deleted,.css-5a8vm2 .shj-syn-err,.css-5a8vm2 .shj-syn-var{color:#e06c75;}.css-5a8vm2 .shj-syn-section,.css-5a8vm2 .shj-syn-oper,.css-5a8vm2 .shj-syn-kwd{color:#c678dd;}.css-5a8vm2 .shj-syn-class{color:#e5c07b;}.css-5a8vm2 .shj-numbers,.css-5a8vm2 .shj-syn-cmnt{color:#76839a;}.css-5a8vm2 .shj-syn-insert{color:#98c379;}.css-5a8vm2 .shj-syn-type{color:#56b6c2;}.css-5a8vm2 .shj-syn-num,.css-5a8vm2 .shj-syn-bool{color:#d19a66;}.css-5a8vm2 .shj-syn-str,.css-5a8vm2 .shj-syn-func{color:#61afef;}
.css-2bthvy{font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Helvetica,Arial,sans-serif,'Apple Color Emoji','Segoe UI Emoji';}.css-2bthvy li{list-style:initial;}.css-2bthvy ul,.css-2bthvy ol{margin:20px 0;padding:reset;}.css-2bthvy p{margin:20px 0;text-align:justify;}.css-2bthvy blockquote{border-left:5px solid #586369;margin-left:0;padding-left:1em;}.css-2bthvy code:not(.code-block){background-color:#161b22;padding:4px;border-radius:4px;}.css-2bthvy pre{--code-block-margin:3em;--code-block-padding:1em;--code-inline-padding:min(3em, var(--container-side-gap));margin:var(--code-block-margin) 0;padding:var(--code-block-padding) 0;position:relative;white-space:pre;}.css-2bthvy pre .code-block{display:block;width:var(--available-width);white-space:pre;text-shadow:none;font-size:18px;line-height:24px;box-sizing:border-box;max-width:var(--available-width);overflow-x:auto;color:#abb2bf;}.css-2bthvy pre::before{content:'';inset:calc(var(--code-block-padding) * -1) calc(var(--code-inline-padding) * -1);background:#161b22;border-radius:10px;box-shadow:0 0 5px #0001;position:absolute;z-index:-1;max-width:100vw;}
.css-84fmch{opacity:0.8;font-size:0.8em;font-family:Inconsolata,monospace;color:#FDFBF8;white-space:nowrap;}
.css-v6zv8e{font-family:Nunito,sans-serif;font-weight:700;font-size:32px;}
.css-relzm4{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:justify;-webkit-justify-content:space-between;justify-content:space-between;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;}@media (min-width: 769px){.css-relzm4{-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}}
.css-18junyj{font-size:24px;color:white;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:baseline;-webkit-box-align:baseline;-ms-flex-align:baseline;align-items:baseline;gap:12px;letter-spacing:1px;}.css-18junyj abbr{display:inline-block;width:0.8em;overflow:hidden;-webkit-transition:width 0.3s ease;transition:width 0.3s ease;}.css-18junyj:hover abbr{width:3.3em;}
.css-1y1oy5{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;gap:12px;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}
.css-18wymod{--container-side-gap:1rem;--container-width:40rem;--container-sides-gap:calc(var(--container-side-gap) * 2);--available-width:min(
      calc(100vw - var(--container-sides-gap)),
      calc(var(--container-width) - var(--container-sides-gap))
    );max-width:var(--container-width);padding-left:var(--container-side-gap);padding-right:var(--container-side-gap);margin-left:auto;margin-right:auto;}@media (min-width: 769px){.css-18wymod{--container-width:50rem;--container-side-gap:3rem;}}@media (min-width: 1200px){.css-18wymod{--container-width:60rem;}}
.css-x7nza2{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;gap:12px;}.css-x7nza2 a{color:var(--color-primary);margin-left:12px;border-bottom:1px solid transparent;-webkit-transform:translate(0px, 0px);-moz-transform:translate(0px, 0px);-ms-transform:translate(0px, 0px);transform:translate(0px, 0px);}.css-x7nza2 a.parent{border-bottom:1px solid #586369;}.css-x7nza2 a:hover{border-bottom:1px solid var(--color-primary);-webkit-transition:-webkit-transform 1s ease;transition:transform 1s ease;-webkit-transform:translate(0px, -3px);-moz-transform:translate(0px, -3px);-ms-transform:translate(0px, -3px);transform:translate(0px, -3px);}
.css-17rdaxl{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:justify;-webkit-justify-content:space-between;justify-content:space-between;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;}@media (min-width: 769px){.css-17rdaxl{-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;}}
.css-1witpq9{padding:20px 0;background-color:#161b22;color:#FDFBF8;border-bottom:2px solid #586369;}@media (min-width: 769px){.css-1witpq9{position:-webkit-sticky;position:sticky;top:0;z-index:1;}}
.css-1e8d7s{padding-bottom:4rem;}
.css-1p4f3y5{display:grid;padding-top:20px;gap:12px;}</style></head><body class=" css-1e8d7s"><header class="css-1witpq9 "><div class="css-17rdaxl css-18wymod"><h2 class="css-1y1oy5"><a href="../.." class="css-18junyj inactive">{ <abbr>Adrian</abbr> Matías Quezada }</a></h2><nav class="css-x7nza2"><a href=".." class="parent">Blog</a><a href="../../projects" class="">Projects</a><a href="../../career" class="">CV</a><a href="../../../es/blog/2011-12-18-patron-promise-implementacion" class="">🇪🇸</a></nav></div></header><div class="css-1p4f3y5 css-18wymod"><h2 class="css-relzm4  css-v6zv8e">Promise pattern: Implementation (spanish)<time class="css-84fmch " dateTime="12/18/2011">Dec 18, 2011</time></h2><article class="md css-2bthvy css-5a8vm2 "><p>Lo prometido es deuda (bien lo saben las funciones) y he encontrado un momento para empezar a explicar la forma en la que he implementado el patrón Promise en mi caso, no tiene porqué ser la mejor, pero cumple con su cometido.</p>
<p><strong>NOTA:</strong> Me gustaría implementarla en Test Driven Development, pero ya es bastante para quien lee y para el que escribe seguir la implementación como para encima añadir TDD, pero no quisiera dejar de recomendarlo.</p>
<!-- end extract -->
<h3 id="primero-funcionalidad-b-sica">Primero: Funcionalidad básica</h3>
<p>Lo que necesitamos de un objeto Promise es:</p>

<ul>
<li>Crear instancias totalmente independientes</li>
<li>Añadirle callbacks que serán llamados cuando se cumpla la promesa</li>
<li>Notificarle cuando se ha cumplido la promesa</li>
</ul>
<!--more Seguir leyendo → -->
<p>Con los objetivos en la mano es más sencillo ver que hacer, lo primero necesitamos una clase, a la hora de crear clases en Javascript yo me decanto por el patrón de constructor con prototipos que espero explicar algún día.</p>

<pre><code class="code-block shj-lang-js"><span class="shj-syn-kwd">function</span> <span class="shj-syn-class">Promise</span>() {}
</code></pre>
<p><strong>Segundo punto:</strong> poder añadirle callbacks, ésto consiste en el método <code>.then()</code> al que deberemos poder llamar pasándole las funciones que queremos que se ejecuten cuando la promesa se cumpla. Puesto de debe poderse añadir más de un callback para cada promise lo más lógico sería crear un Array donde almacenarlos</p>

<pre><code class="code-block shj-lang-js"><span class="shj-syn-kwd">function</span> <span class="shj-syn-class">Promise</span>() {
  <span class="shj-syn-kwd">this</span><span class="shj-syn-oper">.</span>_callbacks <span class="shj-syn-oper">=</span> [];
}
</code></pre>
<p>Y el método <code>.then()</code> que vaya añadiendo al Array los callbacks que se le pasen, puesto que es mejor que los errores se detecten cuanto antes también podemos asegurarnos que el callback es una función:</p>

<pre><code class="code-block shj-lang-js"><span class="shj-syn-class">Promise</span><span class="shj-syn-oper">.</span>prototype<span class="shj-syn-oper">.</span><span class="shj-syn-func">then</span> <span class="shj-syn-oper">=</span> <span class="shj-syn-kwd">function</span> (callback) {
  <span class="shj-syn-kwd">if</span> (<span class="shj-syn-kwd">typeof</span> callback <span class="shj-syn-oper">!==</span> <span class="shj-syn-str">'function'</span>) {
    <span class="shj-syn-kwd">throw</span> <span class="shj-syn-kwd">new</span> <span class="shj-syn-class">Error</span>(<span class="shj-syn-str">"[Promise.then] El argumento 'callback' no es una función "</span> <span class="shj-syn-oper">+</span> <span class="shj-syn-kwd">typeof</span> callback);
  }

  <span class="shj-syn-kwd">this</span><span class="shj-syn-oper">.</span>_callbacks<span class="shj-syn-oper">.</span><span class="shj-syn-func">push</span>(callback);
};
</code></pre>
<p>Y ahora que ya tenemos todos los callbacks en un Array necesitamos algún sistema para avisarle al Promise que ya tiene los datos que necesita y que se los pase a los callbacks. Sobre ésto no he visto ninguna implementación, pero a mi me parece bastante razonable crear un método <code>Promise.done()</code> que notifica al Promise que ya está cumplido y ejecuta los callbacks.</p>

<pre><code class="code-block shj-lang-js"><span class="shj-syn-class">Promise</span><span class="shj-syn-oper">.</span>prototype<span class="shj-syn-oper">.</span><span class="shj-syn-func">done</span> <span class="shj-syn-oper">=</span> <span class="shj-syn-kwd">function</span> () {
  <span class="shj-syn-kwd">var</span> callback;
  <span class="shj-syn-kwd">for</span> (<span class="shj-syn-kwd">var</span> i <span class="shj-syn-oper">=</span> <span class="shj-syn-num">0</span>; i <span class="shj-syn-oper">&lt;</span> <span class="shj-syn-kwd">this</span><span class="shj-syn-oper">.</span>_callbacks<span class="shj-syn-oper">.</span>length; i<span class="shj-syn-oper">++</span>) {
    callback <span class="shj-syn-oper">=</span> <span class="shj-syn-kwd">this</span><span class="shj-syn-oper">.</span>_callbacks[i];
    <span class="shj-syn-func">callback</span>();
  }
};
</code></pre>
<p>Y ya lo tenemos hecho, hemos creado un Promise básico, vamos a probarlo. Imaginemos cualquier función asíncrona, por ejemplo vamos a crear una función que nos avise cuando pase un segundo:</p>

<pre><code class="code-block shj-lang-js"><span class="shj-syn-kwd">function</span> <span class="shj-syn-func">esperarUnSegundo</span>() {
  <span class="shj-syn-kwd">var</span> promise <span class="shj-syn-oper">=</span> <span class="shj-syn-kwd">new</span> <span class="shj-syn-class">Promise</span>();
  <span class="shj-syn-cmnt">// Hacemos un timeout a mil milisegundos
</span>  <span class="shj-syn-func">setTimeout</span>(<span class="shj-syn-kwd">function</span> () {
    promise<span class="shj-syn-oper">.</span><span class="shj-syn-func">done</span>();
  }<span class="shj-syn-oper">,</span> <span class="shj-syn-num">1000</span>);
  <span class="shj-syn-kwd">return</span> promise;
}

<span class="shj-syn-func">esperarUnSegundo</span>()<span class="shj-syn-oper">.</span><span class="shj-syn-func">then</span>(<span class="shj-syn-kwd">function</span> () {
  <span class="shj-syn-func">alert</span>(<span class="shj-syn-str">'Ha pasado un segundo =D'</span>);
});
</code></pre>
<p><a href="http://jsfiddle.net/amatiasq/4LBWd/2/" target="_blank">Pruébame</a></p>
<p>Si probamos todo el código veremos que al cabo de un segundo ejecuta el alert.</p>
<p>Todo funciona perfectamente, vamos un punto más allá, ésta vez descarguemos una página, como no nos importa ahora mismo el código que descarga la página fingiremos llamar a una función <code>peticiónHttp(url, callback)</code> que lo hará por nosotros.</p>

<pre><code class="code-block shj-lang-js"><span class="shj-syn-kwd">function</span> <span class="shj-syn-func">descargar</span>(url) {
  <span class="shj-syn-kwd">var</span> promise <span class="shj-syn-oper">=</span> <span class="shj-syn-kwd">new</span> <span class="shj-syn-class">Promise</span>();
  petició<span class="shj-syn-func">nHttp</span>(url<span class="shj-syn-oper">,</span> <span class="shj-syn-kwd">function</span> (codigoHtml) {
    promise<span class="shj-syn-oper">.</span><span class="shj-syn-func">done</span>();
  });
  <span class="shj-syn-kwd">return</span> promise;
}
<span class="shj-syn-func">descargar</span>(<span class="shj-syn-str">'www.google.com'</span>)<span class="shj-syn-oper">.</span><span class="shj-syn-func">then</span>(<span class="shj-syn-kwd">function</span> () {
  <span class="shj-syn-cmnt">// Y ahora?
</span>});
</code></pre>
<p>Sorpresa! La función ha descargado la página y obtenido el html, pero nuestro Promise no ha sido capaz de pasarlo al callback. La función del Promise en un principio era avisar cuando una tarea asíncrona termina, pero la mayoría de las tareas asíncronas devuelven un resultado y cuando avisemos al Promise que se ha cumplido también querremos que pase el resultado a todos los callbacks. Para ello modificaremos el método done y para que pase a los callbacks todos los argumentos que se le pasen a él (si no sabes lo que hace el método apply puedes mirarlo [aquí][1]):</p>

<pre><code class="code-block shj-lang-js"><span class="shj-syn-class">Promise</span><span class="shj-syn-oper">.</span>prototype<span class="shj-syn-oper">.</span><span class="shj-syn-func">done</span> <span class="shj-syn-oper">=</span> <span class="shj-syn-kwd">function</span> () {
  <span class="shj-syn-cmnt">// Guardamos los argumentos que se le ha pasado a .done()
</span>  <span class="shj-syn-kwd">var</span> args <span class="shj-syn-oper">=</span> arguments;
  <span class="shj-syn-kwd">var</span> callback;
  <span class="shj-syn-kwd">for</span> (<span class="shj-syn-kwd">var</span> i <span class="shj-syn-oper">=</span> <span class="shj-syn-num">0</span>; i <span class="shj-syn-oper">&lt;</span> <span class="shj-syn-kwd">this</span><span class="shj-syn-oper">.</span>_callbacks<span class="shj-syn-oper">.</span>length; i<span class="shj-syn-oper">++</span>) {
    callback <span class="shj-syn-oper">=</span> <span class="shj-syn-kwd">this</span><span class="shj-syn-oper">.</span>_callbacks[i];
    <span class="shj-syn-cmnt">// Y se los pasamos al callback
</span>    callback<span class="shj-syn-oper">.</span><span class="shj-syn-func">apply</span>(<span class="shj-syn-num">null</span><span class="shj-syn-oper">,</span> args);
  }
};
</code></pre>
<p>Y ya está, ahora podemos pasarle argumentos a <code>.done()</code>:</p>

<pre><code class="code-block shj-lang-js"><span class="shj-syn-kwd">function</span> <span class="shj-syn-func">descargar</span>(url) {
  <span class="shj-syn-kwd">var</span> promise <span class="shj-syn-oper">=</span> <span class="shj-syn-kwd">new</span> <span class="shj-syn-class">Promise</span>();
  petició<span class="shj-syn-func">nHttp</span>(url<span class="shj-syn-oper">,</span> <span class="shj-syn-kwd">function</span> (codigoHtml) {
    promise<span class="shj-syn-oper">.</span><span class="shj-syn-func">done</span>(codigoHtml);
  });
  <span class="shj-syn-kwd">return</span> promise;
}

<span class="shj-syn-func">descargar</span>(<span class="shj-syn-str">'www.google.com'</span>)<span class="shj-syn-oper">.</span><span class="shj-syn-func">then</span>(<span class="shj-syn-kwd">function</span> (codigoHtml) {
  <span class="shj-syn-func">alert</span>(codigoHtml);
});
</code></pre>
<p>Ya tenemos nuestra versión 0.1 de la clase Promise :D</p>
<h3 id="segundo-gesti-n-de-errores">Segundo: Gestión de errores</h3>
<p>Hasta aquí ya tenemos un Promise con el que avisar cuando acaba una tarea asíncrona, pero nos olvidamos de algo muy importante, a la hora de programar no todo sale como quisiéramos y muchas veces nos encontramos con errores, que pasaría si <code>peticiónHttp()</code> fallara? Que jamás se ejecutaría el <code>.done()</code> del Promise que hemos devuelto y el callback esperará sentado a que lo llamen el resto de su vida. Hay que preparar el Promise para que avise cuando algo va mal. Necesitamos añadirle al Promise:</p>

<ul>
<li>Poder añadir callbacks especiales para cuando se produzca un error</li>
<li>Avisarle cuando se produzca un error</li>
<li>Que le pase al callback de error el objeto Error que se ha lanzado</li>
</ul>
<p>Lo primero es que el Promise no solo reciba un callback normal sino que también reciba otro callback que será ejecutado solo si se produce un error. Una idea que me gusta es dárselo al método <code>.then()</code> como segundo argumento, ya que el primero es el callback normal. Y éste debería guardarlo, para ello debemos crear otro Array donde guardar los callbacks de errores:</p>

<pre><code class="code-block shj-lang-js"><span class="shj-syn-kwd">function</span> <span class="shj-syn-class">Promise</span>() {
  <span class="shj-syn-kwd">this</span><span class="shj-syn-oper">.</span>_callbacks <span class="shj-syn-oper">=</span> [];
  <span class="shj-syn-kwd">this</span><span class="shj-syn-oper">.</span>_onError <span class="shj-syn-oper">=</span> [];
}
<span class="shj-syn-class">Promise</span><span class="shj-syn-oper">.</span>prototype<span class="shj-syn-oper">.</span><span class="shj-syn-func">then</span> <span class="shj-syn-oper">=</span> <span class="shj-syn-kwd">function</span> (callback<span class="shj-syn-oper">,</span> onError) {
  <span class="shj-syn-cmnt">// Validamos el callback normal
</span>  <span class="shj-syn-kwd">if</span> (<span class="shj-syn-kwd">typeof</span> callback <span class="shj-syn-oper">!==</span> <span class="shj-syn-str">'function'</span>) {
    <span class="shj-syn-kwd">throw</span> <span class="shj-syn-kwd">new</span> <span class="shj-syn-class">Error</span>(<span class="shj-syn-str">"[Promise.then] El argumento 'callback' no es una función "</span> <span class="shj-syn-oper">+</span> <span class="shj-syn-kwd">typeof</span> callback);
  }
  <span class="shj-syn-cmnt">// Validamos el callback de error. Como es opcional puede ser 'undefined' o una función
</span>  <span class="shj-syn-kwd">if</span> (onError <span class="shj-syn-oper">&#38;&#38;</span> <span class="shj-syn-kwd">typeof</span> onError <span class="shj-syn-oper">!==</span> <span class="shj-syn-str">'function'</span>) {
    <span class="shj-syn-kwd">throw</span> <span class="shj-syn-kwd">new</span> <span class="shj-syn-class">Error</span>(<span class="shj-syn-str">"[Promise.then] El argumento 'onError' no es una función "</span> <span class="shj-syn-oper">+</span> <span class="shj-syn-kwd">typeof</span> onError);
  }

  <span class="shj-syn-kwd">this</span><span class="shj-syn-oper">.</span>_callbacks<span class="shj-syn-oper">.</span><span class="shj-syn-func">push</span>(callback);
  <span class="shj-syn-cmnt">// Si no era undefined debe ser una función, porque ya lo validamos
</span>  <span class="shj-syn-kwd">if</span> (onError) {
    <span class="shj-syn-kwd">this</span><span class="shj-syn-oper">.</span>_onError<span class="shj-syn-oper">.</span><span class="shj-syn-func">push</span>(onError);
  }
};
</code></pre>
<p>Como se ve es prácticamente lo mismo que para los callbacks, ya que se trata de lo mismo, un callback por si hay errores. Ahora vamos a matar los últimos dos puntos de un tiro. Añadiremos un método para avisar al Promise cuando se produzca un error y le pasaremos el objeto Error para que lo pase a todos los callbacks de error.</p>

<pre><code class="code-block shj-lang-js"><span class="shj-syn-class">Promise</span><span class="shj-syn-oper">.</span>prototype<span class="shj-syn-oper">.</span><span class="shj-syn-func">fail</span> <span class="shj-syn-oper">=</span> <span class="shj-syn-kwd">function</span> (error) {
  <span class="shj-syn-kwd">var</span> callback;
  <span class="shj-syn-kwd">for</span> (<span class="shj-syn-kwd">var</span> i <span class="shj-syn-oper">=</span> <span class="shj-syn-num">0</span>; i <span class="shj-syn-oper">&lt;</span> <span class="shj-syn-kwd">this</span><span class="shj-syn-oper">.</span>_onError<span class="shj-syn-oper">.</span>length; i<span class="shj-syn-oper">++</span>) {
    callback <span class="shj-syn-oper">=</span> <span class="shj-syn-kwd">this</span><span class="shj-syn-oper">.</span>_onError[i];
    <span class="shj-syn-func">callback</span>(error);
  }
};
</code></pre>
<p>Y ya está, ahora cuando llamemos al método <code>.fail()</code> llamará a todos los callbacks de error y les pasará el objeto Error. Ahora podemos adaptar la función <code>descargar()</code> para que también notifique cuando se produzca un error:</p>

<pre><code class="code-block shj-lang-js"><span class="shj-syn-kwd">function</span> <span class="shj-syn-func">descargar</span>(url) {
  <span class="shj-syn-kwd">var</span> promise <span class="shj-syn-oper">=</span> <span class="shj-syn-kwd">new</span> <span class="shj-syn-class">Promise</span>();
  <span class="shj-syn-kwd">try</span> {
    petició<span class="shj-syn-func">nHttp</span>(url<span class="shj-syn-oper">,</span> <span class="shj-syn-kwd">function</span> (codigoHtml) {
      promise<span class="shj-syn-oper">.</span><span class="shj-syn-func">done</span>(codigoHtml);
    });
  } <span class="shj-syn-kwd">catch</span> (error) {
    promise<span class="shj-syn-oper">.</span><span class="shj-syn-func">fail</span>(error);
  }
  <span class="shj-syn-kwd">return</span> promise;
}
<span class="shj-syn-func">descargar</span>(<span class="shj-syn-str">'www.google.com'</span>)<span class="shj-syn-oper">.</span><span class="shj-syn-func">then</span>(<span class="shj-syn-kwd">function</span> (codigoHtml) {
  <span class="shj-syn-func">alert</span>(codigoHtml);
});
</code></pre>
<p>Ahora ya podemos decir que tenemos la versión 0.2 del Promise tengo que dejar para otro post métodos más complicados como <code>.then()</code> concatenados y el <code>.and()</code> porque ya es muy tarde. Aquí dejo el código completo al que le he añadido la propiedad <code>_estado</code> para evitar que se pueda cumplir o fallar un Promise cuando ya está cumplido o fallado.</p>

<pre><code class="code-block shj-lang-js"><span class="shj-syn-kwd">function</span> <span class="shj-syn-class">Promise</span>() {
  <span class="shj-syn-kwd">this</span><span class="shj-syn-oper">.</span>_callbacks <span class="shj-syn-oper">=</span> [];
  <span class="shj-syn-kwd">this</span><span class="shj-syn-oper">.</span>_onError <span class="shj-syn-oper">=</span> [];
  <span class="shj-syn-kwd">this</span><span class="shj-syn-oper">.</span>_estado <span class="shj-syn-oper">=</span> <span class="shj-syn-str">'esperando'</span>;
}

<span class="shj-syn-class">Promise</span><span class="shj-syn-oper">.</span>prototype<span class="shj-syn-oper">.</span><span class="shj-syn-func">then</span> <span class="shj-syn-oper">=</span> <span class="shj-syn-kwd">function</span> (callback<span class="shj-syn-oper">,</span> onError) {
  <span class="shj-syn-cmnt">// Validamos el callback normal
</span>  <span class="shj-syn-kwd">if</span> (<span class="shj-syn-kwd">typeof</span> callback <span class="shj-syn-oper">!==</span> <span class="shj-syn-str">'function'</span>)
    <span class="shj-syn-kwd">throw</span> <span class="shj-syn-kwd">new</span> <span class="shj-syn-class">Error</span>(<span class="shj-syn-str">"[Promise.then] El argumento 'callback' no es una función "</span> <span class="shj-syn-oper">+</span> <span class="shj-syn-kwd">typeof</span> callback);

  <span class="shj-syn-cmnt">// Validamos el callback de error. Como es opcional puede ser 'undefined' o una función
</span>  <span class="shj-syn-kwd">if</span> (onError <span class="shj-syn-oper">&#38;&#38;</span> <span class="shj-syn-kwd">typeof</span> onError <span class="shj-syn-oper">!==</span> <span class="shj-syn-str">'function'</span>)
    <span class="shj-syn-kwd">throw</span> <span class="shj-syn-kwd">new</span> <span class="shj-syn-class">Error</span>(<span class="shj-syn-str">"[Promise.then] El argumento 'onError' no es una función "</span> <span class="shj-syn-oper">+</span> <span class="shj-syn-kwd">typeof</span> onError);

  <span class="shj-syn-kwd">this</span><span class="shj-syn-oper">.</span>_callbacks<span class="shj-syn-oper">.</span><span class="shj-syn-func">push</span>(callback);
  <span class="shj-syn-cmnt">// Si no era undefined debe ser una función, porque ya lo validamos
</span>  <span class="shj-syn-kwd">if</span> (onError) <span class="shj-syn-kwd">this</span><span class="shj-syn-oper">.</span>_onError<span class="shj-syn-oper">.</span><span class="shj-syn-func">push</span>(onError);
};

<span class="shj-syn-class">Promise</span><span class="shj-syn-oper">.</span>prototype<span class="shj-syn-oper">.</span><span class="shj-syn-func">done</span> <span class="shj-syn-oper">=</span> <span class="shj-syn-kwd">function</span> (error) {
  <span class="shj-syn-kwd">if</span> (<span class="shj-syn-kwd">this</span><span class="shj-syn-oper">.</span>_estado <span class="shj-syn-oper">!==</span> <span class="shj-syn-str">'esperando'</span>) <span class="shj-syn-kwd">throw</span> <span class="shj-syn-kwd">new</span> <span class="shj-syn-class">Error</span>(<span class="shj-syn-str">'Intentando cumplir un promise que ya ha finalizado'</span>);

  <span class="shj-syn-kwd">this</span><span class="shj-syn-oper">.</span>_estado <span class="shj-syn-oper">=</span> <span class="shj-syn-str">'cumplido'</span>;
  <span class="shj-syn-cmnt">// Guardamos los argumentos que se le ha pasado a .done()
</span>  <span class="shj-syn-kwd">var</span> args <span class="shj-syn-oper">=</span> arguments;
  <span class="shj-syn-kwd">var</span> callback;

  <span class="shj-syn-kwd">for</span> (<span class="shj-syn-kwd">var</span> i <span class="shj-syn-oper">=</span> <span class="shj-syn-num">0</span>; i <span class="shj-syn-oper">&lt;</span> <span class="shj-syn-kwd">this</span><span class="shj-syn-oper">.</span>_callbacks<span class="shj-syn-oper">.</span>length; i<span class="shj-syn-oper">++</span>) {
    callback <span class="shj-syn-oper">=</span> <span class="shj-syn-kwd">this</span><span class="shj-syn-oper">.</span>_callbacks[i];
    <span class="shj-syn-cmnt">// Y se los pasamos al callback
</span>    callback<span class="shj-syn-oper">.</span><span class="shj-syn-func">apply</span>(<span class="shj-syn-num">null</span><span class="shj-syn-oper">,</span> args);
  }
};

<span class="shj-syn-class">Promise</span><span class="shj-syn-oper">.</span>prototype<span class="shj-syn-oper">.</span><span class="shj-syn-func">fail</span> <span class="shj-syn-oper">=</span> <span class="shj-syn-kwd">function</span> (error) {
  <span class="shj-syn-kwd">if</span> (<span class="shj-syn-kwd">this</span><span class="shj-syn-oper">.</span>_estado <span class="shj-syn-oper">!==</span> <span class="shj-syn-str">'esperando'</span>) <span class="shj-syn-kwd">throw</span> <span class="shj-syn-kwd">new</span> <span class="shj-syn-class">Error</span>(<span class="shj-syn-str">'Intentando hacer fallar un promise que ya ha finalizado'</span>);

  <span class="shj-syn-kwd">this</span><span class="shj-syn-oper">.</span>_estado <span class="shj-syn-oper">=</span> <span class="shj-syn-str">'fallado'</span>;
  <span class="shj-syn-kwd">var</span> callback;

  <span class="shj-syn-kwd">for</span> (<span class="shj-syn-kwd">var</span> i <span class="shj-syn-oper">=</span> <span class="shj-syn-num">0</span>; i <span class="shj-syn-oper">&lt;</span> <span class="shj-syn-kwd">this</span><span class="shj-syn-oper">.</span>_onError<span class="shj-syn-oper">.</span>length; i<span class="shj-syn-oper">++</span>) {
    callback <span class="shj-syn-oper">=</span> <span class="shj-syn-kwd">this</span><span class="shj-syn-oper">.</span>_onError[i];
    <span class="shj-syn-func">callback</span>(error);
  }
};
</code></pre>

</article></div><div class="css-1ljukny"><input type="color" id="color-picker" value="#EFE751"/>
          <script>
            document.querySelector('#color-picker').addEventListener('input', (e) => {
              document.body.style.setProperty('--color-primary', e.target.value);
            });
          </script>
        </div></body></html>