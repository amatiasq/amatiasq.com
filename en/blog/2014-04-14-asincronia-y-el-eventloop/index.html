<!DOCTYPE html><html lang="en"><head><meta charSet="UTF-8"/><meta name="description" content="A. Matías Quezada&#x27;s personal website"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Asynchrony and the Event Loop (spanish) | A. Matías Quezada</title><style> *, ::before, ::after { box-sizing: border-box; } html { line-sizing: normal; } body { margin: 0; } [hidden] { display: none; } h1 { font-size: 2rem; } h2 { font-size: 1.5rem; } h3 { font-size: 1.17rem; } h4 { font-size: 1.00rem; } h5 { font-size: 0.83rem; } h6 { font-size: 0.67rem; } h1 { margin: 0.67em 0; } pre { white-space: pre-wrap; } hr { border-style: solid; border-width: 1px 0 0; color: inherit; height: 0; overflow: visible; } img, svg, video, canvas, audio, iframe, embed, object { display: block; vertical-align: middle; max-width: 100%; } audio:not([controls]) { display:none; } picture { display: contents; } source { display: none; } img, svg, video, canvas { height: auto; } audio { width: 100%; } img { border-style: none; } svg { overflow: hidden; } article, aside, details, figcaption, figure, footer, header, hgroup, main, nav, section { display: block; } [type='checkbox'], [type='radio'] { box-sizing: border-box; padding: 0; } @media (prefers-reduced-motion: reduce) { *, ::before, ::after { animation-name: none !important; transition: none !important; } } </style><style>@font-face { font-family: 'Inconsolata'; font-style: normal; font-weight: 400; font-stretch: normal; font-display: swap; src: url(https://fonts.gstatic.com/s/inconsolata/v30/QldgNThLqRwH-OJ1UHjlKENVzkWGVkL3GZQmAwLYxYWI2qfdm7Lpp4U8aRo.ttf) format('truetype'); } @font-face { font-family: 'Inconsolata'; font-style: normal; font-weight: 700; font-stretch: normal; font-display: swap; src: url(https://fonts.gstatic.com/s/inconsolata/v30/QldgNThLqRwH-OJ1UHjlKENVzkWGVkL3GZQmAwLYxYWI2qfdm7Lpp2I7aRo.ttf) format('truetype'); } @font-face { font-family: 'Nunito'; font-style: normal; font-weight: 400; font-display: swap; src: url(https://fonts.gstatic.com/s/nunito/v24/XRXI3I6Li01BKofiOc5wtlZ2di8HDLshRTM.ttf) format('truetype'); } @font-face { font-family: 'Nunito'; font-style: normal; font-weight: 700; font-display: swap; src: url(https://fonts.gstatic.com/s/nunito/v24/XRXI3I6Li01BKofiOc5wtlZ2di8HDFwmRTM.ttf) format('truetype'); } @font-face { font-family: 'Nunito Sans'; font-style: normal; font-weight: 400; font-display: swap; src: url(https://fonts.gstatic.com/s/nunitosans/v12/pe0qMImSLYBIv1o4X1M8cfe6.ttf) format('truetype'); } @font-face { font-family: 'Nunito Sans'; font-style: normal; font-weight: 700; font-display: swap; src: url(https://fonts.gstatic.com/s/nunitosans/v12/pe03MImSLYBIv1o4X1M8cc8GBv5q.ttf) format('truetype'); } </style><style> :root { background-color: #263238; color: #FDFBF8; font-family: Nunito Sans, sans-serif; font-size: 18px; line-height: 1.5; letter-spacing: 0.5px; --color-primary: #8BB9F8; /* azul */ --color-primary: #8BA9FF; /* French Sky Blue */ --color-primary: #70ACFF; /* French Sky Blue 2 */ --color-primary: #FC9173; /* Dark Salmom */ --color-primary: #00ff01; /* Verde familia */ --color-primary: #00ffe1; /* Cyan Romi */ --color-primary: #EFE751; --color-primary-soft: var(--color-primary)88; } header, h1, h2, h3, h4, h5, h6 { font-family: Nunito, sans-serif; } a { color: var(--color-primary); text-decoration: none; } a[href^="http"]:not(.no-external)::after { content: ''; margin-left: 0.5em; width: 0.8em; height: 0.8em; display: inline-block; background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='%23EFE751' stroke='%23EFE751'%3E%3Cpath d='M6 17c2.269-9.881 11-11.667 11-11.667v-3.333l7 6.637-7 6.696v-3.333s-6.17-.171-11 5zm12 .145v2.855h-16v-12h6.598c.768-.787 1.561-1.449 2.339-2h-10.937v16h20v-6.769l-2 1.914z'/%3E%3C/svg%3E"); background-repeat: no-repeat; background-position: center; background-size: contain; } :where(.bouncy-box, article a) { position: relative; display: inline-block; --underline-width: 1px; --padding: 8; transform: scale(1) rotate(0); transition: transform 0.3s cubic-bezier(0.25, 0.1, 0, 2.05); } :where(.bouncy-box, article a):hover { transform: scale(1.1) rotate(0); } :where(.bouncy-box, article a):before { content: ''; position: absolute; z-index: -1; border-radius: 8px; opacity: 1; background: var(--color-primary); inset: calc(100% - var(--underline-width)) 0 0 0; height: var(--underline-width); transition-property: inset, opacity, height, background; transition-duration: 0.3s; transition-timing-function: cubic-bezier(0,.5,0,1); } :where(.bouncy-box, article a):hover:before { inset: calc(var(--padding) * -1px) calc(var(--padding) * -2px); background: black; opacity: 0.8; height: calc(100% + calc(var(--padding) * 2px)); } ol { padding: 0; } li { list-style: none; } code { font-family: Inconsolata, monospace; } svg { fill: #FDFBF8; } </style><style>.css-1ljukny{position:fixed;bottom:1rem;right:1rem;background-color:black;}.css-1ljukny input{border:none;width:3rem;height:3rem;}
.css-5a8vm2 .shj-inline{margin:0;padding:2px 5px;display:inline-block;border-radius:5px;}.css-5a8vm2 [class*=shj-lang-]::selection,.css-5a8vm2 [class*=shj-lang-] ::selection{background:#bdf5;}.css-5a8vm2 [class*=shj-lang-]>div{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;overflow:auto;}.css-5a8vm2 [class*=shj-lang-]>div :last-child{-webkit-flex:1;-ms-flex:1;flex:1;outline:none;}.css-5a8vm2 .shj-syn-cmnt{font-style:italic;}.css-5a8vm2 .shj-syn-err,.css-5a8vm2 .shj-syn-kwd{color:#e16;}.css-5a8vm2 .shj-syn-num,.css-5a8vm2 .shj-syn-class{color:#f60;}.css-5a8vm2 .shj-numbers,.css-5a8vm2 .shj-syn-cmnt{color:#999;}.css-5a8vm2 .shj-syn-insert,.css-5a8vm2 .shj-syn-str{color:#7d8;}.css-5a8vm2 .shj-syn-bool{color:#3bf;}.css-5a8vm2 .shj-syn-type,.css-5a8vm2 .shj-syn-oper{color:#5af;}.css-5a8vm2 .shj-syn-section,.css-5a8vm2 .shj-syn-func{color:#84f;}.css-5a8vm2 .shj-syn-deleted,.css-5a8vm2 .shj-syn-var{color:#f44;}.css-5a8vm2 .shj-oneline{padding:12px 10px;}.css-5a8vm2 .shj-lang-http.shj-oneline .shj-syn-kwd{background:#25f;color:#fff;padding:5px 7px;border-radius:5px;}.css-5a8vm2 .shj-multiline.shj-mode-header{padding:20px;}.css-5a8vm2 .shj-multiline.shj-mode-header:before{content:attr(data-lang);color:#58f;display:block;padding:10px 20px;background:#58f3;border-radius:5px;margin-bottom:20px;}.css-5a8vm2 [class*=shj-lang-]:before{color:#6f9aff;}.css-5a8vm2 .shj-syn-deleted,.css-5a8vm2 .shj-syn-err,.css-5a8vm2 .shj-syn-var{color:#e06c75;}.css-5a8vm2 .shj-syn-section,.css-5a8vm2 .shj-syn-oper,.css-5a8vm2 .shj-syn-kwd{color:#c678dd;}.css-5a8vm2 .shj-syn-class{color:#e5c07b;}.css-5a8vm2 .shj-numbers,.css-5a8vm2 .shj-syn-cmnt{color:#76839a;}.css-5a8vm2 .shj-syn-insert{color:#98c379;}.css-5a8vm2 .shj-syn-type{color:#56b6c2;}.css-5a8vm2 .shj-syn-num,.css-5a8vm2 .shj-syn-bool{color:#d19a66;}.css-5a8vm2 .shj-syn-str,.css-5a8vm2 .shj-syn-func{color:#61afef;}
.css-2bthvy{font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Helvetica,Arial,sans-serif,'Apple Color Emoji','Segoe UI Emoji';}.css-2bthvy li{list-style:initial;}.css-2bthvy ul,.css-2bthvy ol{margin:20px 0;padding:reset;}.css-2bthvy p{margin:20px 0;text-align:justify;}.css-2bthvy blockquote{border-left:5px solid #586369;margin-left:0;padding-left:1em;}.css-2bthvy code:not(.code-block){background-color:#161b22;padding:4px;border-radius:4px;}.css-2bthvy pre{--code-block-margin:3em;--code-block-padding:1em;--code-inline-padding:min(3em, var(--container-side-gap));margin:var(--code-block-margin) 0;padding:var(--code-block-padding) 0;position:relative;white-space:pre;}.css-2bthvy pre .code-block{display:block;width:var(--available-width);white-space:pre;text-shadow:none;font-size:18px;line-height:24px;box-sizing:border-box;max-width:var(--available-width);overflow-x:auto;color:#abb2bf;}.css-2bthvy pre::before{content:'';inset:calc(var(--code-block-padding) * -1) calc(var(--code-inline-padding) * -1);background:#161b22;border-radius:10px;box-shadow:0 0 5px #0001;position:absolute;z-index:-1;max-width:100vw;}
.css-84fmch{opacity:0.8;font-size:0.8em;font-family:Inconsolata,monospace;color:#FDFBF8;white-space:nowrap;}
.css-v6zv8e{font-family:Nunito,sans-serif;font-weight:700;font-size:32px;}
.css-relzm4{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:justify;-webkit-justify-content:space-between;justify-content:space-between;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;}@media (min-width: 769px){.css-relzm4{-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}}
.css-18junyj{font-size:24px;color:white;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:baseline;-webkit-box-align:baseline;-ms-flex-align:baseline;align-items:baseline;gap:12px;letter-spacing:1px;}.css-18junyj abbr{display:inline-block;width:0.8em;overflow:hidden;-webkit-transition:width 0.3s ease;transition:width 0.3s ease;}.css-18junyj:hover abbr{width:3.3em;}
.css-1y1oy5{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;gap:12px;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}
.css-18wymod{--container-side-gap:1rem;--container-width:40rem;--container-sides-gap:calc(var(--container-side-gap) * 2);--available-width:min(
      calc(100vw - var(--container-sides-gap)),
      calc(var(--container-width) - var(--container-sides-gap))
    );max-width:var(--container-width);padding-left:var(--container-side-gap);padding-right:var(--container-side-gap);margin-left:auto;margin-right:auto;}@media (min-width: 769px){.css-18wymod{--container-width:50rem;--container-side-gap:3rem;}}@media (min-width: 1200px){.css-18wymod{--container-width:60rem;}}
.css-x7nza2{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;gap:12px;}.css-x7nza2 a{color:var(--color-primary);margin-left:12px;border-bottom:1px solid transparent;-webkit-transform:translate(0px, 0px);-moz-transform:translate(0px, 0px);-ms-transform:translate(0px, 0px);transform:translate(0px, 0px);}.css-x7nza2 a.parent{border-bottom:1px solid #586369;}.css-x7nza2 a:hover{border-bottom:1px solid var(--color-primary);-webkit-transition:-webkit-transform 1s ease;transition:transform 1s ease;-webkit-transform:translate(0px, -3px);-moz-transform:translate(0px, -3px);-ms-transform:translate(0px, -3px);transform:translate(0px, -3px);}
.css-17rdaxl{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:justify;-webkit-justify-content:space-between;justify-content:space-between;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;}@media (min-width: 769px){.css-17rdaxl{-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;}}
.css-1witpq9{padding:20px 0;background-color:#161b22;color:#FDFBF8;border-bottom:2px solid #586369;}@media (min-width: 769px){.css-1witpq9{position:-webkit-sticky;position:sticky;top:0;z-index:1;}}
.css-1e8d7s{padding-bottom:4rem;}
.css-1p4f3y5{display:grid;padding-top:20px;gap:12px;}</style></head><body class=" css-1e8d7s"><header class="css-1witpq9 "><div class="css-17rdaxl css-18wymod"><h2 class="css-1y1oy5"><a href="../.." class="css-18junyj inactive">{ <abbr>Adrian</abbr> Matías Quezada }</a></h2><nav class="css-x7nza2"><a href=".." class="parent">Blog</a><a href="../../projects" class="">Projects</a><a href="../../career" class="">CV</a><a href="../../../es/blog/2014-04-14-asincronia-y-el-eventloop" class="">🇪🇸</a></nav></div></header><div class="css-1p4f3y5 css-18wymod"><h2 class="css-relzm4  css-v6zv8e">Asynchrony and the Event Loop (spanish)<time class="css-84fmch " dateTime="04/14/2014">Apr 14, 2014</time></h2><article class="md css-2bthvy css-5a8vm2 "><p>Me gustaría hacer un repaso al tema de la asincronía en Javascript porque me llama la atención que pese a tener casi 20 años es un tema que sigue madurando y he visto surgir buenas ideas recientemente.</p>
<h3 id="el-event-loop">El event loop</h3>
<p>Primero lo primero, de donde sale la asincronía. Javascript es un lenguaje cuya ejecución se basa en lo que se llama <strong>event loop</strong> (bucle de eventos). El <em>event loop</em> es una cola donde se van añadiendo los bloques de código que quieren ejecutarse, por ejemplo: cuando el navegador está renderizando el HTML de una página y se encuentra un tag <code>&lt;script&gt;</code> el contenido de ese elemento se añade al <em>event loop</em> para que sea ejecutado tan pronto como sea posible.</p>
<!-- end extract -->
<p>Lo mismo ocurre cuando la página ya está cargada y el usuario hace click. Si tenemos una función listener (también llamado callback) escuchando los eventos click de un objeto esa función se añade a la cola del <em>event loop</em> para que el sistema lo ejecute tan pronto como sea posible.</p>
<p>De esta forma todos los bloques de código que se ejecutan en javascript han sido bloques de código que entraron a la cola del <em>event loop</em> y cuando llegó su turno fueron ejecutados. Podemos entenderlo más fácilmente si implementamos un falso event loop en Javascript:</p>

<pre><code class="code-block shj-lang-js"><span class="shj-syn-kwd">var</span> eventLoop <span class="shj-syn-oper">=</span> {
  _queue<span class="shj-syn-oper">:</span> []<span class="shj-syn-oper">,</span>

  add<span class="shj-syn-oper">:</span> <span class="shj-syn-kwd">function</span> (fn) {
    <span class="shj-syn-cmnt">// añadimos la función a la cola
</span>    <span class="shj-syn-kwd">this</span><span class="shj-syn-oper">.</span>_queue<span class="shj-syn-oper">.</span><span class="shj-syn-func">push</span>(fn);

    <span class="shj-syn-cmnt">// si está desocupado ejecutar la función
</span>    <span class="shj-syn-kwd">if</span> (<span class="shj-syn-oper">!</span><span class="shj-syn-kwd">this</span><span class="shj-syn-oper">.</span>running) <span class="shj-syn-kwd">this</span><span class="shj-syn-oper">.</span><span class="shj-syn-func">executeNext</span>();
  }<span class="shj-syn-oper">,</span>

  executeNext<span class="shj-syn-oper">:</span> <span class="shj-syn-kwd">function</span> () {
    <span class="shj-syn-kwd">if</span> (<span class="shj-syn-kwd">this</span><span class="shj-syn-oper">.</span>running <span class="shj-syn-oper">||</span> <span class="shj-syn-kwd">this</span><span class="shj-syn-oper">.</span>_queue<span class="shj-syn-oper">.</span>length <span class="shj-syn-oper">===</span> <span class="shj-syn-num">0</span>) <span class="shj-syn-kwd">return</span>;

    <span class="shj-syn-kwd">this</span><span class="shj-syn-oper">.</span>running <span class="shj-syn-oper">=</span> <span class="shj-syn-bool">true</span>;
    <span class="shj-syn-kwd">var</span> block <span class="shj-syn-oper">=</span> <span class="shj-syn-kwd">this</span><span class="shj-syn-oper">.</span>_queue<span class="shj-syn-oper">.</span><span class="shj-syn-func">shift</span>();
    <span class="shj-syn-func">block</span>();
    <span class="shj-syn-kwd">this</span><span class="shj-syn-oper">.</span>running <span class="shj-syn-oper">=</span> <span class="shj-syn-bool">false</span>;

    <span class="shj-syn-kwd">this</span><span class="shj-syn-oper">.</span><span class="shj-syn-func">executeNext</span>();
  }<span class="shj-syn-oper">,</span>
};
</code></pre>
<p><a target="_black" href="http://jsfiddle.net/amatiasq/k9ebk/">Pruébame</a></p>
<p>Esto significa que mientras un bloque esté ejecutándose ningún otro bloque de código puede estar ejecutándose a la vez. Pero si un proceso tarda mucho (como leer el disco, comunicarse con el servidor, esperar una determinada cantidad de tiempo...) lo que hacemos es pasarles una función que será añadida al <em>event loop</em> cuando el proceso acabe.</p>
<p>Cada &quot;bloque&quot; que el <em>event loop</em> ejecuta se llama &quot;un tick del event loop&quot;, de ahí el nombre de la función <code>process.nextTick</code> de NodeJS.</p>
<p>Una forma sencilla de controlar el <em>event loop</em> es mediante <code>setTimeout</code>, <code>setInterval</code> y <code>setImmediate</code>, podemos crear funciones similares que hagan la misma funcionalidad (simplificada) pero para nuestro <code>eventLoop</code>:</p>

<pre><code class="code-block shj-lang-js"><span class="shj-syn-kwd">function</span> <span class="shj-syn-func">mySetImmediate</span>(fn) {
  eventLoop<span class="shj-syn-oper">.</span><span class="shj-syn-func">add</span>(fn);
}

<span class="shj-syn-kwd">function</span> <span class="shj-syn-func">mySetTimeout</span>(fn<span class="shj-syn-oper">,</span> milliseconds) {
  <span class="shj-syn-cmnt">// la unica forma de dejar pasar el tiempo
</span>  <span class="shj-syn-cmnt">// es mediante el VERDADERO setTimeout ;)
</span>  <span class="shj-syn-func">setTimeout</span>(<span class="shj-syn-kwd">function</span> () {
    <span class="shj-syn-func">mySetImmediate</span>(fn);
  }<span class="shj-syn-oper">,</span> milliseconds);
}

<span class="shj-syn-kwd">function</span> <span class="shj-syn-func">mySetInterval</span>(fn<span class="shj-syn-oper">,</span> milliseconds) {
  <span class="shj-syn-kwd">function</span> <span class="shj-syn-func">execute</span>() {
    <span class="shj-syn-func">fn</span>();
    <span class="shj-syn-func">mySetTimeout</span>(execute<span class="shj-syn-oper">,</span> milliseconds);
  }

  <span class="shj-syn-func">mySetTimeout</span>(execute<span class="shj-syn-oper">,</span> milliseconds);
}
</code></pre>
<p>Como se puede ver tanto setTimeout como setInterval esperan la cantidad de milisegundos definida y <strong>entonces añaden</strong> el bloque al <em>event loop</em>, si el <em>event loop</em> está ocupado en ese momento puede tardar un poco más de lo esperado en ejecutarse nuestra función.</p>
<p>Entiendiendo esto es más fácil entender porqué Javascript funciona de la forma que funciona.</p>

<ul>
<li>Solo hay un bloque de código ejecutandose en cada momento</li>
<li>Los bloques se encolan</li>
<li>Se considera asíncrono a una sección de código que será ejecutada en un &quot;tick&quot; distinto</li>
</ul>

<pre><code class="code-block shj-lang-js"><span class="shj-syn-kwd">var</span> a <span class="shj-syn-oper">=</span> <span class="shj-syn-num">1</span>;
<span class="shj-syn-func">setTimeout</span>(<span class="shj-syn-kwd">function</span> () {
  <span class="shj-syn-cmnt">// esta función es asíncrona porque el tick que llama a setTimeout
</span>  <span class="shj-syn-cmnt">// tiene que acabar antes que esta función sea invocada.
</span>  a <span class="shj-syn-oper">=</span> <span class="shj-syn-num">2</span>;
}<span class="shj-syn-oper">,</span> <span class="shj-syn-num">100</span>);
</code></pre>
<p>En el caso de javascript para el navegador además nos encontramos con que el <em>event loop</em> es compartido por Javascript y el motor de renderizado del navegador. Como el <em>event loop</em> solo puede ejecutar un bloque por vez resulta que si estamos ejecutando Javascript el navegador no puede renderizar la página y vice versa, si la página tarda mucho en renderizarse retrasará la ejecución del Javascript. Esto es así porque desde Javascript podemos modificar el DOM y si el navegador intenta renderizar la página mientras nosotros la modificamos tendríamos otro tipo de problemas peores.</p>
<p>Pero es importante tener esto en cuenta ya que un proceso Javascript que tarde demasiado &quot;congelará&quot; la página, no funcionarán los clicks, scroll, ni siquiera los <code>:hover</code>.</p>
<h3 id="un-poco-de-historia">Un poco de historia</h3>
<p>Cuando Javascript fue desarrollado la comunicación asíncrona con el DOM se solucionó mediante eventos y tiene todo el sentido del mundo. Quieres saber cuando el usuario hace click en un elemento? Registra el evento y el navegador te avisará, quieres saber cuando el usuario haga scroll? registra el evento!</p>
<p>El problema empezó cuando empezamos a usar eventos para cosas no tan claras, como eventos puntuales que solo se disparaban una vez:</p>

<pre><code class="code-block shj-lang-js">window<span class="shj-syn-oper">.</span><span class="shj-syn-func">addEventListener</span>(<span class="shj-syn-str">'load'</span><span class="shj-syn-oper">,</span> <span class="shj-syn-kwd">function</span>() { <span class="shj-syn-oper">...</span> });
<span class="shj-syn-func">someAjax</span>()<span class="shj-syn-oper">.</span><span class="shj-syn-func">onready</span> <span class="shj-syn-oper">=</span> <span class="shj-syn-kwd">function</span>() { <span class="shj-syn-oper">...</span> };
</code></pre>
<p>Incluso para controlar errores</p>

<pre><code class="code-block shj-lang-js">xhr<span class="shj-syn-oper">.</span><span class="shj-syn-func">onerror</span> <span class="shj-syn-oper">=</span> <span class="shj-syn-kwd">function</span>() { <span class="shj-syn-oper">...</span> };
document<span class="shj-syn-oper">.</span><span class="shj-syn-func">querySelector</span>(<span class="shj-syn-str">"script"</span>)<span class="shj-syn-oper">.</span><span class="shj-syn-func">onerror</span> <span class="shj-syn-oper">=</span> <span class="shj-syn-kwd">function</span>() { <span class="shj-syn-oper">...</span> };
</code></pre>
<p>Hasta para controlar un progreso (en APIs modernas incluso)</p>

<pre><code class="code-block shj-lang-js"><span class="shj-syn-kwd">var</span> reader <span class="shj-syn-oper">=</span> <span class="shj-syn-kwd">new</span> <span class="shj-syn-class">FileReader</span>();
reader<span class="shj-syn-oper">.</span><span class="shj-syn-func">onprogress</span> <span class="shj-syn-oper">=</span> <span class="shj-syn-kwd">function</span>() { <span class="shj-syn-oper">...</span> };
</code></pre>
<p>Pero al no estar acostumbrados a trabajar con asincronía de esta forma no fuimos capaces de ver que estabamos usando una herramienta para todo, como dicen por ahí &quot;para un hombre con un martillo todo es un clavo&quot;.</p>
<p>En node decidieron adaptar el patrón &quot;Continuous Passing Style&quot;, que consiste en pasar callbacks a funciones asíncronas</p>

<pre><code class="code-block shj-lang-js">fs<span class="shj-syn-oper">.</span><span class="shj-syn-func">readFile</span>(<span class="shj-syn-str">"foo"</span><span class="shj-syn-oper">,</span> <span class="shj-syn-kwd">function</span>() { <span class="shj-syn-oper">...</span> });
</code></pre>
<p>Y por suerte integraron <code>EventEmitter</code>, que permitió crear APIs que usaran eventos sin más complejidad. Y lo que es mejor, incluyeron los streams, una forma de gestión de asincronía creada para que podamos acceder a un recurso por partes. Con el tiempo llegaron los promises que fue lo primero que me hizo plantearme si estábamos enfocando la asincronía de forma coherente.</p>
<p>En total he llegado a resumir los distintos tipos de asincronía en dos, ambos con la característica de que necesitan gestionar también errores:</p>

<ul>
<li><strong>Valor asíncrono</strong>: el callback se invoca una sola vez en el futuro</li>
<li><strong>Collección asíncrona</strong>: el callback se invoca una vez por cada elemento en la colección</li>
</ul>
<h3 id="valor-as-ncrono">Valor asíncrono</h3>
<p>En el primer caso tenemos un valor asíncrono, puede ser el valor devuelto por una función asíncrona o el valor puede ser nulo en cuyo caso simplemente funcionaría para detectar cuando el proceso ha finalizado. Este caso está cubierto por los Promises.</p>
<p>Desde mi punto de vista se trata de una especie de meta-programación, tenemos un valor (el promise) que sustituye al valor real para que podamos seguir con nuestra ejecución síncrona.</p>

<pre><code class="code-block shj-lang-js"><span class="shj-syn-kwd">var</span> contentPromise <span class="shj-syn-oper">=</span> file<span class="shj-syn-oper">.</span><span class="shj-syn-func">readContent</span>();
<span class="shj-syn-kwd">return</span> contentPromise;
</code></pre>
<h3 id="colecci-n-as-ncrona">Colección asíncrona</h3>
<p>Podemos verlo como un array asíncrono, que a medida que se le van añadiendo elementos va invocando a su callback. En este grupo metería a todo componente asíncrono que invoque a su callback más de una vez:</p>

<ul>
<li>Flujo de datos</li>
<li>Progreso</li>
<li>Eventos</li>
</ul>
<p>Una de las funcionalidades que más me gustan de <a href="https://www.dartlang.org/">Dart</a> es que <a href="https://www.dartlang.org/articles/improving-the-dom/#events">han sustituído los eventos DOM por streams</a>, un pequeño detalle pero que es todo un cambio de concepto, los eventos DOM son una lista de tamaño indeterminado. Cada vez que el usuario hace click es como añadir ese evento al stream de eventos click de ese elemento. Al ser un stream podemos escucharlo, filtrarlo, manipularlo... de la misma forma que hacemos con una colección. Incluso hay implementaciones que tienen métodos <code>.forEach</code> y <code>.filter</code> y <code>.map</code> cumpliendo la misma interfaz que el resto de colecciones.</p>
<p>Por otro lado los streams siguen siendo útiles para su funcionalidad primera, entregarnos un contenido que vamos recibiendo por partes, es decir; en lugar de cargar un achivo de 1Gb en memoria, un stream nos lo va entregando en bloques más pequeños así podemos trabajarlos y liberar memoria. Además en casos como medidores de progresos encajan perfectamente, siendo cada actualización del progreso un elemento del stream.</p>
<h3 id="y-todo-junto">Y todo junto</h3>
<blockquote>
<p>Nota: el código a continuación es adaptado de otros lenguajes y no existe en Javascript</p>
</blockquote>
<p>Incluso hay implementaciones muy completas que integran perfectamente los stream y los promises, podemos hacer de forma sencilla cosas como capturar el primer click en la pagina</p>

<pre><code class="code-block shj-lang-js"><span class="shj-syn-cmnt">// window.onClick instanceof Stream
</span><span class="shj-syn-kwd">var</span> firstClick <span class="shj-syn-oper">=</span> window<span class="shj-syn-oper">.</span>onClick<span class="shj-syn-oper">.</span>first;
firstClick<span class="shj-syn-oper">.</span><span class="shj-syn-func">then</span>(<span class="shj-syn-kwd">function</span>() { <span class="shj-syn-oper">...</span> });
</code></pre>
<p>Comprobar si las primeras diez teclas han sido &quot;flecha derecha&quot;</p>

<pre><code class="code-block shj-lang-js"><span class="shj-syn-kwd">var</span> firstTenKeys <span class="shj-syn-oper">=</span> input<span class="shj-syn-oper">.</span>onKeyDown<span class="shj-syn-oper">.</span><span class="shj-syn-func">take</span>(<span class="shj-syn-num">10</span>);
<span class="shj-syn-kwd">var</span> keyRightTenTimes <span class="shj-syn-oper">=</span> firstTenKeys<span class="shj-syn-oper">.</span><span class="shj-syn-func">every</span>(<span class="shj-syn-kwd">function</span> (event) {
  <span class="shj-syn-kwd">return</span> event<span class="shj-syn-oper">.</span>keyCode <span class="shj-syn-oper">===</span> <span class="shj-syn-num">39</span>;
});
keyRightTenTimes<span class="shj-syn-oper">.</span><span class="shj-syn-func">then</span>(<span class="shj-syn-kwd">function</span> (value) {
  <span class="shj-syn-kwd">if</span> (value) console<span class="shj-syn-oper">.</span><span class="shj-syn-func">log</span>(<span class="shj-syn-str">'You like left arrow! :D'</span>);
});
</code></pre>
<p>Capturar solo el tercer click en la página</p>

<pre><code class="code-block shj-lang-js"><span class="shj-syn-kwd">var</span> thirdClick <span class="shj-syn-oper">=</span> input<span class="shj-syn-oper">.</span>onKeyDown<span class="shj-syn-oper">.</span><span class="shj-syn-func">elementAt</span>(<span class="shj-syn-num">3</span>);
thirdClick<span class="shj-syn-oper">.</span><span class="shj-syn-func">then</span>(<span class="shj-syn-kwd">function</span> (event) {
  console<span class="shj-syn-oper">.</span><span class="shj-syn-func">log</span>(<span class="shj-syn-str">'You clicked three times :)'</span>);
});
</code></pre>
<p>Obtener todo el contenido del archivo desde el stream, no hace falta un método especial</p>

<pre><code class="code-block shj-lang-js"><span class="shj-syn-kwd">var</span> stream <span class="shj-syn-oper">=</span> file<span class="shj-syn-oper">.</span><span class="shj-syn-func">getReadStream</span>()
<span class="shj-syn-kwd">var</span> fileContent <span class="shj-syn-oper">=</span> stream<span class="shj-syn-oper">.</span><span class="shj-syn-func">join</span>(<span class="shj-syn-str">''</span>);
fileContent<span class="shj-syn-oper">.</span><span class="shj-syn-func">then</span>(<span class="shj-syn-kwd">function</span>(content) { <span class="shj-syn-oper">...</span> });
</code></pre>
<p>O detectar el primer evento <code>readystatechange</code> en que el <code>readyState</code> sea <code>4</code>, convertirlo en promise y devolver la respuesta</p>

<pre><code class="code-block shj-lang-js"><span class="shj-syn-kwd">return</span> xhr<span class="shj-syn-oper">.</span>onReadyStateChange
  <span class="shj-syn-oper">.</span><span class="shj-syn-func">filter</span>(<span class="shj-syn-kwd">function</span> (event) {
    <span class="shj-syn-kwd">return</span> xhr<span class="shj-syn-oper">.</span>readyState <span class="shj-syn-oper">===</span> <span class="shj-syn-num">4</span>;
  })
  <span class="shj-syn-oper">.</span>first<span class="shj-syn-oper">.</span><span class="shj-syn-func">then</span>(<span class="shj-syn-kwd">function</span> () {
    <span class="shj-syn-kwd">return</span> xhr<span class="shj-syn-oper">.</span>responseText;
  });
</code></pre>
<p>Unificar varias operaciones</p>

<pre><code class="code-block shj-lang-js"><span class="shj-syn-cmnt">// readFile returns promise
</span><span class="shj-syn-kwd">var</span> concat <span class="shj-syn-oper">=</span> <span class="shj-syn-kwd">new</span> <span class="shj-syn-class">Stream</span>([<span class="shj-syn-func">readFile</span>(<span class="shj-syn-str">'./header.html'</span>)<span class="shj-syn-oper">,</span> <span class="shj-syn-func">readFile</span>(<span class="shj-syn-str">'./content.html'</span>)<span class="shj-syn-oper">,</span> <span class="shj-syn-func">readFile</span>(<span class="shj-syn-str">'./footer.html'</span>)]);
stream<span class="shj-syn-oper">.</span><span class="shj-syn-func">listen</span>(<span class="shj-syn-kwd">function</span> (chunk) {
  response<span class="shj-syn-oper">.</span><span class="shj-syn-func">write</span>(chunk);
});
</code></pre>
<p>Incluso cosas más complejas como detectar la primera acción del usuario en la página</p>

<pre><code class="code-block shj-lang-js"><span class="shj-syn-cmnt">// Promise.race devuelve un promise que se completará
</span><span class="shj-syn-cmnt">// cuando el primer promise de la lista se complete
</span><span class="shj-syn-class">Promise</span><span class="shj-syn-oper">.</span><span class="shj-syn-func">race</span>([window<span class="shj-syn-oper">.</span>onClick<span class="shj-syn-oper">.</span>first<span class="shj-syn-oper">,</span> window<span class="shj-syn-oper">.</span>onKeyDown<span class="shj-syn-oper">.</span>first<span class="shj-syn-oper">,</span> window<span class="shj-syn-oper">.</span>onMouseMove<span class="shj-syn-oper">.</span>first])<span class="shj-syn-oper">.</span><span class="shj-syn-func">then</span>(<span class="shj-syn-kwd">function</span> (event) {
  console<span class="shj-syn-oper">.</span><span class="shj-syn-func">log</span>(<span class="shj-syn-str">'El usuario ha disparado el evento '</span> <span class="shj-syn-oper">+</span> event<span class="shj-syn-oper">.</span>type);
});
</code></pre>
<p>Y hasta capturar el evento <code>load</code> de window aunque ya haya pasado:</p>

<pre><code class="code-block shj-lang-js"><span class="shj-syn-func">setTimeout</span>(<span class="shj-syn-kwd">function</span> () {
  window<span class="shj-syn-oper">.</span>onLoad<span class="shj-syn-oper">.</span><span class="shj-syn-func">first</span>(<span class="shj-syn-kwd">function</span> () {
    <span class="shj-syn-cmnt">// Me van a invocar aunque el evento
</span>    <span class="shj-syn-cmnt">// ya haya pasado :)
</span>  });
}<span class="shj-syn-oper">,</span> <span class="shj-syn-num">1000</span> <span class="shj-syn-oper">*</span> <span class="shj-syn-num">60</span> <span class="shj-syn-oper">*</span> <span class="shj-syn-num">60</span>); <span class="shj-syn-cmnt">// una hora</span>
</code></pre>
<h3 id="resumen">Resumen</h3>
<p>La gestión de la asincronía, que siempre ha sido un caos, se simplifica de forma radical gracias a una buena combinación de Stream/Promises. Espero poder actualizar la entrada de los promises con los nuevos promises estándard de ECMAScript 6 :)</p>
<p>Conocen más patrones de gestión de asincronía?</p>
</article></div><div class="css-1ljukny"><input type="color" id="color-picker" value="#EFE751"/>
          <script>
            document.querySelector('#color-picker').addEventListener('input', (e) => {
              document.body.style.setProperty('--color-primary', e.target.value);
            });
          </script>
        </div></body></html>