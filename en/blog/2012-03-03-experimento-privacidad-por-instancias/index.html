<!DOCTYPE html><html lang="en"><head><meta charSet="UTF-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>potato</title><style>
  /* Box sizing rules */
  *, *::before, *::after {
    box-sizing: border-box;
  }

  /* Remove default padding */
  ul, ol {
    padding: 0;
  }

  /* Remove default margin */
  body, h1, h2, h3, h4, p, ul, ol, li, figure, figcaption, blockquote, dl, dd {
    margin: 0;
  }

  /* Set core body defaults */
  body {
    min-height: 100vh;
    scroll-behavior: smooth;
    text-rendering: optimizeSpeed;
    line-height: 1.5;
  }

  /* Remove list styles on ul, ol elements with a class attribute */
  ul, ol {
    list-style: none;
  }

  /* A elements that don&#x27;t have a class get default styles */
  a:not([class]) {
    text-decoration-skip-ink: auto;
  }

  /* Make images easier to work with */
  img {
    max-width: 100%;
    display: block;
  }

  /* Natural flow and rhythm in articles by default */
  article &gt; * + * {
    margin-top: 1em;
  }

  /* Inherit fonts for inputs and buttons */
  input, button, textarea, select {
    font: inherit;
  }

  /* Remove all animations and transitions for people that prefer not to see them */
  @media (prefers-reduced-motion: reduce) {
    * {
      animation-duration: 0.01ms !important;
      animation-iteration-count: 1 !important;
      transition-duration: 0.01ms !important;
      scroll-behavior: auto !important;
    }
  }

  @import url(&#x27;https://fonts.googleapis.com/css2?family=Lato:ital,wght@1,400;1,700&amp;family=Montserrat:wght@400;700&amp;display=swap&#x27;);

  :root {
    background-color: #263238;
    color: #FDFBF8;
    font-family: Lato, sans-serif;
    font-size: 18px;
  }

  header, h1, h2, h3, h4, h5, h6 {
    font-family: Montserrat, sans-serif;
  }

  a {
    color: #EFE751;
  }

  .md p {
    margin: 20px 0;
    text-align: justify;
  }

  svg {
    fill: #FDFBF8;
  }
</style><style></style></head><body class=""><div class="md"><blockquote>
<p>Actualización 19/3/2014: Sorprendentemente parece que una propuesta del ECMAScript 6 sigue mismo el patrón descrito en este post, y yo que pensaba que era demasiado rebuscado...</p>
<p><a href="http://wiki.ecmascript.org/doku.php?id=harmony:classes">http://wiki.ecmascript.org/doku.php?id=harmony:classes</a></p>
</blockquote>
<p>Como ya comenté, la privacidad en Javascript es un tema peliagudo, <strong>el lenguaje no nos ofrece ninguna herramienta para gestionar la privacidad</strong> automáticamente, tenemos que aprovechar el scope de <strong>los closures para ocultar información</strong> que el usuario de nuestra librería no necesita saber, <strong>pero ocultar propiedades de una instancia es mucho más complicado</strong>. Hace algunos años me empeñé en buscar una forma de conseguir privacidad por instancias que no fuera mediante el constructor, como ya expliqué en el [post anterior][1].</p>
<!--more Seguir leyendo → -->
<p>Para empezar está claro que es necesario tener un closure, para ocultar las variables desde fuera:</p>

<pre><code class="lang-js">// función de ejecución inmediata
(function (global) {
  // Contenido oculto
})(this);
</code></pre>
<p>Dentro de éste closure definiría la clase:</p>

<pre><code class="lang-js">(function (global) {
  function Persona() {
    var secreto;
  }

  Persona.prototype = {
    guardarSecreto: function (susurro) {
      secreto = susurro;
    },
    revelarSecreto: function () {
      return secreto;
    },
  };

  global.Persona = Persona;
})(this);
</code></pre>
<p>Evidentemente es imposible acceder a la variable <code>secreto</code> desde los métodos porque <code>secreto</code> <strong>está encerrada en el constructor y no se puede acceder ella desde fuera</strong> del constructor. Así que si quiero privacidad sin meter los métodos en el constructor por los métodos que [ya expliqué][2] la solución pasa por sacar la variable del constructor:</p>

<pre><code class="lang-js">(function (global) {
  var secreto;

  function Persona() {}
  Persona.prototype = {
    guardarSecreto: function (susurro) {
      secreto = susurro;
    },
    revelarSecreto: function () {
      return secreto;
    },
  };

  global.Persona = Persona;
})(this);

var pepe = new Persona();
var maria = new Persona();
pepe.guardarSecreto(&#39;estás en matrix&#39;);
console.log(maria.revelarSecreto());
</code></pre>
<p><a href="http://jsfiddle.net/amatiasq/eXfkL/" target="_blank">Pruébame</a></p>
<p>Bien, ahora <code>secreto</code> está fuera del constructor, pero tenemos otro problema, <strong>todas las instancias de <code>Persona</code> comparten la misma variable!</strong> Hay que buscar la forma de contar un secreto a <code>pepe</code> sin que <code>maria</code> se entere, dicho de otra forma, de guardar un valor en una instancia sin modificar la otra. En Javascript es muy sencillo trabajar con mappings así que porqué no guardamos en un mapping la relación instancia-valor? Así cada instancia podrá tener su valor guardado en la variable secreto sin interferir con el valor de otra instancia.</p>

<pre><code class="lang-js">(function (global) {
  var secreto = {};

  function Persona() {}
  Persona.prototype = {
    guardarSecreto: function (susurro) {
      secreto[this] = susurro;
    },
    revelarSecreto: function () {
      return secreto[this];
    },
  };

  global.Persona = Persona;
})(this);

var pepe = new Persona();
var maria = new Persona();
pepe.guardarSecreto(&#39;estás en matrix&#39;);
console.log(maria.revelarSecreto());
</code></pre>
<p><a href="http://jsfiddle.net/amatiasq/NaphB/" target="_blank">Pruébame</a></p>
<p>Esto tampoco funciona, porqué? Para entender ésto hay que investigar un poco, <strong>los índices de los arrays y los mappings en Javascript son <code>strings</code></strong>, y si intentas poner un índice de otro tipo lo convierte a <code>string</code> con el método <code>.toString()</code></p>

<pre><code class="lang-js">var array = [];
array[0] = &#39;Hola!&#39;;

for (var i in array) {
  if (array.hasOwnProperty(i)) {
    console.log(
      &#39;Array tiene la propiedad --[&#39; + i + &#39;]-- del tipo --[&#39; + typeof i + &#39;]-- con el valor --[&#39; + array[i] + &#39;]--&#39;,
    );
  }
}

var mapping = {};
var indice = {};
mapping[indice] = &#39;Mundo!&#39;;

for (var i in mapping) {
  if (mapping.hasOwnProperty(i)) {
    console.log(
      &#39;Mapping tiene la propiedad --[&#39; +
        i +
        &#39;]-- del tipo --[&#39; +
        typeof i +
        &#39;]-- con el valor --[&#39; +
        mapping[i] +
        &#39;]--&#39;,
    );
  }
}
</code></pre>
<p><a href="http://jsfiddle.net/amatiasq/cQZmS/" target="_blank">Pruébame</a></p>
<p>Entonces <strong>tanto <code>pepe</code> como <code>maria</code> se convierten a <code>[object Object]</code> cuando los utilizo como índices</strong> del mapping. Y hasta aquí había llegado hasta que descubrí los [<code>WeakMap</code> de Firefox][3]. Consiste básicamente en una clase con métodos <code>.set(id, valor);</code> y <code>.get(id);</code> por lo que cumple la misma funcionalidad que un mapping, con la diferencia de que si el único punto del programa en el que se usa una referencia es un <code>WeakMap</code>, <strong>el recolector de basura la puede borrar</strong>. Es una funcionalidad que es necesaria en Javascript por motivos que no voy a enumerar ahora, pero para mi trae un éxtra: &quot;WeakMaps are key/value maps in which <strong>keys are objects</strong>&quot; (Los WeakMaps son mappings clave/valor donde <strong>las claves son objetos</strong>). Sorpresa! Los <code>WeakMap</code> a diferencia de los mappings comunes no usan strings como claves, sino objetos. Esto haría viable la implementación anterior:</p>

<pre><code class="lang-js">(function (global) {
  var secreto = new WeakMap();

  function Persona() {}
  Persona.prototype = {
    guardarSecreto: function (susurro) {
      secreto.set(this, susurro);
    },
    revelarSecreto: function () {
      // Si no tenemos ningún secreto
      if (!secreto.has(this)) return &#39;Nada&#39;;
      else return secreto.get(this);
    },
  };

  global.Persona = Persona;
})(this);

var pepe = new Persona();
var maria = new Persona();

pepe.guardarSecreto(&#39;estás en matrix&#39;);
console.log(&#39;Secreto de María: &#39; + maria.revelarSecreto());
console.log(&#39;Secreto de Pepe: &#39; + pepe.revelarSecreto());
</code></pre>
<p><a href="http://jsfiddle.net/amatiasq/dAzjx/" target="_blank">Pruébame</a></p>
<p><strong>Nota</strong>: Aunque los WeakMap solo están en Firefox, ésto funcionará en todos los navegadores porque he creado una clase que se comporta de forma similar, pero que no permite al recolector de basura eliminar los objetos, la implementación puede verse al final del artículo.</p>
<p>Funciona! Hemos conseguido guardar una variable privada por instancia con un closure por clase. Ahora llémoslo un poco más allá, que pasa si <strong>en lugar de guardar una variable guardamos un objeto donde podremos tener todas las variables que queramos</strong> para ésa instancia?</p>

<pre><code class="lang-js">(function (global) {
  var privadas = new WeakMap();

  function Persona() {
    // Inicializamos el objeto
    privadas.set(this, {});
    privadas.get(this).otraPrivada = &#39;Variable inaccesible desde fuera&#39;;
  }

  Persona.prototype = {
    guardarSecreto: function (susurro) {
      privadas.get(this).secreto = susurro;
    },
    revelarSecreto: function () {
      return privadas.get(this).secreto;
    },
  };

  global.Persona = Persona;
})(this);

var pepe = new Persona();
var maria = new Persona();

pepe.guardarSecreto(&#39;estás en matrix&#39;);
console.log(&#39;Secreto de María: &#39; + maria.revelarSecreto());
</code></pre>
<p><a href="http://jsfiddle.net/amatiasq/RzDAE/" target="_blank">Pruébame</a></p>
<!-- TODO: This causes error `Expected "=>" but found end of file` -->
<!-- Perfecto, pero es un poco raro y repetitivo tener que hacer `privadas.set(this, {});` en el constructor y `privadas.get(this)` pra acceder a las privadas, podríamos encapsular ésto en una función: -->

<pre><code class="lang-js">function privadas() {
  var map = new WeakMap();
  return function (clave) {
    if (!map.has(clave)) map.set(clave, {});
    return map.get(clave);
  };
}
</code></pre>
<p>Y ahora ésta funcion nos devuelve otra función que podremos llamar cuando queramos con la instancia para obtener las privadas. Nuestra clase queda:</p>

<pre><code class="lang-js">(function (global) {
  var p = privadas();

  function Persona() {
    p(this).secreto = &#39;Nada&#39;;
    p(this).otraPrivada = &#39;Variable inaccesible desde fuera&#39;;
  }

  Persona.prototype = {
    guardarSecreto: function (susurro) {
      p(this).secreto = susurro;
    },
    revelarSecreto: function () {
      return p(this).secreto;
    },
  };

  global.Persona = Persona;
})(this);

var pepe = new Persona();
var maria = new Persona();

pepe.guardarSecreto(&#39;estás en matrix&#39;);
console.log(&#39;Secreto de María: &#39; + maria.revelarSecreto());
console.log(&#39;Secreto de Pepe: &#39; + pepe.revelarSecreto());
</code></pre>
<p><a href="http://jsfiddle.net/amatiasq/XmKCH/" target="_blank">Pruébame</a></p>
<p>Y voilá! Tenemos privadas por clases sin crear más de un closure. :D</p>
<h3 id="resumen">Resumen</h3>
<p>Está claro que <strong>es aberrante pensar en crear una arquitectura basada en éste sistema</strong>, incluso dejando de lado lo extraño de la sintaxis (<code>p(this)</code> para acceder a las privadas), <strong>sería peligroso</strong> porque aunque Firefox nos ofrezca <code>WeakMap</code> en el resto de navegadores tendríamos que crear una funcionalidad similiar y no podríamos evitar tener una referencia a las instancias si queremos que el sistema sea irrompible, lo que haría que el recolector de basura no pudiera borrar las instancias que ya no utilizemos con <strong>riesgo de llenar la memoria RAM disponible</strong>.</p>
<p>Como ya he dicho muchas veces, la gracia de <strong>esto no es forzar Javascript a su límite, sino forzar la mente</strong>, si hoy forzamos la imaginación hasta sus límites mañana podremos sobrepasarlos. La idea es ejercitar y mejorar la capacidad de buscar soluciones creativas y funcionales por extrañas o imposibles que parezcan.</p>
<p>Finalmente, como expliqué en la nota, aquí está la implementación que usé para que los ejemplos funcionen en navegadores que no sean Firefox, guarda en los objetos la propiedad <em>$$ID</em> para no tener que buscar en todo el array de claves el índice del objeto:</p>

<pre><code class="lang-js">if (typeof WeakMap === &#39;undefined&#39;) {
  window.WeakMap = function WeakMap() {
    this.keys = [];
    this.values = [];
  };
  WeakMap.prototype = {
    constructor: WeakMap,

    set: function (key, value) {
      var id = (key.$$ID = this.keys.length);
      this.keys[id] = key;
      this.values[id] = value;
    },

    get: function (key) {
      var id = key.$$ID;

      // Si el índice del objeto no se corresponde
      // con su posición en la lista de claves
      // Es que ha sido modificado, debemos corregirlo.
      if (this.keys[id] !== key) id = this._fixIndex(key);

      return this.values[id];
    },

    has: function (key) {
      return this._fixIndex(key) !== null;
    },

    _fixIndex: function (key) {
      for (var i = this.keys.length; i--; ) if (this.keys[i] === key) return (key.$$ID = i);
      return null;
    },
  };
}
</code></pre>
<p>[1]: <a href="http://www.amatiasq.com/2012/02/conceptos-basicos-javascript-privacidad/">http://www.amatiasq.com/2012/02/conceptos-basicos-javascript-privacidad/</a> &#39;Conceptos Básicos Javascript: Privacidad&#39;
[2]: <a href="http://www.amatiasq.com/?p=174">http://www.amatiasq.com/?p=174</a> &#39;Conceptos Básicos Javascript: Privacidad&#39;
[3]: <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/WeakMap">https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/WeakMap</a> &#39;WeakMap&#39;</p>
</div></body></html>