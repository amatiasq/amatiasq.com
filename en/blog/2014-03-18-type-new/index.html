<!DOCTYPE html><html lang="en"><head><meta charSet="UTF-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Type.new()</title><style>
  /* Box sizing rules */
  *, *::before, *::after {
    box-sizing: border-box;
  }

  /* Remove default padding */
  ul, ol {
    padding: 0;
  }

  /* Remove default margin */
  body, h1, h2, h3, h4, p, ul, ol, li, figure, figcaption, blockquote, dl, dd {
    margin: 0;
  }

  /* Set core body defaults */
  body {
    min-height: 100vh;
    scroll-behavior: smooth;
    text-rendering: optimizeSpeed;
    line-height: 1.5;
  }

  ul, ol, summary {
    list-style: none;
  }
  .md ul, .md ol {
    list-style: initial;
    padding: revert;
  }

  /* A elements that don&#x27;t have a class get default styles */
  a:not([class]) {
    text-decoration-skip-ink: auto;
  }

  /* Make images easier to work with */
  img {
    max-width: 100%;
    display: block;
  }

  /* Natural flow and rhythm in articles by default */
  article &gt; * + * {
    margin-top: 1em;
  }

  /* Inherit fonts for inputs and buttons */
  input, button, textarea, select {
    font: inherit;
  }

  /* Remove all animations and transitions for people that prefer not to see them */
  @media (prefers-reduced-motion: reduce) {
    * {
      animation-duration: 0.01ms !important;
      animation-iteration-count: 1 !important;
      transition-duration: 0.01ms !important;
      scroll-behavior: auto !important;
    }
  }

  @import url(&#x27;https://fonts.googleapis.com/css2?family=Lato:ital,wght@1,400;1,700&amp;family=Montserrat:wght@400;700&amp;display=swap&#x27;);

  :root {
    background-color: #263238;
    color: #FDFBF8;
    font-family: Lato, sans-serif;
    font-size: 18px;
  }

  header, h1, h2, h3, h4, h5, h6 {
    font-family: Montserrat, sans-serif;
  }

  a {
    color: #EFE751;
  }

  .md p {
    margin: 20px 0;
    text-align: justify;
  }

  .md pre {
    white-space: break-spaces;
  }

  svg {
    fill: #FDFBF8;
  }
</style><style>.css-zi0qjt{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:justify;-webkit-justify-content:space-between;justify-content:space-between;}
.css-1p4f3y5{display:grid;padding-top:20px;gap:12px;}
.css-2nd93p{padding:20px 0;margin-bottom:20px;background-color:#1B2225;color:#FDFBF8;border-bottom:2px solid #586369;}@media (min-width: 769px){.css-2nd93p{position:-webkit-sticky;position:sticky;top:0;z-index:1;}}
.css-17rdaxl{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:justify;-webkit-justify-content:space-between;justify-content:space-between;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;}@media (min-width: 769px){.css-17rdaxl{-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;}}
.css-slvbys{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;gap:12px;}.css-slvbys a{color:#EFE751;-webkit-text-decoration:none;text-decoration:none;margin-left:12px;border-bottom:1px solid transparent;}.css-slvbys a.parent{border-bottom:1px solid #586369;}.css-slvbys a:hover{border-bottom:1px solid #EFE751;}
.css-1avicn7{font-size:24px;-webkit-text-decoration:none;text-decoration:none;color:#FDFBF8;}
.css-2u52bv{max-width:30rem;margin-left:auto;margin-right:auto;padding-left:1rem;padding-right:1rem;}@media (min-width: 769px){.css-2u52bv{max-width:50rem;padding-left:5rem;padding-right:5rem;}}@media (min-width: 1200px){.css-2u52bv{max-width:60rem;padding-left:5rem;padding-right:5rem;}}
.css-187qu0u{font-family:Montserrat,sans-serif;font-weight:700;font-size:32px;}
.css-bkztrs{opacity:0.8;font-family:monospace;color:#FDFBF8;}</style></head><body class=""><header class="css-2nd93p "><div class="css-17rdaxl css-2u52bv"><h2><a href="../../.." class="css-1avicn7">A. Mat√≠as Quezada</a></h2><nav class="css-slvbys"><a href="../../../blog" class="">Blog</a><a href="../../../career" class="">Career</a><a href="../../../projects" class="">Projects</a><a href="../../../es/blog/2014-03-18-type-new" class="">üá™üá∏</a></nav></div></header><div class="css-1p4f3y5 css-2u52bv"><div class="css-zi0qjt"><h2 class="undefined css-187qu0u">Type.new()</h2><time class="css-bkztrs " dateTime="03/18/2014">Mar 18, 2014</time></div><div class="md"><blockquote>
<p>NOTA: Este art√≠culo est√° centrado en un tema que ya coment√© en <a href="http://blog.amatiasq.com/2014/03/construccion-de-objetos/">el post anterior</a>, pero de una forma m√°s organizada y centrada, algunos fragmentos est√°n extra√≠dos del post anterior para mayor claridad.</p>
</blockquote>
<h2 id="constructores-en-javascript">Constructores en Javascript</h2>
<p>He hablado antes de la limitaci√≥n de los constructores javascript y sobre todo de la complejidad de extenderlos</p>

<pre><code class="lang-js">function Person(name) {
  this.name = name;
}
Person.prototype.methodA = function() { ... };

function Employee(name, position) {
  Person.call(this, name);
  this.position = position;
}
Employee.prototype = Object.create(Person.prototype);
Employee.prototype.methodB = function() { ... };
</code></pre>
<p>Esto es un asunto que trae de cabeza a la mayor√≠a de la gente que programa javascript, la dificiltad que conlleva crear una simple &quot;clase&quot; hasta el punto que en la siguiente versi√≥n del ECMAScript (el est√°ndar en el que est√° basado Javascript) han inclu√≠do una forma m√°s sencilla de hacer lo mismo: la palabra clave <code>class</code></p>

<pre><code class="lang-js">class Person {
  constructor(name) {
    this.name = name;
  }
  methodA() {}
}

class Employee extends Person {
  constructor(name, position) {
    super(name);
    this.position = position;
  }
  methodB() {}
}
</code></pre>
<p><a target="_blank" href="http://www.es6fiddle.net/hsq7hzw6/">Pru√©bame</a></p>
<p>Aunque he visto a mucha gente emocionada pensando que ECMAScript 6 traer√° clases reales tengo que decir que este c√≥digo no hace ni m√°s ni menos que lo que hace el primer c√≥digo. Y es muy importante saberlo porque aunque prezcan classes como las de Java o C++, en este caso siguen siendo objetos usando <a href="http://blog.amatiasq.com/2012/01/javascript-conceptos-basicos-herencia-por-prototipos/">herencia por prototipos</a> y esconderlo solo servir√° para no saber porqu√© el c√≥digo no funciona como esperamos.</p>
<p>En cualquier caso vemos que definir tipos en javascript es complicado y la soluci√≥n propuesta por el equipo de ECMA no es, en mi opini√≥n, la m√°s adecuada.</p>
<h2 id="orientado-a-objetos">Orientado a objetos</h2>
<p>Creo que el problema se aloja en la definici√≥n que dimos en un principio a &quot;Programaci√≥n Orientada a Objetos&quot; (Object Oriented Programming, OOP) ya que los primeros lenguajes OOP creaban objetos usando clases y otras herramientas, y aunque los objetos son la base del sistema la estructura est√° dada por las clases. Lo que ser√≠a Programaci√≥n Orientada a Objetos con Clases.</p>
<!--more Seguir leyendo ‚Üí -->
<p>Despu√©s recibimos otros lenguajes que tambi√©n se definian como &quot;Programaci√≥n Orientados a Objetos&quot; pero enfocado de otra forma, entre ellos javascript. En este caso el lenguaje no tiene clases sino que todo son objetos y la estructura se crea mediante prototipos, todo objeto puede ser el prototipo de otro objeto y esto significa que si B prototipa a A todas las propiedades que A tenga tambi√©n existir√°n en B. Esto es lo que llamo Programaci√≥n Orientada a Objetos con Prototipos.</p>
<p>Me he cruzado con mucha gente que piensa que la Programaci√≥n Orientada a Objetos no es posible sin clases y que si Javascript no tiene clases no puede denominarse orientado a objetos. Como en todo debate entre geeks acabamos en la wikipedia:</p>
<blockquote>
<p>La programaci√≥n orientada a objetos o POO (OOP seg√∫n sus siglas en ingl√©s) es un paradigma de programaci√≥n que usa los objetos en sus interacciones, para dise√±ar aplicaciones y programas inform√°ticos. Est√° basado en varias t√©cnicas, incluyendo herencia, cohesi√≥n, abstracci√≥n, polimorfismo, acoplamiento y encapsulamiento.</p>
</blockquote>
<p>En resumen, un lenguaje orientado a objetos es el que tiene objetos (brillante conclusi√≥n) y cumple una serie de t√©cnicas (herencia, cohesi√≥n, abstracci√≥n, polimorfismo...) que en el caso de Java se hace mediante clases y en el caso de Javascript se hace mediante prototipos.</p>
<h2 id="los-inicios-de-javascript">Los inicios de Javascript</h2>
<p>Javascript en sus inicios se llam√≥ LiveScript, cuenta la leyenda que por aquella √©poca Java estaba teniendo mucho √©xito y por marketing se decidi√≥ llamar al nuevo lenguaje JavaScript. Tambi√©n cuenta que por el mismo motivo a √∫ltima hora se decidi√≥ modificar el lenguaje para parecerse m√°s a Java a√±adiendo, entre otras funcionalidades, el operador <code>new</code> para que pareciera tener clases.</p>
<p>Hay algo muy curioso en los constructores Javascript, que en el fondo son simples funciones, y es que todas las funciones javascript tienen la propiedad <code>prototype</code> que por defecto trae un objeto que solo tiene una propiedad, la propiedad <code>constructor</code> que es el propio constructor.</p>

<pre><code class="lang-js">function Testing() {}
console.log(Testing.prototype.constructor === Testing);

var proto = Testing.prototype;
console.log(proto.constructor.prototype === proto);
</code></pre>
<h2 id="constructores-vs-objetos-prototipo">Constructores vs objetos prototipo</h2>
<p>Esto me hace pensar que quiz√°s la intenci√≥n original de los objetos en javascript no era tener constructores que contienen prototipos sino tener prototipos que contienen constructores. Es decir: en lugar de...</p>

<pre><code class="lang-js">function MyType() {
  this.id = 1;
}
MyType.prototype.methodA = function() { ... }
</code></pre>
<p>Hacer esto...</p>

<pre><code class="lang-js">var MyType = {
  constructor: function() {
    this.id = 1;
  },
  methodA: function() { ... },
};
</code></pre>
<p>Vaya! No parece una forma mucho m√°s sencilla de declarar tipos? [Aqu√≠][5] podemos comparar el mismo tipo escrito con constructores y con este paradigma y juzguen ustedes mismos. Y que pasa cuando intentamos invocar al constructor? hay que usar <code>.call()</code> o <code>.apply()</code> para pasarle this?</p>

<pre><code class="lang-js">var instancia = Object.create(MyType);
instancia.constructor();
</code></pre>
<p>BOOM! Constructor ya recibe this porque es invocado directamente en la instancia! No es exageradamente sencillo y l√≥gico desde √©ste punto de vista?</p>
<p>Adem√°s por accidente hemos quitado de en medio la funci√≥n constructora y lo que tenemos es un simple objeto, el elemento m√°s b√°sico de la programaci√≥n orientada a objetos. Es decir, para declarar un tipo solo tenemos que crear un objeto, para prototipar un objeto solo necesitamos un paso</p>

<pre><code class="lang-js">var SubType = Object.create(MyType);
</code></pre>
<p>No estamos obligados, a diferenia del primer caso, a crear un nuevo constructor para crear un subtipo, por la herencia por prototipos tenemos el mismo constructor que <code>MyType</code></p>

<pre><code class="lang-js">console.log(SubType.constructor === MyType.constructor);
// true
</code></pre>
<p><a target="_blank" href="http://jsfiddle.net/amatiasq/VRKYv/">Pru√©bame</a></p>
<p>Y la mejor parte, que pasa si queremos crear un tipo sin constructor? No hay problema.</p>

<pre><code class="lang-js">var MyType = {};
console.log(MyType.constructor); // Object
</code></pre>
<p><a target="_blank" href="http://jsfiddle.net/amatiasq/yGJLL/">Pru√©bame</a></p>
<h2 id="ecmascript-6">ECMAScript 6</h2>
<p>Este paradigma se parece bastante a la forma de crear clases en ECMAScript 6</p>

<pre><code class="lang-js">class MyType {
  constructor() {
    this.id = 1;
  }
  methodA() { ... }
}
</code></pre>
<p>Que alguno dir√°, si, pero con las clases de ECMAScript 6 podemos extender clases, llamar al m√©todo padre con <code>super</code> y nos ahorramos poner <code>function</code>... Pero esas no son funcionalidades de las clases de ECMAScript 6, esas son funcionalidades <a href="https://github.com/lukehoban/es6features#enhanced-object-literals">de todos los objetos</a> en ECMAScript 6.</p>

<pre><code class="lang-js">// Clase ECMAScript 6
class Employee extends Person {
  constructor(name, postition) {
    super(name);
    this.position = postition;
  }
  methodA() { ... }
}

// Objeto en ECMAScript 6 est√°ndar
var Employee = {
  __proto__: Person,

  constructor() {
    super(name)
    this.id = 1;
  },
  methodA() { ... }
};
</code></pre>
<p>Las diferencias entre una clase ECMAScript 6 y un objeto en ECMAScript 6 son m√≠nimas, pero mientras que una clase nos hace pensar que <code>Employee</code> se comportar√° como una clase Java cuando no es as√≠, un objeto es simplemente eso, un objeto y todos somos capaces de entender como se comporta un objeto, no? (si no que haces leyendo esto? o.o)</p>
<p>Pero dejemos ECMAScript 6 de lado por ahora, que a√∫n tiene que transcurrir tiempo antes de que podamos usarlo en serio.</p>
<h2 id="instanciaci-n">Instanciaci√≥n</h2>
<p>Hasta aqu√≠ era la definicion del tipo, pero como creamos una instancia? Primero tendr√≠amos que plantearnos que es una instancia, si no tenemos clases podemos tener instancias? Seg√∫n la wikipedia</p>
<blockquote>
<p>En el paradigma de la orientaci√≥n a objetos, una instancia (en ingl√©s, instance) se refiere a una realizaci√≥n espec√≠fica de una clase o prototipo determinados.</p>
</blockquote>
<p>Pero, al menos a mi, no importa mucho la palabra; el tema es que nosotros creamos objetos para que hagan de prototipos y queremos crear &quot;instancias&quot; de estos prototipos. La forma de prototipar un objeto es usando <code>Object.create()</code></p>

<pre><code class="lang-js">var instance = Object.create(MyType);
</code></pre>
<p>Pero, un momento... Esto es exactamente lo mismo que hicimos para crear un subtipo, no? Si. Entonces en que se diferencia una instancia de un subtipo? En general, nada. <strong>Una instancia ES un subtipo</strong>. Pero en la mayor√≠a de los casos las &quot;instancias&quot; tienen una necesidad que los subtipos no tienen: en una instancia se invoca al constructor, en un subtipo no.</p>

<pre><code class="lang-js">var MyType = {
  constructor: function () {
    this.id = 1;
  },
};

// Crear sub-tipo
var SubType = Object.create(MyType);

// Crear instancia
var instance = Object.create(MyType);
instance.constructor();
</code></pre>
<p>Esta similitud entre una instancia y un SubTipo nos ayuda a entender hasta que punto en el fondo Javascript es muy, muy sencillo: todo son objetos; no hay diferencia entre un tipo y una instancia porque la diferencia es conceptual.</p>
<p>Esto es muy √∫til para entender la sencillez y el coraz√≥n de Javascript, pero es un poco tedioso tener que hacer dos pasos para instanciar, podr√≠amos simplificarlo?</p>
<h2 id="-type-new-es-el-nuevo-new-"><code>Type.new()</code> es el nuevo <code>new</code></h2>
<p>Lo cierto es que podr√≠amos, podemos hacer una funci√≥n que haga este proceso:</p>

<pre><code class="lang-js">function createInstance(Type) {
  var instance = Object.create(Type);
  instance.constructor();
  return instance;
}

var Type = {
  constructor: function () {
    this.id = 1;
  },
};

var instance1 = createInstance(Type);

var TypeWithoutConstructor = {};
var instance2 = createInstance(TypeWithoutConstructor);
</code></pre>
<p><a target="_blank" href="http://jsfiddle.net/amatiasq/Jry2Z/">Pru√©bame</a></p>
<p>Y que pasa si en lugar de llamarla <code>createInstance</code> la llamamos <code>$new</code> por ejemplo?</p>

<pre><code class="lang-js">var instance = $new(MyType);
</code></pre>
<p>Empieza a parecer similar, solo nos faltar√≠a cambiar la funcion <code>$new</code> para pasarle par√°metros al constructor</p>

<pre><code class="lang-js">function $new(Type, params) {
  var instance = Object.create(Type);
  instance.constructor.apply(instance, params);
  return instance;
}

var Type = {
  constructor: function (name) {
    this.name = name;
  },
};

var instance = $new(Type, [&#39;bob&#39;]);
</code></pre>
<p><a target="_blank" href="http://jsfiddle.net/amatiasq/t8QCk/">Pru√©bame</a></p>
<p>Parece funcionar, pero solo para acabar de pulirlo, porqu√© no ponemos $new como m√©todo de Type? as√≠ podr√≠amos pasarle los argumentos sin el array y como ECMAScript 5 nos permite usar palabras clave como propiedades de objeto podemos llamarlo simplemente <code>new</code>.</p>

<pre><code class="lang-js">var Type = {
  new: function () {
    var instance = Object.create(this);
    instance.constructor.apply(instance, arguments);
    return instance;
  },
  constructor: function (name) {
    this.name = name;
  },
};

var instance = Type.new(&#39;bob&#39;);
</code></pre>
<p><a target="_blank" href="http://jsfiddle.net/amatiasq/x3qM4/">Pru√©bame</a></p>
<p>Y tenemos una forma que podemos usar con ECMAScript 5 para crear tipos e instancias de forma sencilla. Pero que diferencia hay entre esto y hacer un <code>new</code>? A parte de la ya mencionada simplicidad para crear y extender tipos, tiene m√°s ventajas, principalmente porque nos permite controlar m√°s exactamente <strong>c√≥mo</strong> se crea un objeto que en algunos casos es conveniente cambiarlo (en la mayor√≠a no), pero excede el alcance de √©ste post.</p>
<h2 id="conclusi-n">Conclusi√≥n</h2>
<p>Despu√©s de pasarme los √∫ltimos a√±os probando <a href="https://gist.github.com/amatiasq/4038135">mil</a> <a href="https://gist.github.com/amatiasq/5215294">y</a> <a href="https://gist.github.com/amatiasq/5254098">una</a> <a href="https://gist.github.com/amatiasq/5619166">formas</a> <a href="https://gist.github.com/amatiasq/6270563">de</a> <a href="https://github.com/amatiasq/LifeJS/blob/master/lib/animal.js">crear</a> <a href="https://github.com/amatiasq/-legacy-BRIAP/blob/master/src/core/base.js">y</a> <a href="https://github.com/amatiasq/-legacy-bio/blob/master/src/core/Base.js">extender</a> <a href="https://github.com/amatiasq/jsbase/blob/master/src/extend.js">&quot;clases&quot;</a> <a href="https://github.com/amatiasq/-legacy-Life/blob/master/lib/physic/Force.dart">para</a> <a href="https://github.com/amatiasq/glib/blob/master/core/base.js">encontrar</a> <a href="https://github.com/amatiasq/lulas/blob/master/src/core/extend.js">la</a> forma m√°s sencilla, r√°pida y elegante, muchas de ellas registradas en este blog; me quedo con <a href="https://gist.github.com/amatiasq/7892749">√©sta</a>. La lecci√≥n que me dio javascript es que no es conveniente luchar contra su naturaleza, si queremos usar javascript y no morir en el intento lo m√°s razonable es usar javascript y no tratarlo en contra de su naturaleza.</p>
<p>A√∫n est√° por verse pero creo que este sistema incluso puede competir cara a cara con las &quot;clases&quot; de ECMAScript 6, pero en cualquier caso la conversi√≥n entre un tipo creado por constructor y uno creado con este sistema es muy sencilla</p>
<p>Por ejemplo, convertir un tipo creado con este sistema a constructor para usarlo con <code>new</code>:</p>

<pre><code class="lang-js">var MyType = {
  myMethod: function() { ... },
};

function MyConstructor() {
  MyType.constructor.apply(this, arguments);
}
MyConstructor.prototype = MyType;
</code></pre>
<p><a target="_blank" href="http://jsfiddle.net/amatiasq/tGD7G/">Pru√©bame</a></p>
<p>O convertir un constructor a este paradigma:</p>

<pre><code class="lang-js">function MyConstructor() {
  this.value = 1;
}
MyConstructor.prototype.myMethod = function() { ... };

var MyType = MyConstructor.prototype;
// y si queres a√±adir new...
MyType.new = $new;
</code></pre>
<p><a target="_blank" href="http://jsfiddle.net/amatiasq/5R4z2/">Pru√©bame</a></p>
<h2 id="inicializador">Inicializador</h2>
<p>Para finalizar un bonus, despu√©s de toda esta traves√≠a me he dado cuenta que el constructor, que para javascript parece tan importante, no lo es tanto. Si nos paramos a mirar el constructor vemos que es una simple funci√≥n</p>

<pre><code class="lang-js">function MyType() { ... }
</code></pre>
<p>No tiene nada de especial, incluso podemos invocarla como una funci√≥n y no construye nada. Entonces qui√©n construye? <code>new</code>. Es el operador <code>new</code> el que crea el nuevo objeto y luego invoca el m√©todo llamado &quot;constructor&quot;, que no se diferencia en nada de cualquier otro m√©todo que podr√≠a tener el objeto.</p>
<p>Por como yo lo veo, la funci√≥n del constructor es m√°s inicializar que construir, debe encargarse de inicializar las propiedades del objeto, no construir. Visto as√≠ es evidente que el nombre &quot;constructor&quot; no es apropiado, en mi caso prefiero la denominaci√≥n &quot;initializer&quot; o simplemente &quot;init&quot;, como Backbone ya hace en sus objetos.</p>
<p>Por eso en mis proyectos cuando utilizo este paradigma, prefiero que mi funci√≥n <code>$new</code> invoque el m√©todo <code>init</code> en lugar de llamar al m√©todo <code>constructor</code>.</p>

<pre><code class="lang-js">function $new() {
  var obj = Object.create(this);
  obj.init.apply(obj, arguments);
  return obj;
}

var MyType = {
  new: $new,
  init: function () {
    this.value = 1;
  },
};

var instance = MyType.new();
</code></pre>
<p><a target="_blank" href="http://jsfiddle.net/amatiasq/7h7Te/">Pru√©bame</a></p>
</div></div></body></html>