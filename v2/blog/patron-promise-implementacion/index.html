<!DOCTYPE html><html lang="en" class="astro-ydck33jo"><head><meta charset="utf-8"><link rel="icon" type="image/svg+xml" href="/favicon.svg"><meta name="viewport" content="width=device-width"><meta name="generator" content="Astro v3.4.0"><title>A. Mat√≠as Quezada</title><style>pre code.hljs{display:block;overflow-x:auto;padding:1em}code.hljs{padding:3px 5px}/*!
  Theme: GitHub Dark
  Description: Dark theme as seen on github.com
  Author: github.com
  Maintainer: @Hirse
  Updated: 2021-05-15

  Outdated base version: https://github.com/primer/github-syntax-dark
  Current colors taken from GitHub's CSS
*/.hljs{color:#c9d1d9;background:#0d1117}.hljs-doctag,.hljs-keyword,.hljs-meta .hljs-keyword,.hljs-template-tag,.hljs-template-variable,.hljs-type,.hljs-variable.language_{color:#ff7b72}.hljs-title,.hljs-title.class_,.hljs-title.class_.inherited__,.hljs-title.function_{color:#d2a8ff}.hljs-attr,.hljs-attribute,.hljs-literal,.hljs-meta,.hljs-number,.hljs-operator,.hljs-variable,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-id{color:#79c0ff}.hljs-regexp,.hljs-string,.hljs-meta .hljs-string{color:#a5d6ff}.hljs-built_in,.hljs-symbol{color:#ffa657}.hljs-comment,.hljs-code,.hljs-formula{color:#8b949e}.hljs-name,.hljs-quote,.hljs-selector-tag,.hljs-selector-pseudo{color:#7ee787}.hljs-subst{color:#c9d1d9}.hljs-section{color:#1f6feb;font-weight:700}.hljs-bullet{color:#f2cc60}.hljs-emphasis{color:#c9d1d9;font-style:italic}.hljs-strong{color:#c9d1d9;font-weight:700}.hljs-addition{color:#aff5b4;background-color:#033a16}.hljs-deletion{color:#ffdcd7;background-color:#67060c}pre code.hljs{--_code-margin: var(--code-margin, 1.5em);white-space:pre;background-color:#000;margin:var(--_code-margin) calc(var(--_code-margin) * -1);padding:var(--_code-margin);border-radius:8px}pre code.hljs>.hljs-comment{color:#999}code:not(.hljs){padding:0 .3em .1em;border-radius:5px;background-color:#0000004d}.md li{list-style:initial}.md ul,.md ol{margin:20px 0;padding:reset}.md p{text-align:justify}.md blockquote{border-left:5px solid var(--color-foreground);margin-left:0;padding-left:1em}.md :is(h1,h2,h3,h4,h5,h6){margin-top:2em}
</style>
<link rel="stylesheet" href="/v2/_astro/_slug_.35648afe.css" />
<style>.tag-list{display:flex;gap:.5em;flex-wrap:wrap;list-style:none;margin:0;padding:0}
</style></head><body class="astro-ydck33jo"><header class="amq-header"><div class="container"><h2 class="amq"><a class="name" href="../../../"><span>{</span><abbr>Adrian</abbr><span class="dot">.</span><span>Mat√≠as Quezada</span><span>}</span></a></h2><nav><a href="../../../blog/">Blog</a><a href="../../../projects/">Projects</a><a href="../../../career/">Career</a><!-- <div class="lang-selector"> --><a href="../../../es/v2/blog/patron-promise-implementacion/">
üá™üá∏
</a><!-- </div> --></nav></div></header><main class="astro-ydck33jo"><div class="container"><h1>Promise pattern: Implementation (spanish)</h1><ul class="tag-list md-tags"></ul><article class="md"><p>Lo prometido es deuda (bien lo saben las funciones) y he encontrado un momento para empezar a explicar la forma en la que he implementado el patr√≥n Promise en mi caso, no tiene porqu√© ser la mejor, pero cumple con su cometido.</p>
<p><strong>NOTA:</strong> Me gustar√≠a implementarla en Test Driven Development, pero ya es bastante para quien lee y para el que escribe seguir la implementaci√≥n como para encima a√±adir TDD, pero no quisiera dejar de recomendarlo.</p>
<h3>Primero: Funcionalidad b√°sica</h3>
<p>Lo que necesitamos de un objeto Promise es:</p>
<ul>
<li>Crear instancias totalmente independientes</li>
<li>A√±adirle callbacks que ser√°n llamados cuando se cumpla la promesa</li>
<li>Notificarle cuando se ha cumplido la promesa</li>
</ul>
<p>Con los objetivos en la mano es m√°s sencillo ver que hacer, lo primero necesitamos una clase, a la hora de crear clases en Javascript yo me decanto por el patr√≥n de constructor con prototipos que espero explicar alg√∫n d√≠a.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Promise</span>(<span class="hljs-params"></span>) {}
</code></pre>
<p><strong>Segundo punto:</strong> poder a√±adirle callbacks, √©sto consiste en el m√©todo <code>.then()</code> al que deberemos poder llamar pas√°ndole las funciones que queremos que se ejecuten cuando la promesa se cumpla. Puesto de debe poderse a√±adir m√°s de un callback para cada promise lo m√°s l√≥gico ser√≠a crear un Array donde almacenarlos</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Promise</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">_callbacks</span> = [];
}
</code></pre>
<p>Y el m√©todo <code>.then()</code> que vaya a√±adiendo al Array los callbacks que se le pasen, puesto que es mejor que los errores se detecten cuanto antes tambi√©n podemos asegurarnos que el callback es una funci√≥n:</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">then</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">callback</span>) {
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> callback !== <span class="hljs-string">'function'</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">"[Promise.then] El argumento 'callback' no es una funci√≥n "</span> + <span class="hljs-keyword">typeof</span> callback);
  }

  <span class="hljs-variable language_">this</span>.<span class="hljs-property">_callbacks</span>.<span class="hljs-title function_">push</span>(callback);
};
</code></pre>
<p>Y ahora que ya tenemos todos los callbacks en un Array necesitamos alg√∫n sistema para avisarle al Promise que ya tiene los datos que necesita y que se los pase a los callbacks. Sobre √©sto no he visto ninguna implementaci√≥n, pero a mi me parece bastante razonable crear un m√©todo <code>Promise.done()</code> que notifica al Promise que ya est√° cumplido y ejecuta los callbacks.</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">done</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
  <span class="hljs-keyword">var</span> callback;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &#x3C; <span class="hljs-variable language_">this</span>.<span class="hljs-property">_callbacks</span>.<span class="hljs-property">length</span>; i++) {
    callback = <span class="hljs-variable language_">this</span>.<span class="hljs-property">_callbacks</span>[i];
    <span class="hljs-title function_">callback</span>();
  }
};
</code></pre>
<p>Y ya lo tenemos hecho, hemos creado un Promise b√°sico, vamos a probarlo. Imaginemos cualquier funci√≥n as√≠ncrona, por ejemplo vamos a crear una funci√≥n que nos avise cuando pase un segundo:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">esperarUnSegundo</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">var</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>();
  <span class="hljs-comment">// Hacemos un timeout a mil milisegundos</span>
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    promise.<span class="hljs-title function_">done</span>();
  }, <span class="hljs-number">1000</span>);
  <span class="hljs-keyword">return</span> promise;
}

<span class="hljs-title function_">esperarUnSegundo</span>().<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
  <span class="hljs-title function_">alert</span>(<span class="hljs-string">'Ha pasado un segundo =D'</span>);
});
</code></pre>
<p>Pru√©bame</p>
<p>Si probamos todo el c√≥digo veremos que al cabo de un segundo ejecuta el alert.</p>
<p>Todo funciona perfectamente, vamos un punto m√°s all√°, √©sta vez descarguemos una p√°gina, como no nos importa ahora mismo el c√≥digo que descarga la p√°gina fingiremos llamar a una funci√≥n <code>petici√≥nHttp(url, callback)</code> que lo har√° por nosotros.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">descargar</span>(<span class="hljs-params">url</span>) {
  <span class="hljs-keyword">var</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>();
  petici√≥<span class="hljs-title function_">nHttp</span>(url, <span class="hljs-keyword">function</span> (<span class="hljs-params">codigoHtml</span>) {
    promise.<span class="hljs-title function_">done</span>();
  });
  <span class="hljs-keyword">return</span> promise;
}
<span class="hljs-title function_">descargar</span>(<span class="hljs-string">'www.google.com'</span>).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
  <span class="hljs-comment">// Y ahora?</span>
});
</code></pre>
<p>Sorpresa! La funci√≥n ha descargado la p√°gina y obtenido el html, pero nuestro Promise no ha sido capaz de pasarlo al callback. La funci√≥n del Promise en un principio era avisar cuando una tarea as√≠ncrona termina, pero la mayor√≠a de las tareas as√≠ncronas devuelven un resultado y cuando avisemos al Promise que se ha cumplido tambi√©n querremos que pase el resultado a todos los callbacks. Para ello modificaremos el m√©todo done y para que pase a los callbacks todos los argumentos que se le pasen a √©l (si no sabes lo que hace el m√©todo apply puedes mirarlo <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/apply" title="appy method">aqu√≠</a>):</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">done</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
  <span class="hljs-comment">// Guardamos los argumentos que se le ha pasado a .done()</span>
  <span class="hljs-keyword">var</span> args = <span class="hljs-variable language_">arguments</span>;
  <span class="hljs-keyword">var</span> callback;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &#x3C; <span class="hljs-variable language_">this</span>.<span class="hljs-property">_callbacks</span>.<span class="hljs-property">length</span>; i++) {
    callback = <span class="hljs-variable language_">this</span>.<span class="hljs-property">_callbacks</span>[i];
    <span class="hljs-comment">// Y se los pasamos al callback</span>
    callback.<span class="hljs-title function_">apply</span>(<span class="hljs-literal">null</span>, args);
  }
};
</code></pre>
<p>Y ya est√°, ahora podemos pasarle argumentos a <code>.done()</code>:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">descargar</span>(<span class="hljs-params">url</span>) {
  <span class="hljs-keyword">var</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>();
  petici√≥<span class="hljs-title function_">nHttp</span>(url, <span class="hljs-keyword">function</span> (<span class="hljs-params">codigoHtml</span>) {
    promise.<span class="hljs-title function_">done</span>(codigoHtml);
  });
  <span class="hljs-keyword">return</span> promise;
}

<span class="hljs-title function_">descargar</span>(<span class="hljs-string">'www.google.com'</span>).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">codigoHtml</span>) {
  <span class="hljs-title function_">alert</span>(codigoHtml);
});
</code></pre>
<p>Ya tenemos nuestra versi√≥n 0.1 de la clase Promise :D</p>
<h3>Segundo: Gesti√≥n de errores</h3>
<p>Hasta aqu√≠ ya tenemos un Promise con el que avisar cuando acaba una tarea as√≠ncrona, pero nos olvidamos de algo muy importante, a la hora de programar no todo sale como quisi√©ramos y muchas veces nos encontramos con errores, que pasar√≠a si <code>petici√≥nHttp()</code> fallara? Que jam√°s se ejecutar√≠a el <code>.done()</code> del Promise que hemos devuelto y el callback esperar√° sentado a que lo llamen el resto de su vida. Hay que preparar el Promise para que avise cuando algo va mal. Necesitamos a√±adirle al Promise:</p>
<ul>
<li>Poder a√±adir callbacks especiales para cuando se produzca un error</li>
<li>Avisarle cuando se produzca un error</li>
<li>Que le pase al callback de error el objeto Error que se ha lanzado</li>
</ul>
<p>Lo primero es que el Promise no solo reciba un callback normal sino que tambi√©n reciba otro callback que ser√° ejecutado solo si se produce un error. Una idea que me gusta es d√°rselo al m√©todo <code>.then()</code> como segundo argumento, ya que el primero es el callback normal. Y √©ste deber√≠a guardarlo, para ello debemos crear otro Array donde guardar los callbacks de errores:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Promise</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">_callbacks</span> = [];
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">_onError</span> = [];
}
<span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">then</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">callback, onError</span>) {
  <span class="hljs-comment">// Validamos el callback normal</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> callback !== <span class="hljs-string">'function'</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">"[Promise.then] El argumento 'callback' no es una funci√≥n "</span> + <span class="hljs-keyword">typeof</span> callback);
  }
  <span class="hljs-comment">// Validamos el callback de error. Como es opcional puede ser 'undefined' o una funci√≥n</span>
  <span class="hljs-keyword">if</span> (onError &#x26;&#x26; <span class="hljs-keyword">typeof</span> onError !== <span class="hljs-string">'function'</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">"[Promise.then] El argumento 'onError' no es una funci√≥n "</span> + <span class="hljs-keyword">typeof</span> onError);
  }

  <span class="hljs-variable language_">this</span>.<span class="hljs-property">_callbacks</span>.<span class="hljs-title function_">push</span>(callback);
  <span class="hljs-comment">// Si no era undefined debe ser una funci√≥n, porque ya lo validamos</span>
  <span class="hljs-keyword">if</span> (onError) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_onError</span>.<span class="hljs-title function_">push</span>(onError);
  }
};
</code></pre>
<p>Como se ve es pr√°cticamente lo mismo que para los callbacks, ya que se trata de lo mismo, un callback por si hay errores. Ahora vamos a matar los √∫ltimos dos puntos de un tiro. A√±adiremos un m√©todo para avisar al Promise cuando se produzca un error y le pasaremos el objeto Error para que lo pase a todos los callbacks de error.</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">fail</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) {
  <span class="hljs-keyword">var</span> callback;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &#x3C; <span class="hljs-variable language_">this</span>.<span class="hljs-property">_onError</span>.<span class="hljs-property">length</span>; i++) {
    callback = <span class="hljs-variable language_">this</span>.<span class="hljs-property">_onError</span>[i];
    <span class="hljs-title function_">callback</span>(error);
  }
};
</code></pre>
<p>Y ya est√°, ahora cuando llamemos al m√©todo <code>.fail()</code> llamar√° a todos los callbacks de error y les pasar√° el objeto Error. Ahora podemos adaptar la funci√≥n <code>descargar()</code> para que tambi√©n notifique cuando se produzca un error:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">descargar</span>(<span class="hljs-params">url</span>) {
  <span class="hljs-keyword">var</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>();
  <span class="hljs-keyword">try</span> {
    petici√≥<span class="hljs-title function_">nHttp</span>(url, <span class="hljs-keyword">function</span> (<span class="hljs-params">codigoHtml</span>) {
      promise.<span class="hljs-title function_">done</span>(codigoHtml);
    });
  } <span class="hljs-keyword">catch</span> (error) {
    promise.<span class="hljs-title function_">fail</span>(error);
  }
  <span class="hljs-keyword">return</span> promise;
}
<span class="hljs-title function_">descargar</span>(<span class="hljs-string">'www.google.com'</span>).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">codigoHtml</span>) {
  <span class="hljs-title function_">alert</span>(codigoHtml);
});
</code></pre>
<p>Ahora ya podemos decir que tenemos la versi√≥n 0.2 del Promise tengo que dejar para otro post m√©todos m√°s complicados como <code>.then()</code> concatenados y el <code>.and()</code> porque ya es muy tarde. Aqu√≠ dejo el c√≥digo completo al que le he a√±adido la propiedad <code>_estado</code> para evitar que se pueda cumplir o fallar un Promise cuando ya est√° cumplido o fallado.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Promise</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">_callbacks</span> = [];
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">_onError</span> = [];
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">_estado</span> = <span class="hljs-string">'esperando'</span>;
}

<span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">then</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">callback, onError</span>) {
  <span class="hljs-comment">// Validamos el callback normal</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> callback !== <span class="hljs-string">'function'</span>)
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">"[Promise.then] El argumento 'callback' no es una funci√≥n "</span> + <span class="hljs-keyword">typeof</span> callback);

  <span class="hljs-comment">// Validamos el callback de error. Como es opcional puede ser 'undefined' o una funci√≥n</span>
  <span class="hljs-keyword">if</span> (onError &#x26;&#x26; <span class="hljs-keyword">typeof</span> onError !== <span class="hljs-string">'function'</span>)
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">"[Promise.then] El argumento 'onError' no es una funci√≥n "</span> + <span class="hljs-keyword">typeof</span> onError);

  <span class="hljs-variable language_">this</span>.<span class="hljs-property">_callbacks</span>.<span class="hljs-title function_">push</span>(callback);
  <span class="hljs-comment">// Si no era undefined debe ser una funci√≥n, porque ya lo validamos</span>
  <span class="hljs-keyword">if</span> (onError) <span class="hljs-variable language_">this</span>.<span class="hljs-property">_onError</span>.<span class="hljs-title function_">push</span>(onError);
};

<span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">done</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) {
  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">_estado</span> !== <span class="hljs-string">'esperando'</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'Intentando cumplir un promise que ya ha finalizado'</span>);

  <span class="hljs-variable language_">this</span>.<span class="hljs-property">_estado</span> = <span class="hljs-string">'cumplido'</span>;
  <span class="hljs-comment">// Guardamos los argumentos que se le ha pasado a .done()</span>
  <span class="hljs-keyword">var</span> args = <span class="hljs-variable language_">arguments</span>;
  <span class="hljs-keyword">var</span> callback;

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &#x3C; <span class="hljs-variable language_">this</span>.<span class="hljs-property">_callbacks</span>.<span class="hljs-property">length</span>; i++) {
    callback = <span class="hljs-variable language_">this</span>.<span class="hljs-property">_callbacks</span>[i];
    <span class="hljs-comment">// Y se los pasamos al callback</span>
    callback.<span class="hljs-title function_">apply</span>(<span class="hljs-literal">null</span>, args);
  }
};

<span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">fail</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) {
  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">_estado</span> !== <span class="hljs-string">'esperando'</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'Intentando hacer fallar un promise que ya ha finalizado'</span>);

  <span class="hljs-variable language_">this</span>.<span class="hljs-property">_estado</span> = <span class="hljs-string">'fallado'</span>;
  <span class="hljs-keyword">var</span> callback;

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &#x3C; <span class="hljs-variable language_">this</span>.<span class="hljs-property">_onError</span>.<span class="hljs-property">length</span>; i++) {
    callback = <span class="hljs-variable language_">this</span>.<span class="hljs-property">_onError</span>[i];
    <span class="hljs-title function_">callback</span>(error);
  }
};
</code></pre></article></div><footer class="amq-footer"><span>Created by A. Mat√≠as Quezada</span><!-- <span>Copyright 2023</span> --></footer></main></body></html>