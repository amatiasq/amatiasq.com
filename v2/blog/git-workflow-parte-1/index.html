<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><link rel="icon" type="image/svg+xml" href="/favicon.svg"><meta name="viewport" content="width=device-width"><meta name="generator" content="Astro v3.4.0"><title>A. Mat√≠as Quezada</title><style>pre code.hljs{display:block;overflow-x:auto;padding:1em}code.hljs{padding:3px 5px}/*!
  Theme: GitHub Dark
  Description: Dark theme as seen on github.com
  Author: github.com
  Maintainer: @Hirse
  Updated: 2021-05-15

  Outdated base version: https://github.com/primer/github-syntax-dark
  Current colors taken from GitHub's CSS
*/.hljs{color:#c9d1d9;background:#0d1117}.hljs-doctag,.hljs-keyword,.hljs-meta .hljs-keyword,.hljs-template-tag,.hljs-template-variable,.hljs-type,.hljs-variable.language_{color:#ff7b72}.hljs-title,.hljs-title.class_,.hljs-title.class_.inherited__,.hljs-title.function_{color:#d2a8ff}.hljs-attr,.hljs-attribute,.hljs-literal,.hljs-meta,.hljs-number,.hljs-operator,.hljs-variable,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-id{color:#79c0ff}.hljs-regexp,.hljs-string,.hljs-meta .hljs-string{color:#a5d6ff}.hljs-built_in,.hljs-symbol{color:#ffa657}.hljs-comment,.hljs-code,.hljs-formula{color:#8b949e}.hljs-name,.hljs-quote,.hljs-selector-tag,.hljs-selector-pseudo{color:#7ee787}.hljs-subst{color:#c9d1d9}.hljs-section{color:#1f6feb;font-weight:700}.hljs-bullet{color:#f2cc60}.hljs-emphasis{color:#c9d1d9;font-style:italic}.hljs-strong{color:#c9d1d9;font-weight:700}.hljs-addition{color:#aff5b4;background-color:#033a16}.hljs-deletion{color:#ffdcd7;background-color:#67060c}pre code.hljs{--_code-margin: var(--code-margin, 1.5em);white-space:pre;background-color:#000;margin:var(--_code-margin) calc(var(--_code-margin) * -1);padding:var(--_code-margin);border-radius:8px}pre code.hljs>.hljs-comment{color:#999}code:not(.hljs){padding:0 .3em .1em;border-radius:5px;background-color:#0000004d}.md li{list-style:initial}.md ul,.md ol{margin:20px 0;padding:reset}.md p{text-align:justify}.md blockquote{border-left:5px solid var(--color-foreground);margin-left:0;padding-left:1em}.md :is(h1,h2,h3,h4,h5,h6){margin-top:2em}
</style>
<link rel="stylesheet" href="/v2/_astro/_slug_.d27839b1.css" />
<style>.tag-list{display:flex;gap:.5em;flex-wrap:wrap;list-style:none;margin:0;padding:0}
</style></head><body><header class="amq-header"><div class="container"><h2 class="amq"><a class="name" href="../../../"><span>{</span><abbr>Adrian</abbr><span class="dot">.</span><span>Mat√≠as Quezada</span><span>}</span></a></h2><nav><a href="../../../blog/">Blog</a><a href="../../../projects/">Projects</a><a href="../../../career/">Career</a><!-- <div class="lang-selector"> --><a href="../../../es/v2/blog/git-workflow-parte-1/">
üá™üá∏
</a><!-- </div> --></nav></div></header><main><div class="container"><h1>GIT Workflow 1 (spanish)</h1><ul class="tag-list md-tags"></ul><article class="md"><p>Acabo de leer <a href="http://scottchacon.com/2011/08/31/github-flow.html">un art√≠culo</a> creado por los trabajadores de <a href="http://www.github.com">Github</a> que han dado una vuelta de tuerca a lo que sab√≠a de GIT y creo que ser√° muy √∫til compartirlo, pero primero vamos por partes:</p>
<h3>Control de Versiones</h3>
<p>Prefiero empezar por lo m√°s b√°sico porque √©sto es algo que los programadores damos por hecho pero para alguien empezando puede ser totalmente desconocido. Una de las herramientas m√°s b√°sicas de un programador junto con el editor de texto es un <strong>sistema de control de versiones</strong>. Se trata b√°sicamente de un programa que <strong>registra los cambios que vamos haciendo en los archivos y cuando nosotros se lo ordenamos (hacemos commit) se guarda el estado actual de los archivos</strong>, si m√°s adelante seguimos haciendo cambio en los archivos y en lugar de mejorar empeora gracias al sistema de control de versiones podemos revertir los archivos y dejarlos tal y como estaban en el √∫ltimo commit o cualquier commit anterior. Adem√°s permite que <strong>dos o m√°s personas puedan archivos de un mismo proyecto y cuando ambos env√≠en sus cambios el sistema har√° lo posible por combinarlos</strong> (hacer merge), en caso de que el merge no se pueda hacer autom√°tico el sistema notifica un conflicto de cambios y nos pide que lo hagamos a mano.</p>
<h3>GIT</h3>
<p>Despu√©s de usar SVN y TFS y SourceSafe en los cuales hacer merge era dram√°tico o bien imposible (en SourceSafe¬†dos personas no pueden modificar el mismo archivo a la vez), descubrir GIT fue fascinante, <strong>la eficacia con la que resuelve conflictos y la capacidad de crear, combinar y destruir ramas</strong> con un simple comando es una herramienta invaluable. El principal problema con las grandes herramientas es que <strong>hay tantas formas de usarlas que si no sabes lo que haces probablemente te encuentres en un caos</strong> y esa es la sensaci√≥n que tuve al dar mis primeros pasos con GIT, estar gastando tiempo y esfuerzo en usar una herramienta compleja sin conseguir exprimirle el jugo.</p>
<h3>GIT Flow</h3>
<p>Finalmente me cruc√© con <a href="http://nvie.com/posts/a-successful-git-branching-model/">GIT Flow</a>, <strong>una gu√≠a para aprovechar el potencial de GIT</strong> en el √°mbito laboral. La idea es bastante sencilla pero las directrices deben ser respetadas para garantizar el orden:</p>
<ul>
<li>Mantener en la <strong>rama <code>master</code> una versi√≥n del c√≥digo lista</strong> para ser utilizada (production-ready)</li>
<li>Mantener en la <strong>rama <code>develop</code> las nuevas funcionalidades</strong> completas de nuestra aplicaci√≥n, esperando a que podamos lanzar otra versi√≥n estable (release)</li>
<li>Las nuevas funcionalidades se desarrollan en ramas creadas a partir de la rama <code>develop</code> y una vez completadas se "mergean" a <code>develop</code></li>
<li>Cuando develop est√© listo para una nueva release se abre una rama y se hace la fase final de testing y los cambios de versi√≥n. Una vez completada √©sta fase la rama de release se "mergea" a <code>develop</code> y <code>master</code> y se a√±ade un <code>tag</code> en <code>master</code> para marcar la release.</li>
<li>Los bugs se arreglan en ramas creadas a partir de <code>master</code> y una vez corregidos igual que una rama de release se se actualiza la versi√≥n y se "mergea" a <code>master</code> y <code>develop</code> y se a√±ade un tag en <code>master</code></li>
</ul>
<p>Para una explicaci√≥n m√°s detallada recomiendo leer el <a href="http://nvie.com/posts/a-successful-git-branching-model/">art√≠culo original</a> (ingl√©s) ya que lo explica mucho mejor de lo que yo podr√≠a. Cada una de √©stas operaciones est√° compuesta de varios comandos git que deben ser ejecutados en un orden dado y es muy com√∫n olvidar alg√∫n paso, principalmente al empezar con el Workflow, por ello <strong>disponemos de <a href="https://github.com/nvie/gitflow">git-flow</a>, una herramienta que a√±ade comandos a git</strong>. <a href="https://github.com/nvie/gitflow/wiki/Installation">Una vez instalado</a> podremos ejecutar comandos como:</p>
<pre><code>git flow feature start my-feature-name
</code></pre>
<p>Que gestionar√° por nosotros la creaci√≥n de la rama a partir de <code>develop</code>. Podemos ver una introducci√≥n a git-flow en el art√≠culo <a href="http://jeffkreeftmeijer.com/2010/why-arent-you-using-git-flow/">Why aren't you using git-flow?</a> (ingƒ∫√©s). Aunque no sobra decir que <strong>en el caso de las interfaces gr√°ficas de GIT hay que seguir los pasos manualmente</strong>.</p>
<p>Personalmente creo que √©ste sistema es bueno si tenemos GIT y no tenemos claro que Workflow seguir. <strong>Es un sistema muy extendido</strong> entre los usuarios de GIT lo que permite que la gente se adapte r√°pidamente y lo considero un punto medio entre complejidad y simpleza. Hay una variante para proyectos que necesitan mantener m√°s de una versi√≥n (es decir, la mayor√≠a de los productos que se venden como paquete cerrado) <strong>en √©sta variante en lugar de poner un tag en <code>master</code> por versi√≥n creamos una nueva rama</strong>, por ejemplo "release-1.4", de √©sta forma disponemos de distintas ramas para cada versi√≥n. √âsto nos permite corregir un bug en una versi√≥n pasada y sacar un parche espec√≠fico.</p>
<p>El proceso <strong>al detectar un bug en la √∫ltima release es probar las releases anteriores hasta detectar la release en la que se introdujo el bug</strong>. Por ejemplo, estamos en la versi√≥n 1.8 pero detectamos un bug que afecta a nuestro producto desde la versi√≥n 1.2. En ese caso corregimos el bug en una rama creada a partir de la rama de la primera versi√≥n que contiene el bug, y una vez corregido se env√≠a a cada rama de release que contenga el bug. Evidentemente <strong>se trata de un Workflow mucho m√°s costoso que no debe ser utilizado a menos que tengamos la necesidad</strong> de mantener m√°s de una versi√≥n del producto que por mi experiencia considero una mala pr√°ctica, pero si nos encontramos en √©sta situaci√≥n nos puede reducir los problemas y ahorrar mucho tiempo. Contin√∫a en <a href="http://www.amatiasq.com/2012/12/git-workflow-flujo-de-trabajo-parte-2/" title="GIT Workflow (Flujo de trabajo) (Parte 2)">la segunda parte</a>...</p></article></div><footer class="amq-footer"><span>Created by A. Mat√≠as Quezada</span><!-- <span>Copyright 2023</span> --></footer></main></body></html>