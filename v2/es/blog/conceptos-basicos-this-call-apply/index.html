<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><link rel="icon" type="image/svg+xml" href="/favicon.svg"><meta name="viewport" content="width=device-width"><meta name="generator" content="Astro v3.4.0"><title>A. Mat√≠as Quezada</title><style>pre code.hljs{display:block;overflow-x:auto;padding:1em}code.hljs{padding:3px 5px}/*!
  Theme: GitHub Dark
  Description: Dark theme as seen on github.com
  Author: github.com
  Maintainer: @Hirse
  Updated: 2021-05-15

  Outdated base version: https://github.com/primer/github-syntax-dark
  Current colors taken from GitHub's CSS
*/.hljs{color:#c9d1d9;background:#0d1117}.hljs-doctag,.hljs-keyword,.hljs-meta .hljs-keyword,.hljs-template-tag,.hljs-template-variable,.hljs-type,.hljs-variable.language_{color:#ff7b72}.hljs-title,.hljs-title.class_,.hljs-title.class_.inherited__,.hljs-title.function_{color:#d2a8ff}.hljs-attr,.hljs-attribute,.hljs-literal,.hljs-meta,.hljs-number,.hljs-operator,.hljs-variable,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-id{color:#79c0ff}.hljs-regexp,.hljs-string,.hljs-meta .hljs-string{color:#a5d6ff}.hljs-built_in,.hljs-symbol{color:#ffa657}.hljs-comment,.hljs-code,.hljs-formula{color:#8b949e}.hljs-name,.hljs-quote,.hljs-selector-tag,.hljs-selector-pseudo{color:#7ee787}.hljs-subst{color:#c9d1d9}.hljs-section{color:#1f6feb;font-weight:700}.hljs-bullet{color:#f2cc60}.hljs-emphasis{color:#c9d1d9;font-style:italic}.hljs-strong{color:#c9d1d9;font-weight:700}.hljs-addition{color:#aff5b4;background-color:#033a16}.hljs-deletion{color:#ffdcd7;background-color:#67060c}pre code.hljs{--_code-margin: var(--code-margin, 1.5em);white-space:pre;background-color:#000;margin:var(--_code-margin) calc(var(--_code-margin) * -1);padding:var(--_code-margin);border-radius:8px}pre code.hljs>.hljs-comment{color:#999}code:not(.hljs){padding:0 .3em .1em;border-radius:5px;background-color:#0000004d}.md li{list-style:initial}.md ul,.md ol{margin:20px 0;padding:reset}.md p{text-align:justify}.md blockquote{border-left:5px solid var(--color-foreground);margin-left:0;padding-left:1em}.md :is(h1,h2,h3,h4,h5,h6){margin-top:2em}
</style>
<link rel="stylesheet" href="/v2/_astro/_slug_.d27839b1.css" />
<style>.tag-list{display:flex;gap:.5em;flex-wrap:wrap;list-style:none;margin:0;padding:0}
</style></head><body><header class="amq-header"><div class="container"><h2 class="amq"><a class="name" href="../../../../"><span>{</span><abbr>Adrian</abbr><span class="dot">.</span><span>Mat√≠as Quezada</span><span>}</span></a></h2><nav><a href="../../../../blog/">Blog</a><a href="../../../../projects/">Projects</a><a href="../../../../career/">Career</a><!-- <div class="lang-selector"> --><a href="../../../../es/v2/es/blog/conceptos-basicos-this-call-apply/">
üá™üá∏
</a><!-- </div> --></nav></div></header><main><div class="container"><h1>Basic Javascript Concepts: this, .call() y .apply() (spanish)</h1><ul class="tag-list md-tags"></ul><article class="md"><p>Antes de continuar con el Patr√≥n Promise me gustar√≠a explicar en paralelo Conceptos B√°sicos de Javascript. Entendiendo que estamos hablando de Javascript como lenguaje y no vamos a hablar sobre conceptos b√°sicos del DOM o como abrir una nueva ventana en el navegador, sino detalles de Javascript puro, tanto en cliente como en servidor.</p>
<h3>De d√≥nde sale <em>this</em></h3>
<p>He pensado que ser√≠a un buen punto empezar por una curiosidad bastante desconocida para los reci√©n llegados a Javascript: La variable <code>this</code>, tambi√©n llamado el <code>scope</code> o m√°s correctamente <code>contexto</code> de la funci√≥n. En los lenguajes basados en clases m√°s extendidos (Java, C++, C#...) encontramos que <strong>los m√©todos de la clase siempre disponen de la variable <code>this</code> que nos permite acceder a nuestra propia instancia</strong> sobre la que se est√° ejecutando el m√©todo. Es decir, si tenemos la clase...</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> {
  <span class="hljs-title class_">String</span> myField;
  <span class="hljs-keyword">void</span> <span class="hljs-title function_">myMethod</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">myField</span>;
  }
}
</code></pre>
<p>Veremos que en myMethod siempre tendremos <code>this</code> apuntando a una variable del tipo <code>MyClass</code> que contendr√° un campo <code>myField</code>. En Javascript √©sto no es as√≠, <strong>en Javascript todo son objetos</strong>, incluidas las funciones y m√©todos, ambos <strong>son instancias de <code>Function</code></strong>, y como tales no est√°n ligadas a un objeto en particular. Miremos el c√≥digo:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myFunction</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);
}

<span class="hljs-keyword">var</span> objectA = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">'Alice'</span>,
  <span class="hljs-attr">myMethod</span>: myFunction,
};

<span class="hljs-keyword">var</span> objectB = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">'Bob'</span>,
  <span class="hljs-attr">myMethod</span>: myFunction,
};
</code></pre>
<p>Aqu√≠ tenemos dos objetos totalmente independientes y ambos tienen la propiedad <code>myMethod</code> apuntado a <code>myFunction</code> a pesar de que no tienen una clase en com√∫n m√°s que <code>Object</code>. Entonces cu√°l es <strong>el valor de this</strong> en <code>myFunction</code>? No es fijo, <strong>cambia seg√∫n como lo llamemos</strong>.</p>
<pre><code class="hljs language-js">objectA.<span class="hljs-title function_">myMethod</span>();
<span class="hljs-comment">// Imprime "Alice"</span>

objectB.<span class="hljs-title function_">myMethod</span>();
<span class="hljs-comment">// Imprime "Bob"</span>
</code></pre>
<p>Pru√©bame</p>
<p>Como vemos el valor de <code>this</code> cambia seg√∫n sobre que objeto lo llamemos. Bien, Javascript sabe que valor tiene que poner a <code>this</code> antes de llamar a una funci√≥n, pero nosotros necesitamos entenderlo para no encontrarnos con bugs imposibles de corregir. Para √©sto hay una regla de oro: <strong>el objeto <code>this</code> pasado a una funci√≥n es el objeto que est√° antes del punto que precede los par√©ntesis que invocan a la funci√≥n</strong>. Es decir, la llamada <code>objectA.myMethod()</code> la podr√≠amos dividir en cuatro partes: _ <strong>objectA</strong>: El objeto que contiene la funci√≥n _ <strong>. (punto)</strong>: Separa el objeto de su propiedad (la funci√≥n) _ <strong>myMethod</strong>: Nombre de la funci√≥n _ <strong>() (par√©ntesis)</strong>: Ejecutan la funci√≥n En √©ste caso vemos que</p>
<p><strong>antes del punto est√° <code>objectA</code></strong> por lo que ser√° <code>objectA</code> lo <strong>que se le pasar√° a la variable <code>this</code></strong> del m√©todo <code>myMethod</code>.</p>
<h3>Casos m√°s complejos</h3>
<h4>M√°s de un punto</h4>
<p>Ahora vamos a ver casos en los que tenemos m√°s o menos de un punto, es menos dif√≠cil de lo que parece. Para empezar, que pasa si usamos namespaces:</p>
<pre><code class="hljs language-js">amq.<span class="hljs-property">test</span>.<span class="hljs-property">StringHelper</span>.<span class="hljs-title function_">firstToUpperCase</span>(<span class="hljs-string">'myname'</span>);
</code></pre>
<p>Aqu√≠ cu√°l es el valor de <code>this</code>? Si miramos la regla de oro veremos que solo el punto que precede a los par√©ntesis debe importarnos, por lo que tenemos:</p>
<ul>
<li><strong>amq.test.StringHelper</strong>: El objeto que contiene la funci√≥n</li>
<li><strong>. (punto)</strong>: Separa el objeto de su propiedad (la funci√≥n)</li>
<li><strong>firstToUpperCase</strong>: Nombre de la funci√≥n</li>
<li><strong>() (par√©ntesis)</strong>: Ejecutan la funci√≥n El valor de</li>
</ul>
<p><strong><code>this</code> siempre es el objeto que est√° antes del √∫ltimo punto</strong>, es decir, el objeto <strong>que contiene la funci√≥n</strong>.</p>
<h4>Sin puntos</h4>
<p>Pero que pasa si no hay ning√∫n punto? si la funci√≥n no est√° en ning√∫n objeto?</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">testScope</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);
}
<span class="hljs-title function_">testScope</span>();
</code></pre>
<p>Aqu√≠ podr√≠amos pensar que <code>this</code> es <code>null</code> y tendr√≠a sentido pero no, Javascript define que una funci√≥n invocada sin contexto, el contexto debe ser el Objeto Global, que en el caso de un navegador ser√≠a <code>window</code>. Por lo que en <strong>una funci√≥n que no est√© contenida en ning√∫n objeto recibir√° el objeto global</strong> como <code>this</code>.</p>
<h3>Callbacks</h3>
<p>Ya con toda √©sta base podemos abordar el problema de los callbacks, supongamos que tenemos una funci√≥n que hace un proceso as√≠ncrono y necesitamos pasarle un callback para que se ejecute cuando el proceso as√≠ncrono termine. Para el ejemplo pondremos que la tarea as√≠ncrona sea esperar un segundo</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">esperarUnSegundo</span>(<span class="hljs-params">callback</span>) {
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-title function_">callback</span>();
  }, <span class="hljs-number">1000</span>);
}
</code></pre>
<p>Perfecto, ya tenemos una funci√≥n que espera que pase un segundo y llama al callback, pero que pasa si la usamos de √©sta forma?</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">var</span> alice = {
  <span class="hljs-attr">nombre</span>: <span class="hljs-string">'Alice'</span>,
  <span class="hljs-attr">cansarse</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-title function_">alert</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">nombre</span> + <span class="hljs-string">' se ha cansado de esperar'</span>);
  },
};
<span class="hljs-title function_">esperarUnSegundo</span>(alice.<span class="hljs-property">cansarse</span>);
</code></pre>
<p>Pru√©bame</p>
<p>Aqu√≠ tenemos un problema, al parecer <code>this.nombre</code> no es "Alice". Porqu√©? Repasemos la regla de oro, <code>this</code> ser√° el objeto que est√° antes del punto que precede a los par√©ntesis que ejecutan la funci√≥n. Busquemos los par√©ntesis que ejecutan la funci√≥n:</p>
<pre><code class="hljs language-js"><span class="hljs-title function_">callback</span>();
</code></pre>
<p>Y vemos que no hay ning√∫n punto delante. <strong>La funci√≥n la hemos extra√≠do del objeto</strong> <code>alice</code>, pero al extraerla la hemos desvinculado de √©l y al llamarlo ya no se le pasa <code>alice</code> porque ya no se la llama con <code>alice.&#x3C;nombre del m√©todo></code> Entonces c√≥mo hacemos para que callback no pierda su contexto? para que mantenga el valor de <code>this</code> a <code>alice</code>?</p>
<h3>Los m√©todos de <code>Function</code></h3>
<p>Para √©sto vienen en nuestra ayuda los m√©todos de <code>Function</code>, como ya dijimos, <strong>las funciones son instancias de la clase <code>Function</code> y como tal tienen tambi√©n m√©todos propios</strong>. Los m√°s utilizados son <code>.call()</code> y <code>.apply()</code></p>
<h4><code>.call()</code> Imaginemos que tenemos otra vez el objeto <code>alice</code> y que guardamos su m√©todo en una variable.</h4>
<pre><code class="hljs language-js"><span class="hljs-keyword">var</span> alice = {
  <span class="hljs-attr">nombre</span>: <span class="hljs-string">'Alice'</span>,
  <span class="hljs-attr">cansarse</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">nombre</span>);
  },
};

<span class="hljs-keyword">var</span> myFunction = alice.<span class="hljs-property">cansarse</span>;
</code></pre>
<p>Si llamamos a <code>myFunction</code> directamente lo estar√≠amos llamando sin contexto por lo el la variable <code>this</code> tendr√≠a el objeto global dentro de <code>myFunction</code>, como podemos hacer que ejecute <code>myFunction</code> pero pas√°ndole <code>alice</code> como <code>this</code>? Para √©sto tenemos las funciones <code>.call()</code> y <code>.apply()</code>, empecemos por la funci√≥n <code>.call()</code>.</p>
<p><strong>La funci√≥n <code>.call()</code> recibe los mismos argumentos que la funci√≥n mas uno, el valor que tendr√° <code>this</code> que se pasa antes que los dem√°s argumentos</strong>. Es decir, nuestra funci√≥n <code>myFunction</code> no recibe ning√∫n argumento as√≠ que si llamamos a su m√©todo <code>.call()</code> y le pasamos lo que queremos que sea <code>this</code> es decir, <code>alice</code> conseguiremos que el m√©todo funcione igual que si lo hubi√©semos llamado con <code>alice.cansarse</code></p>
<pre><code class="hljs language-js">myFunction.<span class="hljs-title function_">call</span>(alice);
</code></pre>
<p>Pru√©bame</p>
<p>Ahora vamos a probar lo mismo con una funci√≥n que reciba argumentos:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">var</span> alice = {
  <span class="hljs-attr">nombre</span>: <span class="hljs-string">'Alice'</span>,
  <span class="hljs-attr">saludar</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">amigo1, amigo2</span>) {
    <span class="hljs-title function_">alert</span>(<span class="hljs-string">'Hola '</span> + amigo1 + <span class="hljs-string">' y '</span> + amigo2 + <span class="hljs-string">', yo soy '</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">nombre</span>);
  },
};

<span class="hljs-keyword">var</span> myFunction = alice.<span class="hljs-property">saludar</span>;
myFunction.<span class="hljs-title function_">call</span>(alice, <span class="hljs-string">'Bob'</span>, <span class="hljs-string">'Rob'</span>);
</code></pre>
<p>Pru√©bame</p>
<p>Como se ve, hemos conseguido modificar el valor que tiene <code>this</code> cuando se ejecuta la funci√≥n, es decir el contexto.</p>
<h4>.apply()</h4>
<p>El m√©todo <code>.apply()</code> act√∫a de forma bastante similar a <code>.call()</code>, pero con una variaci√≥n, solo <strong>recibe dos argumentos, el primero es el contexto de la funci√≥n</strong>, el valor de <code>this</code> <strong>y el segundo ser√° un array que contendr√° los argumentos que se le pasar√°n a la funci√≥n</strong>, veamos su uso en el ejemplo anterior:</p>
<pre><code class="hljs language-js">myFunction.<span class="hljs-title function_">apply</span>(alice, [<span class="hljs-string">'Bob'</span>, <span class="hljs-string">'Rob'</span>]);
</code></pre>
<p>Pru√©bame</p>
<p>Esto aunque en un principio parezca bastante in√∫til nos servir√° cuando, queriendo o no cambiar el contexto de una funci√≥n, <strong>querramos llamarla y no sepamos ni nos interese saber cu√°ntos argumentos tiene</strong>, supongamos que tenemos la funci√≥n <code>callWithAlice()</code> que llama a la funci√≥n <code>.saludar()</code> de <code>alice</code> y le pasa todos los argumentos que recibe.</p>
<p><strong>Nota 1:</strong> Para √©sto hace falta aclarar que el objeto <code>arguments</code> es una especie de array con los argumentos pasados a la funci√≥n, m√°s adelante profundizaremos en ello.</p>
<p><strong>Nota 2:</strong> En √©ste caso no queremos cambiar el contexto, pero como estamos llamando a <code>.apply()</code> tenemos que darle uno, por lo que le damos <code>alice</code> que es el contexto que ya ten√≠a.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">callWithAlice</span>(<span class="hljs-params"></span>) {
  alice.<span class="hljs-property">saludar</span>.<span class="hljs-title function_">apply</span>(alice, <span class="hljs-variable language_">arguments</span>);
}
<span class="hljs-title function_">callWithAlice</span>(<span class="hljs-string">'Rob'</span>, <span class="hljs-string">'Bob'</span>);
</code></pre>
<p>Pru√©bame</p>
<h4>Bonus: .bind()</h4>
<p>Ahora que ya entendemos el contexto, <code>.call()</code> y <code>.apply()</code> sabremos que cuando pasemos una funci√≥n como callback si no queremos perder el contexto de la funci√≥n deberemos hacer:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">esperarUnSegundo</span>(<span class="hljs-params">callback</span>) {
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
    <span class="hljs-title function_">callback</span>();
  }, <span class="hljs-number">1000</span>);
});

<span class="hljs-title function_">esperarUnSegundo</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
  alice.<span class="hljs-title function_">myMethod</span>();
});
</code></pre>
<p>O bien:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">esperarUnSegundo</span>(<span class="hljs-params">callback, context</span>) {
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
    callback.<span class="hljs-title function_">call</span>(context);
  }, <span class="hljs-number">1000</span>);
});

<span class="hljs-title function_">esperarUnSegundo</span>(alice.<span class="hljs-property">myMethod</span>, alice);
</code></pre>
<p>Pero √©sto puede ser un poco tedioso cuando manejas muchos callbacks de √©ste tipo, para ello se ha creado el m√©todo <code>.bind()</code>. Es un m√©todo de <code>Function</code> que devuelve otra funci√≥n. Confuso, verdad?</p>
<p><strong><code>.bind()</code> recibe un argumento, el contexto que se le podr√° a la funci√≥n sobre la que se aplica el <code>.bind()</code> y devolver√° una funci√≥n</strong> que cuando sea llamada ejecutar√° la funci√≥n original con el contexto que se le pas√≥ a <code>.bind()</code>. Lo veremos mejor con un ejemplo:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">var</span> alice = {
  <span class="hljs-attr">nombre</span>: <span class="hljs-string">'Alice'</span>,
  <span class="hljs-attr">saludar</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Hola! Soy '</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">nombre</span>);
  },
};

<span class="hljs-keyword">var</span> myFunction = alice.<span class="hljs-property">saludar</span>.<span class="hljs-title function_">bind</span>(alice);
<span class="hljs-title function_">myFunction</span>();
</code></pre>
<p>Pru√©bame</p>
<p>Lo que hemos hecho en la l√≠nea 8 es crear una funci√≥n que cuando sea invocada llamar√° a <code>saludar</code> y le pasar√° <code>alice</code> como contexto.</p>
<h3>Y ya est√°!</h3>
<p>Con √©ste repaso ya deber√≠amos ser capaces de entender la parte m√°s complicada para un reci√©n llegado a Javascript, la modificaci√≥n del contexto. Es una t√©cnica que requiere mucha pr√°ctica, pero detr√°s de la cual se esconde la mitad del potencial de Javascript y como tal, tambi√©n nos abre los ojos a muchos bugs que de otra forma ser√≠an imposibles de entender.</p>
<p>De hecho, para los que les gusta romperse la cabeza como yo, les dejo un caramelo: Todas las funciones tienen los m√©todos <code>.call()</code>, <code>.apply()</code> y <code>.bind()</code>, es cierto. Pero √©stos m√©todos tambi√©n son funciones, eso significa que podemos hacer √©sto? Que resultado tendr√≠a? Se los dejo a ustedes ;)</p>
<pre><code class="hljs language-js">alice.<span class="hljs-property">saludar</span>.<span class="hljs-property">call</span>.<span class="hljs-property">call</span>.<span class="hljs-property">call</span>.<span class="hljs-property">call</span>.<span class="hljs-property">apply</span>.<span class="hljs-title function_">bind</span>();
</code></pre>
<p>Y que pasa si llamo a uno de √©stos m√©todos y no le paso scope?</p>
<pre><code class="hljs language-js">alice.<span class="hljs-property">saludar</span>.<span class="hljs-title function_">call</span>(<span class="hljs-literal">null</span>);
</code></pre>
<p>Espero que haya sido claro y conciso, pero me temo que ha sido m√°s de lo primero que de lo segundo. Pronto tendr√© otro art√≠culo sobre Conceptos B√°sicos de Javascript. Saludos.</p></article></div><footer class="amq-footer"><span>Created by A. Mat√≠as Quezada</span><!-- <span>Copyright 2023</span> --></footer></main></body></html>