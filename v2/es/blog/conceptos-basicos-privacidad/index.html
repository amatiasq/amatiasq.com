<!DOCTYPE html><html lang="es"><head><meta charset="utf-8"><!-- <link rel="icon" type="image/svg+xml" href="/favicon.svg" /> --><meta name="viewport" content="width=device-width"><title>A. Matías Quezada</title><style>pre code.hljs{display:block;overflow-x:auto;padding:1em}code.hljs{padding:3px 5px}/*!
  Theme: GitHub Dark
  Description: Dark theme as seen on github.com
  Author: github.com
  Maintainer: @Hirse
  Updated: 2021-05-15

  Outdated base version: https://github.com/primer/github-syntax-dark
  Current colors taken from GitHub's CSS
*/.hljs{color:#c9d1d9;background:#0d1117}.hljs-doctag,.hljs-keyword,.hljs-meta .hljs-keyword,.hljs-template-tag,.hljs-template-variable,.hljs-type,.hljs-variable.language_{color:#ff7b72}.hljs-title,.hljs-title.class_,.hljs-title.class_.inherited__,.hljs-title.function_{color:#d2a8ff}.hljs-attr,.hljs-attribute,.hljs-literal,.hljs-meta,.hljs-number,.hljs-operator,.hljs-variable,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-id{color:#79c0ff}.hljs-regexp,.hljs-string,.hljs-meta .hljs-string{color:#a5d6ff}.hljs-built_in,.hljs-symbol{color:#ffa657}.hljs-comment,.hljs-code,.hljs-formula{color:#8b949e}.hljs-name,.hljs-quote,.hljs-selector-tag,.hljs-selector-pseudo{color:#7ee787}.hljs-subst{color:#c9d1d9}.hljs-section{color:#1f6feb;font-weight:700}.hljs-bullet{color:#f2cc60}.hljs-emphasis{color:#c9d1d9;font-style:italic}.hljs-strong{color:#c9d1d9;font-weight:700}.hljs-addition{color:#aff5b4;background-color:#033a16}.hljs-deletion{color:#ffdcd7;background-color:#67060c}pre code.hljs{--_code-margin: var(--code-margin, 1.5em);white-space:pre;background-color:#000;margin:var(--_code-margin) calc(var(--_code-margin) * -1);padding:var(--_code-margin);border-radius:8px}pre code.hljs>.hljs-comment{color:#999}code:not(.hljs){padding:0 .3em .1em;border-radius:5px;background-color:#0000004d}.md{display:grid;gap:24px}.md :is(h1,h2,h3,h4,h5,h6),.md li+li{margin-top:16px}.md :is(ul,pre,code,p){margin-top:0!important;margin-bottom:0!important}.md p{text-align:justify}.md blockquote{border-left:2px solid var(--color-text);margin-left:0;padding-left:1em}
.tag-list{display:flex;gap:.5em;flex-wrap:wrap;list-style:none;margin:0;padding:0}:root{--grid-transparent-width: 960px}
</style>
<link rel="stylesheet" href="/_astro/_slug_.6d0c3eca.css" /><script type="module">CSS.paintWorklet?.addModule("/dot-mesh.js");
</script></head><body class="content-grid"><script defer>
  function closeHamburger() {
    document.querySelector('hamburger-button')?.removeAttribute('active');
  }
</script><script type="module" defer>export const tagName = 'hamburger-button';

export const template = `
  <div class="bar"></div>
  <div class="bar"></div>
  <div class="bar"></div>

  <style>
    :host {
      cursor: pointer;
  
      --_color: var(--color, black);
      --_width: var(--width, 2em);
      --_thickness: var(--thickness, 3px);
      --_spacing: var(--spacing, 7px);
      --_opacity: var(--opacity, 0.5);
  
      --translation-x: calc(var(--_thickness) + var(--_spacing));
    }
  
    .bar {
      width: var(--_width);
      height: var(--_thickness);
      background-color: var(--_color);
      margin: var(--_spacing) 0;
      opacity: var(--_opacity);
  
      will-change: transform, opacity;
      transition: 0.4s;
      transition-property: transform, opacity;
    }
  
    :host(:hover) .bar {
      opacity: 1;
    }
  
    :host([active]) .bar:first-of-type {
      transform: translate(0, var(--translation-x)) rotate(45deg);
    }
  
    :host([active]) .bar:nth-child(2) {
      opacity: 0;
    }
  
    :host([active]) .bar:last-of-type {
      transform: translate(0, calc(var(--translation-x) * -1)) rotate(-45deg);
    }
  </style>
`;

export class HamburgerButton extends HTMLElement {
  #shadowRoot;

  constructor() {
    super();

    this.#shadowRoot = this.attachShadow({ mode: 'open' });
    this.#shadowRoot.innerHTML = template;
  
    this.bars = this.shadowRoot.querySelectorAll(".bar");
    this.toggle = this.toggle.bind(this);
  }

  connectedCallback() {
    this.addEventListener("click", this.toggle);
  }
  disconnectedCallback() {
    this.addEventListener("click", this.toggle);
  }

  toggle() {
    this.toggleAttribute("active");

    const event = new CustomEvent('toggle', {
      detail: {
        active: this.hasAttribute("active")
      }
    });

    this.dispatchEvent(event);
  }
}

customElements.define('hamburger-button', HamburgerButton);</script><hamburger-button><template shadowrootmode="open"><!-- don't fold me  -->
  <div class="bar"></div>
  <div class="bar"></div>
  <div class="bar"></div>

  <style>
    :host {
      cursor: pointer;
  
      --_color: var(--color, black);
      --_width: var(--width, 2em);
      --_thickness: var(--thickness, 3px);
      --_spacing: var(--spacing, 7px);
      --_opacity: var(--opacity, 0.5);
  
      --translation-x: calc(var(--_thickness) + var(--_spacing));
    }
  
    .bar {
      width: var(--_width);
      height: var(--_thickness);
      background-color: var(--_color);
      margin: var(--_spacing) 0;
      opacity: var(--_opacity);
  
      will-change: transform, opacity;
      transition: 0.4s;
      transition-property: transform, opacity;
    }
  
    :host(:hover) .bar {
      opacity: 1;
    }
  
    :host([active]) .bar:first-of-type {
      transform: translate(0, var(--translation-x)) rotate(45deg);
    }
  
    :host([active]) .bar:nth-child(2) {
      opacity: 0;
    }
  
    :host([active]) .bar:last-of-type {
      transform: translate(0, calc(var(--translation-x) * -1)) rotate(-45deg);
    }
  </style>
</template></hamburger-button><nav class="amq-header full-width"><div><div class="internal-links"><a class="nav-link" href="#projects" onclick="closeHamburger();">Proyectos</a><a class="nav-link" href="#experiments" onclick="closeHamburger();">Experimentos</a><a class="nav-link" href="#blog" onclick="closeHamburger();"> Blog</a><a class="nav-link" href="#talks" onclick="closeHamburger();">Charlas</a><a class="nav-link" href="#career" onclick="closeHamburger();">Experiencia</a></div><div class="external-links"><a target="_blank" href="https://github.com/amatiasq"><svg aria-label="Github icon" width="32" height="32" viewBox="0 0 98 96" xmlns="http://www.w3.org/2000/svg">
    <path fill-rule="evenodd" clip-rule="evenodd"
        d="M48.854 0C21.839 0 0 22 0 49.217c0 21.756 13.993 40.172 33.405 46.69 2.427.49 3.316-1.059 3.316-2.362 0-1.141-.08-5.052-.08-9.127-13.59 2.934-16.42-5.867-16.42-5.867-2.184-5.704-5.42-7.17-5.42-7.17-4.448-3.015.324-3.015.324-3.015 4.934.326 7.523 5.052 7.523 5.052 4.367 7.496 11.404 5.378 14.235 4.074.404-3.178 1.699-5.378 3.074-6.6-10.839-1.141-22.243-5.378-22.243-24.283 0-5.378 1.94-9.778 5.014-13.2-.485-1.222-2.184-6.275.486-13.038 0 0 4.125-1.304 13.426 5.052a46.97 46.97 0 0 1 12.214-1.63c4.125 0 8.33.571 12.213 1.63 9.302-6.356 13.427-5.052 13.427-5.052 2.67 6.763.97 11.816.485 13.038 3.155 3.422 5.015 7.822 5.015 13.2 0 18.905-11.404 23.06-22.324 24.283 1.78 1.548 3.316 4.481 3.316 9.126 0 6.6-.08 11.897-.08 13.526 0 1.304.89 2.853 3.316 2.364 19.412-6.52 33.405-24.935 33.405-46.691C97.707 22 75.788 0 48.854 0z"
        fill="#fff">
    </path>
</svg></a><a target="_blank" href="https://www.linkedin.com/in/amatiasq/"><?xml version="1.0" encoding="utf-8"?>
<!-- Uploaded to: SVG Repo, www.svgrepo.com, Generator: SVG Repo Mixer Tools -->
<svg aria-label="LinkedIn Icon" width="32" height="32" viewBox="4 4 16 16" xmlns="http://www.w3.org/2000/svg">
    <path
        d="M18.72 3.99997H5.37C5.19793 3.99191 5.02595 4.01786 4.86392 4.07635C4.70189 4.13484 4.55299 4.22471 4.42573 4.34081C4.29848 4.45692 4.19537 4.59699 4.12232 4.75299C4.04927 4.909 4.0077 5.07788 4 5.24997V18.63C4.01008 18.9901 4.15766 19.3328 4.41243 19.5875C4.6672 19.8423 5.00984 19.9899 5.37 20H18.72C19.0701 19.9844 19.4002 19.8322 19.6395 19.5761C19.8788 19.32 20.0082 18.9804 20 18.63V5.24997C20.0029 5.08247 19.9715 4.91616 19.9078 4.76122C19.8441 4.60629 19.7494 4.466 19.6295 4.34895C19.5097 4.23191 19.3672 4.14059 19.2108 4.08058C19.0544 4.02057 18.8874 3.99314 18.72 3.99997ZM9 17.34H6.67V10.21H9V17.34ZM7.89 9.12997C7.72741 9.13564 7.5654 9.10762 7.41416 9.04768C7.26291 8.98774 7.12569 8.89717 7.01113 8.78166C6.89656 8.66615 6.80711 8.5282 6.74841 8.37647C6.6897 8.22474 6.66301 8.06251 6.67 7.89997C6.66281 7.73567 6.69004 7.57169 6.74995 7.41854C6.80986 7.26538 6.90112 7.12644 7.01787 7.01063C7.13463 6.89481 7.2743 6.80468 7.42793 6.74602C7.58157 6.68735 7.74577 6.66145 7.91 6.66997C8.07259 6.66431 8.2346 6.69232 8.38584 6.75226C8.53709 6.8122 8.67431 6.90277 8.78887 7.01828C8.90344 7.13379 8.99289 7.27174 9.05159 7.42347C9.1103 7.5752 9.13699 7.73743 9.13 7.89997C9.13719 8.06427 9.10996 8.22825 9.05005 8.3814C8.99014 8.53456 8.89888 8.6735 8.78213 8.78931C8.66537 8.90513 8.5257 8.99526 8.37207 9.05392C8.21843 9.11259 8.05423 9.13849 7.89 9.12997ZM17.34 17.34H15V13.44C15 12.51 14.67 11.87 13.84 11.87C13.5822 11.8722 13.3313 11.9541 13.1219 12.1045C12.9124 12.2549 12.7546 12.4664 12.67 12.71C12.605 12.8926 12.5778 13.0865 12.59 13.28V17.34H10.29V10.21H12.59V11.21C12.7945 10.8343 13.0988 10.5225 13.4694 10.3089C13.84 10.0954 14.2624 9.98848 14.69 9.99997C16.2 9.99997 17.34 11 17.34 13.13V17.34Z" />
</svg></a></div></div></nav><h1 class="article-title astro-4sgn5e7x">Conceptos Básicos Javascript: Privacidad</h1><ul class="tag-list md-tags astro-4sgn5e7x"></ul><article class="md astro-4sgn5e7x"><h3>Introducción</h3>
<p>Uno de los temas más frecuentes cuando uno se inicia en Javascript es la privacidad, principalmente viniendo de <strong>lenguajes como Java, C# o C++; donde publican o se ocultan propiedades de los objetos mediante modificadores. Javascript</strong> no posee dichos modificadores sino que <strong>todas las propiedades de los objetos son públicas</strong> lo que puede ser muy confuso para una persona poco diestra en ésta técnica, entre los que me incluyo.</p>
<p>Personalmente cuando diseño un componente (objeto/clase/librería), es porque quiero que ese componente cumpla una funcionalidad, por ejemplo, si yo quiero tener una clase que represente a una impresora necesito enviarle datos y que los imprima; <strong>mi prioridad es que dicho componente sea sencillo de utilizar, lo que facilita la reutilización del componente</strong>. Por lo que primero imagino cómo me gustaría usarlo:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">var</span> impresora = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Impresora</span>();
impresora.<span class="hljs-title function_">encender</span>();
impresora.<span class="hljs-title function_">imprimir</span>(datos);
impresora.<span class="hljs-title function_">apagar</span>();
</code></pre>
<p>Como se ve, para cumplir la funcionalidad me basta con tres métodos, pero si yo escribo mi clase impresora con solo tres métodos probablemente duplicaría mucho código, por ejemplo, que <code>.imprimir()</code> y <code>.apagar()</code> deban comprobar si hay papel en la impresora.</p>
<h3>Soluciones</h3>
<h4>Hacer toda la interfaz pública</h4>
<p>Podríamos crear in método público <code>.hayPapel()</code>, pero personalmente prefiero que la API, la interfaz pública de mi componente sea tan sencilla como sea posible por lo que no quiero hacer ése método público. <strong>Cuando tengo que usar una librería ajena no quiero saber cómo está hecha, quiero saber como usarla</strong>. Por ello si ésta clase tiene el método <code>.hayPapel()</code> le estoy diciendo al programador que ese método está ahí para usarlo, cuando en realidad no es así, ese método está ahí para ayudarme a mi como desarrollador de la clase a no duplicar código.</p>
<h4>Usar la convención de Barra Baja (Underscore, '<code>_</code>')</h4>
<p>Una práctica muy común en Javascript es añadir al principio o al final del nombre de la propiedad el símbolo barra baja con lo que la propiedad es pública, pero <strong>por convención las propiedades que empiezan o finalizan con barra baja no deben ser llamadas desde fuera del componente</strong>:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Impresora</span>(<span class="hljs-params"></span>) { }
<span class="hljs-title class_">Impresora</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = {
    <span class="hljs-attr">encender</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) { ... },
    <span class="hljs-attr">apagar</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) { ... },
    <span class="hljs-attr">imprimir</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">datos</span>) { ... },
    <span class="hljs-attr">_hayPapel</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) { ... }
};
</code></pre>
<p>Este es el método más extendido que he visto en Javascript, porque es una solución que <strong>no afecta al tiempo de ejecución del programa</strong>. Javascript simplemente accede a una propiedad pública sin pérdida de rendimiento. Es una buena solución siempre que se respete la convención, de lo contrario estaríamos acoplando componentes. Eso quiere decir que si quiero hacer pública una propiedad tengo que cambiarle el nombre en todos los puntos en que la utilizo? Desgraciadamente si, pero siempre tienes el consuelo de que será dentro de tu propia librería, ya que si cambias una variable de privada a pública no debería haber ningún punto fuera de tu código que accediera a ésa propiedad, y si lo que estás haciendo es cambiarla de pública a privada... bueno, evidentemente hay que refactorizar el código que utilizara tu librería de cualquier forma.</p>
<h4>Privacidad por constructor</h4>
<p>Los closures son un curioso método de privacidad, cuando creamos una función dentro de otra, <strong>la función hija puede acceder a las variables de la función padre, pero no al revés</strong>:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">5</span>;

<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">var</span> b = <span class="hljs-number">6</span>;

    <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
        <span class="hljs-keyword">var</span> c = <span class="hljs-number">7</span>;
        <span class="hljs-comment">// Desde aquí puedo acceder a 'a', 'b' y 'c'</span>
    }

    <span class="hljs-comment">// Desde aquí puedo acceder a 'a' y 'b'.</span>
    <span class="hljs-comment">// 'c' no existe</span>
}

<span class="hljs-comment">// Desde aquí solo puedo acceder a 'a'.</span>
<span class="hljs-comment">// 'b' y 'c' no existen</span>
</code></pre>
<p>Con ésto podemos buscar la privacidad, si analizamos el constructor de la clase <code>Impresora</code> veremos que es una función, igual que las del ejemplo. De alguna forma <strong>podemos crear variables privadas ahí</strong>.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Impresora</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">var</span> a = <span class="hljs-string">'Privada!'</span>;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Accediendo desde dentro:'</span> + a);
}

<span class="hljs-keyword">var</span> temp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Impresora</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Intentando acceder desde fuera usando 'temp.a': "</span> + temp.<span class="hljs-property">a</span>);

<span class="hljs-comment">// Esta línea no se ejecuta porque 'a' no existe aquí y falla.</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Intentando acceder desde fuera usando 'a': "</span> + a);
</code></pre>
<p>Pruébame</p>
<p>Funciona! Ahora añadamos los métodos:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Impresora</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">var</span> a = <span class="hljs-string">'Privada!'</span>;
}

<span class="hljs-title class_">Impresora</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = {
  <span class="hljs-attr">probando</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Intentando acceder desde un método usando 'this.a': "</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>);

    <span class="hljs-comment">// Esta línea no se ejecuta porque 'a' no existe aquí y falla.</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Intentando acceder desde un método usando 'a': "</span> + a);
  },
};

<span class="hljs-keyword">var</span> temp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Impresora</span>();
temp.<span class="hljs-title function_">probando</span>();
</code></pre>
<p>Pruébame</p>
<p>Pero no podemos acceder desde los métodos! <strong>Porque no están dentro del closure</strong>, de que nos sirve una variable privada si no podemos acceder a ella desde los métodos públicos? Hay una solución: el closure en el que hemos guardado la variable privada es el constructor del objeto, por lo que podríamos aprovechar el dinamismo de Javascript e injectar los métodos en el objeto dentro del constructor, así los métodos podrían acceder a las variables privadas:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Impresora</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">var</span> a = <span class="hljs-string">'Privada!'</span>;

  <span class="hljs-comment">// This es el objeto que éste constructor está creando</span>
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">probando</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Intentando acceder desde un método usando 'this.a': "</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Intentando acceder desde un método usando 'a': "</span> + a);
  };
}

<span class="hljs-keyword">var</span> temp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Impresora</span>();
temp.<span class="hljs-title function_">probando</span>();
</code></pre>
<p>Pruébame</p>
<p>Bien! éste sistema funciona, verdad? No tiene ningún inconveniente? Bueno, tiene uno, pero no es visible a simple vista porque nuestro cerebro y el intérprete de Javascript funcionan de forma distinta. <strong>Para nosotros <code>this.probando = function() { ... }</code> es crear una función y añadirla a todos las instancias de <code>Impresora</code></strong> pero el intérprete no lo ve así, para la máquina Javascript <strong>estamos creando una función por cada método para cada instancia</strong> y tiene sentido, si la primera función <code>probando</code> que creamos accede a la variable privada <code>a</code> de la primera instancia que creamos necesitaremos una función distinta para acceder a la variable privada de la segunda instancia que creemos.</p>
<p>Eso quiere decir que <strong>si creamos 10.000 instancias de <code>Impresora</code> tendremos 10.000 funciones que hacen casi lo mismo en la memoria? Si.</strong> Con las computadoras actuales es casi despreciable, pero si estamos manejando un proyecto en Javascript que puede estar creando y borrando instancias de la clase durante días (por ejemplo un programa de servidor o una RIA), tendremos un problema a medio plazo.</p>
<h3>Privacidad de librería</h3>
<p>Ahora tengo que confesar que he hecho trampas, todos los patrones descritos son para hacer privacidad a nivel de clase, pero <strong>hay una forma más sencilla de hacer privada una clase entera, los closures</strong>. Ahora pensarás "pero me acabas de decir que los closures volvían a crear los métodos por cada instancia!" si, cuando el closure es el constructor. <strong>Pero si englobamos toda la clase en un closure podemos tener privacidad a nivel de librería:</strong></p>
<pre><code class="hljs language-js"><span class="hljs-comment">// función de ejecución inmediata, se crea, se ejecuta y no se vuelve a utilizar</span>
<span class="hljs-comment">// es el closure que guardará la privacidad</span>
(<span class="hljs-keyword">function</span> (<span class="hljs-params"><span class="hljs-variable language_">global</span></span>) {
  <span class="hljs-keyword">var</span> contador = <span class="hljs-number">0</span>;

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">Impresora</span>(<span class="hljs-params"></span>) {
    contador++;
  }

  <span class="hljs-comment">// Creamos un método estático</span>
  <span class="hljs-title class_">Impresora</span>.<span class="hljs-property">cantidadDeInstancias</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> contador;
  };

  <span class="hljs-variable language_">global</span>.<span class="hljs-property">Impresora</span> = <span class="hljs-title class_">Impresora</span>;
})(<span class="hljs-variable language_">this</span>);

<span class="hljs-keyword">var</span> temp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Impresora</span>();
<span class="hljs-keyword">var</span> temp2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Impresora</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Impresora</span>.<span class="hljs-title function_">cantidadDeInstancias</span>());
</code></pre>
<p>Pruébame</p>
<p>La variable <code>contador</code> es <strong>privada a nivel de librería</strong>, significa que <strong>todo lo que esté dentro del closure accede a ella</strong> y como podemos ver todo el código dentro del closure accede a la misma variable, lo que significa que todas las instancias de <code>Impresora</code> comparten la misma variable. También podemos usar éste patrón para ocultar clases y funciones, <strong>lo único que será publicado de dentro del closure será lo que guardemos en la variable <code>global</code>.</strong></p>
<pre><code class="hljs language-js"><span class="hljs-comment">// función de ejecución inmediata, se crea, se ejecuta y no se vuelve a utilizar</span>
<span class="hljs-comment">// es el closure que guardará la privacidad</span>
(<span class="hljs-keyword">function</span> (<span class="hljs-params"><span class="hljs-variable language_">global</span></span>) {
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">Papel</span>(<span class="hljs-params"></span>) {}
  <span class="hljs-title class_">Papel</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = {
    <span class="hljs-attr">hayPapelEn</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">impresora</span>) {
      <span class="hljs-comment">// no hay papel</span>
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    },
    <span class="hljs-attr">pedirAlUsuario</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Oye tu! ponme papel!'</span>);
    },
  };

  <span class="hljs-keyword">var</span> papel = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Papel</span>();

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">Impresora</span>(<span class="hljs-params"></span>) {}
  <span class="hljs-title class_">Impresora</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = {
    <span class="hljs-attr">imprimir</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">datos</span>) {
      <span class="hljs-keyword">if</span> (!papel.<span class="hljs-title function_">hayPapelEn</span>(<span class="hljs-variable language_">this</span>)) papel.<span class="hljs-title function_">pedirAlUsuario</span>();
      <span class="hljs-comment">// imprimir</span>
    },
  };

  <span class="hljs-variable language_">global</span>.<span class="hljs-property">Impresora</span> = <span class="hljs-title class_">Impresora</span>;
})(<span class="hljs-variable language_">this</span>);

<span class="hljs-keyword">var</span> temp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Impresora</span>();
temp.<span class="hljs-title function_">imprimir</span>();
</code></pre>
<p>Pruébame</p>
<p>Este es un patrón muy recomendable, ya que mediante una función autoejecutable ocultamos todo lo que el usuario de nuestra librería no necesita conocer. Por poner un ejemplo, <a href="http://nodejs.org/">node.js</a> utiliza un patrón similar para generar librerías, en las que todas las variables que creamos en el archivo .js quedan ocultas y solo se exponen las propiedades que añadimos al objeto global <code>exports</code>. Ejemplo de saludo.js:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">var</span> saludo = <span class="hljs-string">'Hola!'</span>;
<span class="hljs-keyword">function</span> <span class="hljs-title function_">saludar</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(saludo);
}
<span class="hljs-built_in">exports</span>.<span class="hljs-property">saludar</span> = saludar;
</code></pre>
<p>Si tuviera que decir un defecto de éste patrón, es que <strong>todo lo que queramos englobar dentro del closure deberá estar en el mismo archivo</strong>, ya que el código debe estar dentro del closure y éste no puede estar repartido entre archivos. Ésto es un problema si queremos que dos clases con mucha lógica se comuniquen y no queremos acabar con un archivo de 1.000 líneas de código.</p>
<h3>Resumen</h3>
<p>No voy a opinar si la decisión de hacer todo público al crear Javascript es buena o mala porque en mi opinión <strong>no es que hacer todo público sea malo, sino que no estamos acostrumbrados a utilizarlo</strong>. Por ello, porque la mayoría de los programadores estamos acostumbrado a tener privacidad en los componentes, buscamos entre las opciones que nos da el lenguaje para simularlo.</p>
<p>En cuanto a mi, me parece interesante las posibilidades de un lenguaje tan flexible como Javascript a nivel académico, al fin y al cabo el objetivo de la investigación es tener la mente flexible para que a la hora de la verdad podamos ver caminos alternativos que nos ofrecen una mejor solución para un problema en particular. Un ejemplo de ésto es un patrón de privacidad por instancia que descubrí recientemente, hablaré de él en el <a href="http://www.amatiasq.com/?p=208" title="Experimento: Privacidad por instancias">próximo post</a>.</p></article></body></html>