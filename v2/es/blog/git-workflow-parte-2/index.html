<!DOCTYPE html><html lang="en" class="astro-ydck33jo"><head><meta charset="utf-8"><link rel="icon" type="image/svg+xml" href="/favicon.svg"><meta name="viewport" content="width=device-width"><meta name="generator" content="Astro v3.4.0"><title>A. Mat√≠as Quezada</title><style>pre code.hljs{display:block;overflow-x:auto;padding:1em}code.hljs{padding:3px 5px}/*!
  Theme: GitHub Dark
  Description: Dark theme as seen on github.com
  Author: github.com
  Maintainer: @Hirse
  Updated: 2021-05-15

  Outdated base version: https://github.com/primer/github-syntax-dark
  Current colors taken from GitHub's CSS
*/.hljs{color:#c9d1d9;background:#0d1117}.hljs-doctag,.hljs-keyword,.hljs-meta .hljs-keyword,.hljs-template-tag,.hljs-template-variable,.hljs-type,.hljs-variable.language_{color:#ff7b72}.hljs-title,.hljs-title.class_,.hljs-title.class_.inherited__,.hljs-title.function_{color:#d2a8ff}.hljs-attr,.hljs-attribute,.hljs-literal,.hljs-meta,.hljs-number,.hljs-operator,.hljs-variable,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-id{color:#79c0ff}.hljs-regexp,.hljs-string,.hljs-meta .hljs-string{color:#a5d6ff}.hljs-built_in,.hljs-symbol{color:#ffa657}.hljs-comment,.hljs-code,.hljs-formula{color:#8b949e}.hljs-name,.hljs-quote,.hljs-selector-tag,.hljs-selector-pseudo{color:#7ee787}.hljs-subst{color:#c9d1d9}.hljs-section{color:#1f6feb;font-weight:700}.hljs-bullet{color:#f2cc60}.hljs-emphasis{color:#c9d1d9;font-style:italic}.hljs-strong{color:#c9d1d9;font-weight:700}.hljs-addition{color:#aff5b4;background-color:#033a16}.hljs-deletion{color:#ffdcd7;background-color:#67060c}pre code.hljs{--_code-margin: var(--code-margin, 1.5em);white-space:pre;background-color:#000;margin:var(--_code-margin) calc(var(--_code-margin) * -1);padding:var(--_code-margin);border-radius:8px}pre code.hljs>.hljs-comment{color:#999}code:not(.hljs){padding:0 .3em .1em;border-radius:5px;background-color:#0000004d}.md li{list-style:initial}.md ul,.md ol{margin:20px 0;padding:reset}.md p{text-align:justify}.md blockquote{border-left:5px solid var(--color-foreground);margin-left:0;padding-left:1em}.md :is(h1,h2,h3,h4,h5,h6){margin-top:2em}
</style>
<link rel="stylesheet" href="/v2/_astro/_slug_.35648afe.css" />
<style>.tag-list{display:flex;gap:.5em;flex-wrap:wrap;list-style:none;margin:0;padding:0}
</style></head><body class="astro-ydck33jo"><header class="amq-header"><div class="container"><h2 class="amq"><a class="name" href="../../../../"><span>{</span><abbr>Adrian</abbr><span class="dot">.</span><span>Mat√≠as Quezada</span><span>}</span></a></h2><nav><a href="../../../../blog/">Blog</a><a href="../../../../projects/">Projects</a><a href="../../../../career/">Career</a><!-- <div class="lang-selector"> --><a href="../../../../es/v2/es/blog/git-workflow-parte-2/">
üá™üá∏
</a><!-- </div> --></nav></div></header><main class="astro-ydck33jo"><div class="container"><h1>GIT Workflow 2 (spanish)</h1><ul class="tag-list md-tags"></ul><article class="md"><p>Continuando con <a href="http://www.amatiasq.com/2012/12/git-workflow-flujo-de-trabajo-parte-1/" title="GIT Workflow (Flujo de trabajo) (Parte 1)">mi √∫ltimo art√≠culo</a>, lleg√≥ la hora de hablar del gran <em>Github Flow</em>:</p>
<h3>Github Flow</h3>
<p>Y finalmente <a href="http://scottchacon.com/2011/08/31/github-flow.html">el art√≠culo</a> que ha inspirado √©ste. Despu√©s de probar el Git Flow (el modelo, no la herramienta) en productos profesionales y a modo de prueba en <a href="https://github.com/amatiasq/jsbase">peque√±as librer√≠as</a> propias y <strong>aunque para proyectos grandes donde una release se planea durante semanas va bien, en peque√±os proyectos, y en proyectos SaaS no acaba de encajar</strong>.</p>
<p>Para empezar en peque√±os proyectos no hay necesidad de planificar con antelaci√≥n una release, <strong>un proyecto peque√±o necesita mucha actividad y poca burocracia para crecer</strong>, por otro lado, en proyectos SaaS (Software as a Serivce), es decir, productos que est√°n disponibles online y todos los usuarios tienen la √∫ltima versi√≥n y reciben los cambios inmediatamente **las versiones y releases pierden fuerza. **Porqu√© retrasar el lanzamiento de una nueva funcionalidad cuando todos los usuarios podr√≠an tenerla ma√±ana sin ning√∫n coste? en un producto cl√°sico las funcionalidades se empaquetan para entregar al usuario la actualizaci√≥n un paquete cerrado y pasar el proceso de actualizaci√≥n la menor cantidad de veces posibles, pero <strong>en un SaaS para el usuario no tiene ning√∫n coste (en esfuerzo) una actualizaci√≥n</strong>, simplemente la pr√≥xima vez que abra el programa tendr√° la funcionalidad.</p>
<p>Un ejemplo de SaaS es Gmail (que estuvo m√°s de 5 a√±os en fase Beta por √©ste motivo), twitter o github. Y es √©ste √∫ltimo qui√©n, como no pod√≠a ser de otra forma, utiliza <strong>un flujo de trabajo de GIT que parece encajar bastante bien con la filosof√≠a SaaS</strong> de release constantes. Lo que ellos llaman <strong><code>Github Flow</code></strong>.</p>
<p>Como ellos mismos dicen despu√©s de mentar las ventajas de git-flow, "One of the bigger issues for me is that it‚Äôs more complicated than I think most developers and development teams actually require" (Uno de sus mayores problemas para mi es que <strong>[git-flow] es m√°s complicado de lo que creo que muchos equipos de desarrollo realmente necesitan</strong>)</p>
<blockquote>
<p>So, why don‚Äôt we use git-flow at GitHub? Well, the main issue is that we deploy all the time." (Porqu√© no usamos git-flow en Github? Bueno, el mayor problema es que <strong>nosotros hacemos releases todo el tiempo</strong>).</p>
</blockquote>
<p>B√°sicamente utilizan un flujo de trabajo que combina la potencia de GIT con las geniales herramientas de Github por lo que es aplicable tal cual a los proyectos alojados en Github.com:</p>
<ul>
<li>El contenido en <code>master</code> es una versi√≥n lista para ser utilizada, lo mismo que en git-flow.</li>
<li>Crear ramas descriptivas a partir de <code>master</code> en el repositorio y hacer push constantemente.</li>
<li>Abrir "Pull Request" en Github en cualquier momento</li>
<li><strong>Hacer merge a <code>master</code> solo despu√©s de una revisi√≥n del "Pull Request"</strong></li>
<li>Enviar el c√≥digo a producci√≥n inmediatamente despu√©s del merge (es decir, enviar a los clientes)</li>
</ul>
<p>Igual que en git-flow, <code>master</code> tiene que ser c√≥digo estable listo para poner en producci√≥n, pero en √©ste Workflow adem√°s debe ser la rama a partir de la cual crear el resto de ramas. En resumen, <strong>cualquier desarrollador puede crear una rama partiendo de <code>master</code> mientras tenga un nombre claro y coherente</strong>, bien sea para corregir un bug o implementar una nueva funcionalidad. A partir de entonces el desarrollador puede hacer todos los commits que necesite y hacer <code>push</code> a la rama en el repositorio constantemente.</p>
<p>En Github mencionan muchas ventajas de √©sta fase, en primer lugar, que al hacer pull cada desarrollador recibe informaci√≥n de las ramas en las que hay actividad, y si su nombre es descriptivo es sencillo de analizar. Adem√°s <strong>en la p√°gina de Github del repositorio podemos consultar las ramas actuales y cu√°nto se ha avanzado en cada una</strong>, como si de una lista de futuras funcionalidades se tratara (ver imagen art√≠culo original). Por otro lado, los push constantes da visibilidad al resto del equipo de la actividad y garantiza la copia de seguridad de nuestros cambios. Y por fin mi parte favorita, mi descubrimiento del d√≠a, los Pull Request de Github.</p>
<p><strong>Un Pull Request consiste en que despu√©s de hacer commits y push en una rama, dejamos una notificaci√≥n de intenci√≥n de hacer merge a <code>master</code></strong>. Al hacer un Pull Request, en la p√°gina de Github del repositorio aparece nuestra notificaci√≥n con la lista de commits que hemos hecho, y todos los cambios que hemos hecho (en rojo l√≠neas borradas y en verde l√≠neas a√±adidas). Esto es muy utilizado para ofrecer al due√±o de un repositorio un parche o una mejora para que sea aplicado en <code>master</code>, lo que me sorprendi√≥ es el uso que le da Github.</p>
<p>A partir de aqu√≠ <strong>cualquier usuario puede a√±adir comentarios a una l√≠nea espec√≠fica del c√≥digo modificado en los commits</strong>, o un comentario general y abrir debate. Lo que a nivel profesional se conoce como <strong><code>code review</code></strong> (repaso del c√≥digo) en el que un tercero nos ayuda a repasar nuestros cambios. Esto siempre que se enfoque con una actitud positiva por ambas partes, permite <strong>extender el conocimiento de esa secci√≥n del c√≥digo y detectar bugs con antelaci√≥n</strong>, simplemente porque cuatro ojos ven m√°s que dos.</p>
<blockquote>
<p>Actually, we use it more as a branch conversation view more than a pull request (En realidad, <strong>[los Pull Request] los usamos m√°s como p√°gina de conversaci√≥n sobre la rama que como petici√≥n de pull</strong>).</p>
</blockquote>
<p>Seg√∫n el <em>Github Flow</em> cuando hayamos acabado el desarrollo de la rama o simplemente nos hayamos atascado o necesitamos que un dise√±ador de el visto bueno al resultado (ya que se pueden adjuntar im√°genes a los comentarios con <a href="http://es.wikipedia.org/wiki/Markdown">Markdown</a>), abrimos un Pull Request y <strong>escribiendo @ en el comentario esa persona recibir√° una notificaci√≥n de nuestro Pull Request</strong>. En Github recomiendan usar "/cc @" para poner "En copia" a los interesados. A medida que recibimos opiniones y recomendaciones de otros usuarios mediante el Pull Request <strong>podemos seguir haciendo commits que autom√°ticamente se a√±adir√°n al Pull Request</strong>.</p>
<p>Una vez el trabajo est√° hecho y hemos pasado el <em>code review</em> esperamos (solicitamos) recibir el visto bueno de alg√∫n o varios compa√±eros</p>
<blockquote>
<p>This is generally a +1 or emoji or ‚Äú:shipit:‚Äù" (Esto suele ser un +1 o el emoticono ‚Äú:shipit:‚Äù)</p>
</blockquote>
<p><strong>Y hayamos pasado los tests, podemos hacer el merge a <code>master</code> nosotros mismos</strong>, cuando hagamos push de <code>master</code> con los cambios aplicados el Pull Request se cerrar√° autom√°ticamente. Finalmente, inmediatamente despu√©s de hacer el merge a <code>master</code> <strong>debemos enviar el c√≥digo a producci√≥n</strong>, que en el caso de Github lo hacen mediante un comando enviado por chat, pero debemos enviar el c√≥digo inmediatamente a producci√≥n para poder detectar posibles bugs con la m√°xima antelaci√≥n posible porque si algo nos da mala imagen como desarrolladores es que el trabajo de otra persona falle al ser enviado a producci√≥n por algo que nosotros cambiamos y no enviamos. En el art√≠culo original se puede ver una imagen en la que <strong>un solo d√≠a se actualiz√≥ el c√≥digo de producci√≥n nada menos que 24 veces</strong>. El mismo c√≥digo que recibimos nosotros al entrar a Github.com</p>
<p>Ha sido largo de explicar, pero quise hacer mucho √©nfasis en los Pull Request ya que es un uso innovador (al menos para mi) tra√≠do de la mano de sus creadores que lo usan activamente por lo que est√° m√°s que garantizada su fiabilidad. En mi opini√≥n es <strong>el mejor flujo de trabajo para desarrollar productos SaaS</strong>, permitiendo lanzar funcionalidades constante e inmediatamente.</p>
<p>Sin embargo, como todas las grandes metodolog√≠as, creo que es muy importante la implicaci√≥n de todo el equipo en el Workflow. <strong>El Workflow est√° basado en que un desarrollador sabe esperar a revisar el c√≥digo a fondo</strong> y recibir feedback antes de hacer el merge a master, y creo que es bastante m√°s complicado de lo que parece superar la tentaci√≥n de tener el "trabajo hecho" pero sin revisar.</p>
<h3>Conclusi√≥n A la fecha me encuentro con tres Workflows para trabajar con GIT:</h3>
<p><strong>Git-flow</strong> - Bastante gen√©rico, en mi opini√≥n si parte del equipo ya conoce √©sta metodolog√≠a es la que utilizar√≠a "por defecto" al empezar un proyecto profesional. Y aunque suene evidente, no est√° de m√°s decir que para peque√±os proyectos puede resultar excesivo.</p>
<h5>Pros</h5>
<ul>
<li><strong>Est√°ndar</strong> - muy conocido en la comunidad GIT</li>
<li><strong>Gen√©rico</strong> - en mi opini√≥n es f√°cil adaptar √©sta metodolog√≠a a medida que avanza el proyecto</li>
</ul>
<h5>Cons</h5>
<ul>
<li><strong>Complejo</strong> - Para una persona comenzando en GIT puede resultar demasiado aprender la secuencia necesaria para cada fase</li>
</ul>
<p><strong>Git-flow con ramas por release</strong> - No muy recomendable por a√±adir una complejidad excesiva, pero para los proyectos elefante en los que tenemos tres clientes con versiones distinta puede ahorrarnos tiempo y esfuerzo.</p>
<h5>Pros</h5>
<ul>
<li><strong>Utilidad clara</strong> - personalmente saber con precisi√≥n d√≥nde es √∫til es una ventaja a la hora de tenerla en considerarlo</li>
</ul>
<h5>Cons</h5>
<ul>
<li><strong>Rebuscado</strong> - hay que tener cierta experiencia para evitar que √©sta metodolog√≠a se descontrole</li>
</ul>
<p><strong>Github Flow</strong> - En mi opini√≥n la soluci√≥n perfecta para un producto SaaS.</p>
<h5>Pros</h5>
<ul>
<li><strong>Probado</strong> - que √©ste sistema est√© en marcha en Github da mucha confianza, m√°xime siendo ellos los creadores de una de las mejores herramientas para GIT</li>
</ul>
<h5>Cons</h5>
<ul>
<li><strong>Equipo conscienciado</strong> - √©ste Workflow requiere mucha atenci√≥n ya que constantemente estaremos aplicando c√≥digo en producci√≥n con los riesgos que conlleva para nuestros clientes</li>
</ul></article></div><footer class="amq-footer"><span>Created by A. Mat√≠as Quezada</span><!-- <span>Copyright 2023</span> --></footer></main></body></html>