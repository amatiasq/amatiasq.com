<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><link rel="icon" type="image/svg+xml" href="/favicon.svg"><meta name="viewport" content="width=device-width"><meta name="generator" content="Astro v3.4.0"><title>A. Mat칤as Quezada</title><style>pre code.hljs{display:block;overflow-x:auto;padding:1em}code.hljs{padding:3px 5px}/*!
  Theme: GitHub Dark
  Description: Dark theme as seen on github.com
  Author: github.com
  Maintainer: @Hirse
  Updated: 2021-05-15

  Outdated base version: https://github.com/primer/github-syntax-dark
  Current colors taken from GitHub's CSS
*/.hljs{color:#c9d1d9;background:#0d1117}.hljs-doctag,.hljs-keyword,.hljs-meta .hljs-keyword,.hljs-template-tag,.hljs-template-variable,.hljs-type,.hljs-variable.language_{color:#ff7b72}.hljs-title,.hljs-title.class_,.hljs-title.class_.inherited__,.hljs-title.function_{color:#d2a8ff}.hljs-attr,.hljs-attribute,.hljs-literal,.hljs-meta,.hljs-number,.hljs-operator,.hljs-variable,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-id{color:#79c0ff}.hljs-regexp,.hljs-string,.hljs-meta .hljs-string{color:#a5d6ff}.hljs-built_in,.hljs-symbol{color:#ffa657}.hljs-comment,.hljs-code,.hljs-formula{color:#8b949e}.hljs-name,.hljs-quote,.hljs-selector-tag,.hljs-selector-pseudo{color:#7ee787}.hljs-subst{color:#c9d1d9}.hljs-section{color:#1f6feb;font-weight:700}.hljs-bullet{color:#f2cc60}.hljs-emphasis{color:#c9d1d9;font-style:italic}.hljs-strong{color:#c9d1d9;font-weight:700}.hljs-addition{color:#aff5b4;background-color:#033a16}.hljs-deletion{color:#ffdcd7;background-color:#67060c}pre code.hljs{--_code-margin: var(--code-margin, 1.5em);white-space:pre;background-color:#000;margin:var(--_code-margin) calc(var(--_code-margin) * -1);padding:var(--_code-margin);border-radius:8px}pre code.hljs>.hljs-comment{color:#999}code:not(.hljs){padding:0 .3em .1em;border-radius:5px;background-color:#0000004d}.md li{list-style:initial}.md ul,.md ol{margin:20px 0;padding:reset}.md p{text-align:justify}.md blockquote{border-left:5px solid var(--color-foreground);margin-left:0;padding-left:1em}.md :is(h1,h2,h3,h4,h5,h6){margin-top:2em}
</style>
<link rel="stylesheet" href="/v2/_astro/_slug_.d27839b1.css" />
<style>.tag-list{display:flex;gap:.5em;flex-wrap:wrap;list-style:none;margin:0;padding:0}
</style></head><body><header class="amq-header"><div class="container"><h2 class="amq"><a class="name" href="../../../../"><span>{</span><abbr>Adrian</abbr><span class="dot">.</span><span>Mat칤as Quezada</span><span>}</span></a></h2><nav><a href="../../../../blog/">Blog</a><a href="../../../../projects/">Projects</a><a href="../../../../career/">Career</a><!-- <div class="lang-selector"> --><a href="../../../../es/v2/es/blog/asincronia-y-el-eventloop/">
游쀯릖
</a><!-- </div> --></nav></div></header><main><div class="container"><h1>Asynchrony and the Event Loop (spanish)</h1><ul class="tag-list md-tags"></ul><article class="md"><p>Me gustar칤a hacer un repaso al tema de la asincron칤a en Javascript porque me llama la atenci칩n que pese a tener casi 20 a침os es un tema que sigue madurando y he visto surgir buenas ideas recientemente.</p>
<h3>El event loop</h3>
<p>Primero lo primero, de donde sale la asincron칤a. Javascript es un lenguaje cuya ejecuci칩n se basa en lo que se llama <strong>event loop</strong> (bucle de eventos). El <em>event loop</em> es una cola donde se van a침adiendo los bloques de c칩digo que quieren ejecutarse, por ejemplo: cuando el navegador est치 renderizando el HTML de una p치gina y se encuentra un tag <code>&#x3C;script></code> el contenido de ese elemento se a침ade al <em>event loop</em> para que sea ejecutado tan pronto como sea posible.</p>
<p>Lo mismo ocurre cuando la p치gina ya est치 cargada y el usuario hace click. Si tenemos una funci칩n listener (tambi칠n llamado callback) escuchando los eventos click de un objeto esa funci칩n se a침ade a la cola del <em>event loop</em> para que el sistema lo ejecute tan pronto como sea posible.</p>
<p>De esta forma todos los bloques de c칩digo que se ejecutan en javascript han sido bloques de c칩digo que entraron a la cola del <em>event loop</em> y cuando lleg칩 su turno fueron ejecutados. Podemos entenderlo m치s f치cilmente si implementamos un falso event loop en Javascript:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">var</span> eventLoop = {
  <span class="hljs-attr">_queue</span>: [],

  <span class="hljs-attr">add</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">fn</span>) {
    <span class="hljs-comment">// a침adimos la funci칩n a la cola</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_queue</span>.<span class="hljs-title function_">push</span>(fn);

    <span class="hljs-comment">// si est치 desocupado ejecutar la funci칩n</span>
    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">running</span>) <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">executeNext</span>();
  },

  <span class="hljs-attr">executeNext</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">running</span> || <span class="hljs-variable language_">this</span>.<span class="hljs-property">_queue</span>.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;

    <span class="hljs-variable language_">this</span>.<span class="hljs-property">running</span> = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">var</span> block = <span class="hljs-variable language_">this</span>.<span class="hljs-property">_queue</span>.<span class="hljs-title function_">shift</span>();
    <span class="hljs-title function_">block</span>();
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">running</span> = <span class="hljs-literal">false</span>;

    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">executeNext</span>();
  },
};
</code></pre>
<p>Pru칠bame</p>
<p>Esto significa que mientras un bloque est칠 ejecut치ndose ning칰n otro bloque de c칩digo puede estar ejecut치ndose a la vez. Pero si un proceso tarda mucho (como leer el disco, comunicarse con el servidor, esperar una determinada cantidad de tiempo...) lo que hacemos es pasarles una funci칩n que ser치 a침adida al <em>event loop</em> cuando el proceso acabe.</p>
<p>Cada "bloque" que el <em>event loop</em> ejecuta se llama "un tick del event loop", de ah칤 el nombre de la funci칩n <code>process.nextTick</code> de NodeJS.</p>
<p>Una forma sencilla de controlar el <em>event loop</em> es mediante <code>setTimeout</code>, <code>setInterval</code> y <code>setImmediate</code>, podemos crear funciones similares que hagan la misma funcionalidad (simplificada) pero para nuestro <code>eventLoop</code>:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">mySetImmediate</span>(<span class="hljs-params">fn</span>) {
  eventLoop.<span class="hljs-title function_">add</span>(fn);
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">mySetTimeout</span>(<span class="hljs-params">fn, milliseconds</span>) {
  <span class="hljs-comment">// la unica forma de dejar pasar el tiempo</span>
  <span class="hljs-comment">// es mediante el VERDADERO setTimeout ;)</span>
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-title function_">mySetImmediate</span>(fn);
  }, milliseconds);
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">mySetInterval</span>(<span class="hljs-params">fn, milliseconds</span>) {
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">execute</span>(<span class="hljs-params"></span>) {
    <span class="hljs-title function_">fn</span>();
    <span class="hljs-title function_">mySetTimeout</span>(execute, milliseconds);
  }

  <span class="hljs-title function_">mySetTimeout</span>(execute, milliseconds);
}
</code></pre>
<p>Como se puede ver tanto setTimeout como setInterval esperan la cantidad de milisegundos definida y <strong>entonces a침aden</strong> el bloque al <em>event loop</em>, si el <em>event loop</em> est치 ocupado en ese momento puede tardar un poco m치s de lo esperado en ejecutarse nuestra funci칩n.</p>
<p>Entiendiendo esto es m치s f치cil entender porqu칠 Javascript funciona de la forma que funciona.</p>
<ul>
<li>Solo hay un bloque de c칩digo ejecutandose en cada momento</li>
<li>Los bloques se encolan</li>
<li>Se considera as칤ncrono a una secci칩n de c칩digo que ser치 ejecutada en un "tick" distinto</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;
<span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
  <span class="hljs-comment">// esta funci칩n es as칤ncrona porque el tick que llama a setTimeout</span>
  <span class="hljs-comment">// tiene que acabar antes que esta funci칩n sea invocada.</span>
  a = <span class="hljs-number">2</span>;
}, <span class="hljs-number">100</span>);
</code></pre>
<p>En el caso de javascript para el navegador adem치s nos encontramos con que el <em>event loop</em> es compartido por Javascript y el motor de renderizado del navegador. Como el <em>event loop</em> solo puede ejecutar un bloque por vez resulta que si estamos ejecutando Javascript el navegador no puede renderizar la p치gina y vice versa, si la p치gina tarda mucho en renderizarse retrasar치 la ejecuci칩n del Javascript. Esto es as칤 porque desde Javascript podemos modificar el DOM y si el navegador intenta renderizar la p치gina mientras nosotros la modificamos tendr칤amos otro tipo de problemas peores.</p>
<p>Pero es importante tener esto en cuenta ya que un proceso Javascript que tarde demasiado "congelar치" la p치gina, no funcionar치n los clicks, scroll, ni siquiera los <code>:hover</code>.</p>
<h3>Un poco de historia</h3>
<p>Cuando Javascript fue desarrollado la comunicaci칩n as칤ncrona con el DOM se solucion칩 mediante eventos y tiene todo el sentido del mundo. Quieres saber cuando el usuario hace click en un elemento? Registra el evento y el navegador te avisar치, quieres saber cuando el usuario haga scroll? registra el evento!</p>
<p>El problema empez칩 cuando empezamos a usar eventos para cosas no tan claras, como eventos puntuales que solo se disparaban una vez:</p>
<pre><code class="hljs language-js"><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'load'</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) { ... });
<span class="hljs-title function_">someAjax</span>().<span class="hljs-property">onready</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) { ... };
</code></pre>
<p>Incluso para controlar errores</p>
<pre><code class="hljs language-js">xhr.<span class="hljs-property">onerror</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) { ... };
<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">"script"</span>).<span class="hljs-property">onerror</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) { ... };
</code></pre>
<p>Hasta para controlar un progreso (en APIs modernas incluso)</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">var</span> reader = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>();
reader.<span class="hljs-property">onprogress</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) { ... };
</code></pre>
<p>Pero al no estar acostumbrados a trabajar con asincron칤a de esta forma no fuimos capaces de ver que estabamos usando una herramienta para todo, como dicen por ah칤 "para un hombre con un martillo todo es un clavo".</p>
<p>En node decidieron adaptar el patr칩n "Continuous Passing Style", que consiste en pasar callbacks a funciones as칤ncronas</p>
<pre><code class="hljs language-js">fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">"foo"</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) { ... });
</code></pre>
<p>Y por suerte integraron <code>EventEmitter</code>, que permiti칩 crear APIs que usaran eventos sin m치s complejidad. Y lo que es mejor, incluyeron los streams, una forma de gesti칩n de asincron칤a creada para que podamos acceder a un recurso por partes. Con el tiempo llegaron los promises que fue lo primero que me hizo plantearme si est치bamos enfocando la asincron칤a de forma coherente.</p>
<p>En total he llegado a resumir los distintos tipos de asincron칤a en dos, ambos con la caracter칤stica de que necesitan gestionar tambi칠n errores:</p>
<ul>
<li><strong>Valor as칤ncrono</strong>: el callback se invoca una sola vez en el futuro</li>
<li><strong>Collecci칩n as칤ncrona</strong>: el callback se invoca una vez por cada elemento en la colecci칩n</li>
</ul>
<h3>Valor as칤ncrono</h3>
<p>En el primer caso tenemos un valor as칤ncrono, puede ser el valor devuelto por una funci칩n as칤ncrona o el valor puede ser nulo en cuyo caso simplemente funcionar칤a para detectar cuando el proceso ha finalizado. Este caso est치 cubierto por los Promises.</p>
<p>Desde mi punto de vista se trata de una especie de meta-programaci칩n, tenemos un valor (el promise) que sustituye al valor real para que podamos seguir con nuestra ejecuci칩n s칤ncrona.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">var</span> contentPromise = file.<span class="hljs-title function_">readContent</span>();
<span class="hljs-keyword">return</span> contentPromise;
</code></pre>
<h3>Colecci칩n as칤ncrona</h3>
<p>Podemos verlo como un array as칤ncrono, que a medida que se le van a침adiendo elementos va invocando a su callback. En este grupo meter칤a a todo componente as칤ncrono que invoque a su callback m치s de una vez:</p>
<ul>
<li>Flujo de datos</li>
<li>Progreso</li>
<li>Eventos</li>
</ul>
<p>Una de las funcionalidades que m치s me gustan de <a href="https://www.dartlang.org/">Dart</a> es que <a href="https://www.dartlang.org/articles/improving-the-dom/#events">han sustitu칤do los eventos DOM por streams</a>, un peque침o detalle pero que es todo un cambio de concepto, los eventos DOM son una lista de tama침o indeterminado. Cada vez que el usuario hace click es como a침adir ese evento al stream de eventos click de ese elemento. Al ser un stream podemos escucharlo, filtrarlo, manipularlo... de la misma forma que hacemos con una colecci칩n. Incluso hay implementaciones que tienen m칠todos <code>.forEach</code> y <code>.filter</code> y <code>.map</code> cumpliendo la misma interfaz que el resto de colecciones.</p>
<p>Por otro lado los streams siguen siendo 칰tiles para su funcionalidad primera, entregarnos un contenido que vamos recibiendo por partes, es decir; en lugar de cargar un achivo de 1Gb en memoria, un stream nos lo va entregando en bloques m치s peque침os as칤 podemos trabajarlos y liberar memoria. Adem치s en casos como medidores de progresos encajan perfectamente, siendo cada actualizaci칩n del progreso un elemento del stream.</p>
<h3>Y todo junto</h3>
<blockquote>
<p>Nota: el c칩digo a continuaci칩n es adaptado de otros lenguajes y no existe en Javascript</p>
</blockquote>
<p>Incluso hay implementaciones muy completas que integran perfectamente los stream y los promises, podemos hacer de forma sencilla cosas como capturar el primer click en la pagina</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// window.onClick instanceof Stream</span>
<span class="hljs-keyword">var</span> firstClick = <span class="hljs-variable language_">window</span>.<span class="hljs-property">onClick</span>.<span class="hljs-property">first</span>;
firstClick.<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) { ... });
</code></pre>
<p>Comprobar si las primeras diez teclas han sido "flecha derecha"</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">var</span> firstTenKeys = input.<span class="hljs-property">onKeyDown</span>.<span class="hljs-title function_">take</span>(<span class="hljs-number">10</span>);
<span class="hljs-keyword">var</span> keyRightTenTimes = firstTenKeys.<span class="hljs-title function_">every</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) {
  <span class="hljs-keyword">return</span> event.<span class="hljs-property">keyCode</span> === <span class="hljs-number">39</span>;
});
keyRightTenTimes.<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) {
  <span class="hljs-keyword">if</span> (value) <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'You like left arrow! :D'</span>);
});
</code></pre>
<p>Capturar solo el tercer click en la p치gina</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">var</span> thirdClick = input.<span class="hljs-property">onKeyDown</span>.<span class="hljs-title function_">elementAt</span>(<span class="hljs-number">3</span>);
thirdClick.<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'You clicked three times :)'</span>);
});
</code></pre>
<p>Obtener todo el contenido del archivo desde el stream, no hace falta un m칠todo especial</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">var</span> stream = file.<span class="hljs-title function_">getReadStream</span>()
<span class="hljs-keyword">var</span> fileContent = stream.<span class="hljs-title function_">join</span>(<span class="hljs-string">''</span>);
fileContent.<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">content</span>) { ... });
</code></pre>
<p>O detectar el primer evento <code>readystatechange</code> en que el <code>readyState</code> sea <code>4</code>, convertirlo en promise y devolver la respuesta</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">return</span> xhr.<span class="hljs-property">onReadyStateChange</span>
  .<span class="hljs-title function_">filter</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) {
    <span class="hljs-keyword">return</span> xhr.<span class="hljs-property">readyState</span> === <span class="hljs-number">4</span>;
  })
  .<span class="hljs-property">first</span>.<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> xhr.<span class="hljs-property">responseText</span>;
  });
</code></pre>
<p>Unificar varias operaciones</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// readFile returns promise</span>
<span class="hljs-keyword">var</span> concat = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stream</span>([<span class="hljs-title function_">readFile</span>(<span class="hljs-string">'./header.html'</span>), <span class="hljs-title function_">readFile</span>(<span class="hljs-string">'./content.html'</span>), <span class="hljs-title function_">readFile</span>(<span class="hljs-string">'./footer.html'</span>)]);
stream.<span class="hljs-title function_">listen</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">chunk</span>) {
  response.<span class="hljs-title function_">write</span>(chunk);
});
</code></pre>
<p>Incluso cosas m치s complejas como detectar la primera acci칩n del usuario en la p치gina</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// Promise.race devuelve un promise que se completar치</span>
<span class="hljs-comment">// cuando el primer promise de la lista se complete</span>
<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>([<span class="hljs-variable language_">window</span>.<span class="hljs-property">onClick</span>.<span class="hljs-property">first</span>, <span class="hljs-variable language_">window</span>.<span class="hljs-property">onKeyDown</span>.<span class="hljs-property">first</span>, <span class="hljs-variable language_">window</span>.<span class="hljs-property">onMouseMove</span>.<span class="hljs-property">first</span>]).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'El usuario ha disparado el evento '</span> + event.<span class="hljs-property">type</span>);
});
</code></pre>
<p>Y hasta capturar el evento <code>load</code> de window aunque ya haya pasado:</p>
<pre><code class="hljs language-js"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">window</span>.<span class="hljs-property">onLoad</span>.<span class="hljs-title function_">first</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-comment">// Me van a invocar aunque el evento</span>
    <span class="hljs-comment">// ya haya pasado :)</span>
  });
}, <span class="hljs-number">1000</span> * <span class="hljs-number">60</span> * <span class="hljs-number">60</span>); <span class="hljs-comment">// una hora</span>
</code></pre>
<h3>Resumen</h3>
<p>La gesti칩n de la asincron칤a, que siempre ha sido un caos, se simplifica de forma radical gracias a una buena combinaci칩n de Stream/Promises. Espero poder actualizar la entrada de los promises con los nuevos promises est치ndard de ECMAScript 6 :)</p>
<p>Conocen m치s patrones de gesti칩n de asincron칤a?</p></article></div><footer class="amq-footer"><span>Created by A. Mat칤as Quezada</span><!-- <span>Copyright 2023</span> --></footer></main></body></html>