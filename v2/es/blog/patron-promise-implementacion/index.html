<!DOCTYPE html><html lang="es" class="astro-wb7wxecl"><head><meta charset="utf-8"><!-- <link rel="icon" type="image/svg+xml" href="/favicon.svg" /> --><meta name="viewport" content="width=device-width"><title>A. Matías Quezada</title><style>pre code.hljs{display:block;overflow-x:auto;padding:1em}code.hljs{padding:3px 5px}/*!
  Theme: GitHub Dark
  Description: Dark theme as seen on github.com
  Author: github.com
  Maintainer: @Hirse
  Updated: 2021-05-15

  Outdated base version: https://github.com/primer/github-syntax-dark
  Current colors taken from GitHub's CSS
*/.hljs{color:#c9d1d9;background:#0d1117}.hljs-doctag,.hljs-keyword,.hljs-meta .hljs-keyword,.hljs-template-tag,.hljs-template-variable,.hljs-type,.hljs-variable.language_{color:#ff7b72}.hljs-title,.hljs-title.class_,.hljs-title.class_.inherited__,.hljs-title.function_{color:#d2a8ff}.hljs-attr,.hljs-attribute,.hljs-literal,.hljs-meta,.hljs-number,.hljs-operator,.hljs-variable,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-id{color:#79c0ff}.hljs-regexp,.hljs-string,.hljs-meta .hljs-string{color:#a5d6ff}.hljs-built_in,.hljs-symbol{color:#ffa657}.hljs-comment,.hljs-code,.hljs-formula{color:#8b949e}.hljs-name,.hljs-quote,.hljs-selector-tag,.hljs-selector-pseudo{color:#7ee787}.hljs-subst{color:#c9d1d9}.hljs-section{color:#1f6feb;font-weight:700}.hljs-bullet{color:#f2cc60}.hljs-emphasis{color:#c9d1d9;font-style:italic}.hljs-strong{color:#c9d1d9;font-weight:700}.hljs-addition{color:#aff5b4;background-color:#033a16}.hljs-deletion{color:#ffdcd7;background-color:#67060c}pre code.hljs{--_code-margin: var(--code-margin, 1.5em);white-space:pre;background-color:#000;margin:var(--_code-margin) calc(var(--_code-margin) * -1);padding:var(--_code-margin);border-radius:8px}pre code.hljs>.hljs-comment{color:#999}code:not(.hljs){padding:0 .3em .1em;border-radius:5px;background-color:#0000004d}.md li{list-style:initial}.md ul,.md ol{margin:20px 0;padding:reset}.md p{text-align:justify}.md blockquote{border-left:2px solid var(--color-text);margin-left:0;padding-left:1em}.md :is(h1,h2,h3,h4,h5,h6){margin-top:.7em;margin-bottom:.3em}
.tag-list{display:flex;gap:.5em;flex-wrap:wrap;list-style:none;margin:0;padding:0}
</style>
<link rel="stylesheet" href="/_astro/_slug_.d64b408e.css" /><script type="module">CSS.paintWorklet?.addModule("/dot-mesh.js");
</script></head><body class="astro-wb7wxecl"><script defer>
  function closeHamburger() {
    document.querySelector('hamburger-button')?.removeAttribute('active');
  }
</script><script type="module" defer>export const tagName = 'hamburger-button';

export const template = `
  <div class="bar"></div>
  <div class="bar"></div>
  <div class="bar"></div>

  <style>
    :host {
      cursor: pointer;
  
      --_color: var(--color, black);
      --_width: var(--width, 2em);
      --_thickness: var(--thickness, 3px);
      --_spacing: var(--spacing, 7px);
      --_opacity: var(--opacity, 0.5);
  
      --translation-x: calc(var(--_thickness) + var(--_spacing));
    }
  
    .bar {
      width: var(--_width);
      height: var(--_thickness);
      background-color: var(--_color);
      margin: var(--_spacing) 0;
      opacity: var(--_opacity);
  
      will-change: transform, opacity;
      transition: 0.4s;
      transition-property: transform, opacity;
    }
  
    :host(:hover) .bar {
      opacity: 1;
    }
  
    :host([active]) .bar:first-of-type {
      transform: translate(0, var(--translation-x)) rotate(45deg);
    }
  
    :host([active]) .bar:nth-child(2) {
      opacity: 0;
    }
  
    :host([active]) .bar:last-of-type {
      transform: translate(0, calc(var(--translation-x) * -1)) rotate(-45deg);
    }
  </style>
`;

export class HamburgerButton extends HTMLElement {
  #shadowRoot;

  constructor() {
    super();

    this.#shadowRoot = this.attachShadow({ mode: 'open' });
    this.#shadowRoot.innerHTML = template;
  
    this.bars = this.shadowRoot.querySelectorAll(".bar");
    this.toggle = this.toggle.bind(this);
  }

  connectedCallback() {
    this.addEventListener("click", this.toggle);
  }
  disconnectedCallback() {
    this.addEventListener("click", this.toggle);
  }

  toggle() {
    this.toggleAttribute("active");

    const event = new CustomEvent('toggle', {
      detail: {
        active: this.hasAttribute("active")
      }
    });

    this.dispatchEvent(event);
  }
}

customElements.define('hamburger-button', HamburgerButton);</script><hamburger-button><template shadowrootmode="open"><!-- don't fold me  -->
  <div class="bar"></div>
  <div class="bar"></div>
  <div class="bar"></div>

  <style>
    :host {
      cursor: pointer;
  
      --_color: var(--color, black);
      --_width: var(--width, 2em);
      --_thickness: var(--thickness, 3px);
      --_spacing: var(--spacing, 7px);
      --_opacity: var(--opacity, 0.5);
  
      --translation-x: calc(var(--_thickness) + var(--_spacing));
    }
  
    .bar {
      width: var(--_width);
      height: var(--_thickness);
      background-color: var(--_color);
      margin: var(--_spacing) 0;
      opacity: var(--_opacity);
  
      will-change: transform, opacity;
      transition: 0.4s;
      transition-property: transform, opacity;
    }
  
    :host(:hover) .bar {
      opacity: 1;
    }
  
    :host([active]) .bar:first-of-type {
      transform: translate(0, var(--translation-x)) rotate(45deg);
    }
  
    :host([active]) .bar:nth-child(2) {
      opacity: 0;
    }
  
    :host([active]) .bar:last-of-type {
      transform: translate(0, calc(var(--translation-x) * -1)) rotate(-45deg);
    }
  </style>
</template></hamburger-button><nav class="amq-header"><div class="container"><div class="internal-links"><a class="nav-link" href="#projects" onclick="closeHamburger();">Proyectos</a><a class="nav-link" href="#experiments" onclick="closeHamburger();">Experimentos</a><a class="nav-link" href="#blog" onclick="closeHamburger();"> Blog</a><a class="nav-link" href="#talks" onclick="closeHamburger();">Charlas</a><a class="nav-link" href="#career" onclick="closeHamburger();">Experiencia</a></div><div class="external-links"><a target="_blank" href="https://github.com/amatiasq"><svg aria-label="Github icon" width="32" height="32" viewBox="0 0 98 96" xmlns="http://www.w3.org/2000/svg">
    <path fill-rule="evenodd" clip-rule="evenodd"
        d="M48.854 0C21.839 0 0 22 0 49.217c0 21.756 13.993 40.172 33.405 46.69 2.427.49 3.316-1.059 3.316-2.362 0-1.141-.08-5.052-.08-9.127-13.59 2.934-16.42-5.867-16.42-5.867-2.184-5.704-5.42-7.17-5.42-7.17-4.448-3.015.324-3.015.324-3.015 4.934.326 7.523 5.052 7.523 5.052 4.367 7.496 11.404 5.378 14.235 4.074.404-3.178 1.699-5.378 3.074-6.6-10.839-1.141-22.243-5.378-22.243-24.283 0-5.378 1.94-9.778 5.014-13.2-.485-1.222-2.184-6.275.486-13.038 0 0 4.125-1.304 13.426 5.052a46.97 46.97 0 0 1 12.214-1.63c4.125 0 8.33.571 12.213 1.63 9.302-6.356 13.427-5.052 13.427-5.052 2.67 6.763.97 11.816.485 13.038 3.155 3.422 5.015 7.822 5.015 13.2 0 18.905-11.404 23.06-22.324 24.283 1.78 1.548 3.316 4.481 3.316 9.126 0 6.6-.08 11.897-.08 13.526 0 1.304.89 2.853 3.316 2.364 19.412-6.52 33.405-24.935 33.405-46.691C97.707 22 75.788 0 48.854 0z"
        fill="#fff">
    </path>
</svg></a><a target="_blank" href="https://www.linkedin.com/in/amatiasq/"><?xml version="1.0" encoding="utf-8"?>
<!-- Uploaded to: SVG Repo, www.svgrepo.com, Generator: SVG Repo Mixer Tools -->
<svg aria-label="LinkedIn Icon" width="32" height="32" viewBox="4 4 16 16" xmlns="http://www.w3.org/2000/svg">
    <path
        d="M18.72 3.99997H5.37C5.19793 3.99191 5.02595 4.01786 4.86392 4.07635C4.70189 4.13484 4.55299 4.22471 4.42573 4.34081C4.29848 4.45692 4.19537 4.59699 4.12232 4.75299C4.04927 4.909 4.0077 5.07788 4 5.24997V18.63C4.01008 18.9901 4.15766 19.3328 4.41243 19.5875C4.6672 19.8423 5.00984 19.9899 5.37 20H18.72C19.0701 19.9844 19.4002 19.8322 19.6395 19.5761C19.8788 19.32 20.0082 18.9804 20 18.63V5.24997C20.0029 5.08247 19.9715 4.91616 19.9078 4.76122C19.8441 4.60629 19.7494 4.466 19.6295 4.34895C19.5097 4.23191 19.3672 4.14059 19.2108 4.08058C19.0544 4.02057 18.8874 3.99314 18.72 3.99997ZM9 17.34H6.67V10.21H9V17.34ZM7.89 9.12997C7.72741 9.13564 7.5654 9.10762 7.41416 9.04768C7.26291 8.98774 7.12569 8.89717 7.01113 8.78166C6.89656 8.66615 6.80711 8.5282 6.74841 8.37647C6.6897 8.22474 6.66301 8.06251 6.67 7.89997C6.66281 7.73567 6.69004 7.57169 6.74995 7.41854C6.80986 7.26538 6.90112 7.12644 7.01787 7.01063C7.13463 6.89481 7.2743 6.80468 7.42793 6.74602C7.58157 6.68735 7.74577 6.66145 7.91 6.66997C8.07259 6.66431 8.2346 6.69232 8.38584 6.75226C8.53709 6.8122 8.67431 6.90277 8.78887 7.01828C8.90344 7.13379 8.99289 7.27174 9.05159 7.42347C9.1103 7.5752 9.13699 7.73743 9.13 7.89997C9.13719 8.06427 9.10996 8.22825 9.05005 8.3814C8.99014 8.53456 8.89888 8.6735 8.78213 8.78931C8.66537 8.90513 8.5257 8.99526 8.37207 9.05392C8.21843 9.11259 8.05423 9.13849 7.89 9.12997ZM17.34 17.34H15V13.44C15 12.51 14.67 11.87 13.84 11.87C13.5822 11.8722 13.3313 11.9541 13.1219 12.1045C12.9124 12.2549 12.7546 12.4664 12.67 12.71C12.605 12.8926 12.5778 13.0865 12.59 13.28V17.34H10.29V10.21H12.59V11.21C12.7945 10.8343 13.0988 10.5225 13.4694 10.3089C13.84 10.0954 14.2624 9.98848 14.69 9.99997C16.2 9.99997 17.34 11 17.34 13.13V17.34Z" />
</svg></a></div></div></nav><div class="container"><h1>Patrón Promise: Implementación</h1><ul class="tag-list md-tags"></ul><article class="md"><p>Lo prometido es deuda (bien lo saben las funciones) y he encontrado un momento para empezar a explicar la forma en la que he implementado el patrón Promise en mi caso, no tiene porqué ser la mejor, pero cumple con su cometido.</p>
<p><strong>NOTA:</strong> Me gustaría implementarla en Test Driven Development, pero ya es bastante para quien lee y para el que escribe seguir la implementación como para encima añadir TDD, pero no quisiera dejar de recomendarlo.</p>
<h3>Primero: Funcionalidad básica</h3>
<p>Lo que necesitamos de un objeto Promise es:</p>
<ul>
<li>Crear instancias totalmente independientes</li>
<li>Añadirle callbacks que serán llamados cuando se cumpla la promesa</li>
<li>Notificarle cuando se ha cumplido la promesa</li>
</ul>
<p>Con los objetivos en la mano es más sencillo ver que hacer, lo primero necesitamos una clase, a la hora de crear clases en Javascript yo me decanto por el patrón de constructor con prototipos que espero explicar algún día.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Promise</span>(<span class="hljs-params"></span>) {}
</code></pre>
<p><strong>Segundo punto:</strong> poder añadirle callbacks, ésto consiste en el método <code>.then()</code> al que deberemos poder llamar pasándole las funciones que queremos que se ejecuten cuando la promesa se cumpla. Puesto de debe poderse añadir más de un callback para cada promise lo más lógico sería crear un Array donde almacenarlos</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Promise</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">_callbacks</span> = [];
}
</code></pre>
<p>Y el método <code>.then()</code> que vaya añadiendo al Array los callbacks que se le pasen, puesto que es mejor que los errores se detecten cuanto antes también podemos asegurarnos que el callback es una función:</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">then</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">callback</span>) {
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> callback !== <span class="hljs-string">'function'</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">"[Promise.then] El argumento 'callback' no es una función "</span> + <span class="hljs-keyword">typeof</span> callback);
  }

  <span class="hljs-variable language_">this</span>.<span class="hljs-property">_callbacks</span>.<span class="hljs-title function_">push</span>(callback);
};
</code></pre>
<p>Y ahora que ya tenemos todos los callbacks en un Array necesitamos algún sistema para avisarle al Promise que ya tiene los datos que necesita y que se los pase a los callbacks. Sobre ésto no he visto ninguna implementación, pero a mi me parece bastante razonable crear un método <code>Promise.done()</code> que notifica al Promise que ya está cumplido y ejecuta los callbacks.</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">done</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
  <span class="hljs-keyword">var</span> callback;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &#x3C; <span class="hljs-variable language_">this</span>.<span class="hljs-property">_callbacks</span>.<span class="hljs-property">length</span>; i++) {
    callback = <span class="hljs-variable language_">this</span>.<span class="hljs-property">_callbacks</span>[i];
    <span class="hljs-title function_">callback</span>();
  }
};
</code></pre>
<p>Y ya lo tenemos hecho, hemos creado un Promise básico, vamos a probarlo. Imaginemos cualquier función asíncrona, por ejemplo vamos a crear una función que nos avise cuando pase un segundo:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">esperarUnSegundo</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">var</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>();
  <span class="hljs-comment">// Hacemos un timeout a mil milisegundos</span>
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    promise.<span class="hljs-title function_">done</span>();
  }, <span class="hljs-number">1000</span>);
  <span class="hljs-keyword">return</span> promise;
}

<span class="hljs-title function_">esperarUnSegundo</span>().<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
  <span class="hljs-title function_">alert</span>(<span class="hljs-string">'Ha pasado un segundo =D'</span>);
});
</code></pre>
<p>Pruébame</p>
<p>Si probamos todo el código veremos que al cabo de un segundo ejecuta el alert.</p>
<p>Todo funciona perfectamente, vamos un punto más allá, ésta vez descarguemos una página, como no nos importa ahora mismo el código que descarga la página fingiremos llamar a una función <code>peticiónHttp(url, callback)</code> que lo hará por nosotros.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">descargar</span>(<span class="hljs-params">url</span>) {
  <span class="hljs-keyword">var</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>();
  petició<span class="hljs-title function_">nHttp</span>(url, <span class="hljs-keyword">function</span> (<span class="hljs-params">codigoHtml</span>) {
    promise.<span class="hljs-title function_">done</span>();
  });
  <span class="hljs-keyword">return</span> promise;
}
<span class="hljs-title function_">descargar</span>(<span class="hljs-string">'www.google.com'</span>).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
  <span class="hljs-comment">// Y ahora?</span>
});
</code></pre>
<p>Sorpresa! La función ha descargado la página y obtenido el html, pero nuestro Promise no ha sido capaz de pasarlo al callback. La función del Promise en un principio era avisar cuando una tarea asíncrona termina, pero la mayoría de las tareas asíncronas devuelven un resultado y cuando avisemos al Promise que se ha cumplido también querremos que pase el resultado a todos los callbacks. Para ello modificaremos el método done y para que pase a los callbacks todos los argumentos que se le pasen a él (si no sabes lo que hace el método apply puedes mirarlo <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/apply" title="appy method">aquí</a>):</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">done</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
  <span class="hljs-comment">// Guardamos los argumentos que se le ha pasado a .done()</span>
  <span class="hljs-keyword">var</span> args = <span class="hljs-variable language_">arguments</span>;
  <span class="hljs-keyword">var</span> callback;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &#x3C; <span class="hljs-variable language_">this</span>.<span class="hljs-property">_callbacks</span>.<span class="hljs-property">length</span>; i++) {
    callback = <span class="hljs-variable language_">this</span>.<span class="hljs-property">_callbacks</span>[i];
    <span class="hljs-comment">// Y se los pasamos al callback</span>
    callback.<span class="hljs-title function_">apply</span>(<span class="hljs-literal">null</span>, args);
  }
};
</code></pre>
<p>Y ya está, ahora podemos pasarle argumentos a <code>.done()</code>:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">descargar</span>(<span class="hljs-params">url</span>) {
  <span class="hljs-keyword">var</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>();
  petició<span class="hljs-title function_">nHttp</span>(url, <span class="hljs-keyword">function</span> (<span class="hljs-params">codigoHtml</span>) {
    promise.<span class="hljs-title function_">done</span>(codigoHtml);
  });
  <span class="hljs-keyword">return</span> promise;
}

<span class="hljs-title function_">descargar</span>(<span class="hljs-string">'www.google.com'</span>).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">codigoHtml</span>) {
  <span class="hljs-title function_">alert</span>(codigoHtml);
});
</code></pre>
<p>Ya tenemos nuestra versión 0.1 de la clase Promise :D</p>
<h3>Segundo: Gestión de errores</h3>
<p>Hasta aquí ya tenemos un Promise con el que avisar cuando acaba una tarea asíncrona, pero nos olvidamos de algo muy importante, a la hora de programar no todo sale como quisiéramos y muchas veces nos encontramos con errores, que pasaría si <code>peticiónHttp()</code> fallara? Que jamás se ejecutaría el <code>.done()</code> del Promise que hemos devuelto y el callback esperará sentado a que lo llamen el resto de su vida. Hay que preparar el Promise para que avise cuando algo va mal. Necesitamos añadirle al Promise:</p>
<ul>
<li>Poder añadir callbacks especiales para cuando se produzca un error</li>
<li>Avisarle cuando se produzca un error</li>
<li>Que le pase al callback de error el objeto Error que se ha lanzado</li>
</ul>
<p>Lo primero es que el Promise no solo reciba un callback normal sino que también reciba otro callback que será ejecutado solo si se produce un error. Una idea que me gusta es dárselo al método <code>.then()</code> como segundo argumento, ya que el primero es el callback normal. Y éste debería guardarlo, para ello debemos crear otro Array donde guardar los callbacks de errores:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Promise</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">_callbacks</span> = [];
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">_onError</span> = [];
}
<span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">then</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">callback, onError</span>) {
  <span class="hljs-comment">// Validamos el callback normal</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> callback !== <span class="hljs-string">'function'</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">"[Promise.then] El argumento 'callback' no es una función "</span> + <span class="hljs-keyword">typeof</span> callback);
  }
  <span class="hljs-comment">// Validamos el callback de error. Como es opcional puede ser 'undefined' o una función</span>
  <span class="hljs-keyword">if</span> (onError &#x26;&#x26; <span class="hljs-keyword">typeof</span> onError !== <span class="hljs-string">'function'</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">"[Promise.then] El argumento 'onError' no es una función "</span> + <span class="hljs-keyword">typeof</span> onError);
  }

  <span class="hljs-variable language_">this</span>.<span class="hljs-property">_callbacks</span>.<span class="hljs-title function_">push</span>(callback);
  <span class="hljs-comment">// Si no era undefined debe ser una función, porque ya lo validamos</span>
  <span class="hljs-keyword">if</span> (onError) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_onError</span>.<span class="hljs-title function_">push</span>(onError);
  }
};
</code></pre>
<p>Como se ve es prácticamente lo mismo que para los callbacks, ya que se trata de lo mismo, un callback por si hay errores. Ahora vamos a matar los últimos dos puntos de un tiro. Añadiremos un método para avisar al Promise cuando se produzca un error y le pasaremos el objeto Error para que lo pase a todos los callbacks de error.</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">fail</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) {
  <span class="hljs-keyword">var</span> callback;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &#x3C; <span class="hljs-variable language_">this</span>.<span class="hljs-property">_onError</span>.<span class="hljs-property">length</span>; i++) {
    callback = <span class="hljs-variable language_">this</span>.<span class="hljs-property">_onError</span>[i];
    <span class="hljs-title function_">callback</span>(error);
  }
};
</code></pre>
<p>Y ya está, ahora cuando llamemos al método <code>.fail()</code> llamará a todos los callbacks de error y les pasará el objeto Error. Ahora podemos adaptar la función <code>descargar()</code> para que también notifique cuando se produzca un error:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">descargar</span>(<span class="hljs-params">url</span>) {
  <span class="hljs-keyword">var</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>();
  <span class="hljs-keyword">try</span> {
    petició<span class="hljs-title function_">nHttp</span>(url, <span class="hljs-keyword">function</span> (<span class="hljs-params">codigoHtml</span>) {
      promise.<span class="hljs-title function_">done</span>(codigoHtml);
    });
  } <span class="hljs-keyword">catch</span> (error) {
    promise.<span class="hljs-title function_">fail</span>(error);
  }
  <span class="hljs-keyword">return</span> promise;
}
<span class="hljs-title function_">descargar</span>(<span class="hljs-string">'www.google.com'</span>).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">codigoHtml</span>) {
  <span class="hljs-title function_">alert</span>(codigoHtml);
});
</code></pre>
<p>Ahora ya podemos decir que tenemos la versión 0.2 del Promise tengo que dejar para otro post métodos más complicados como <code>.then()</code> concatenados y el <code>.and()</code> porque ya es muy tarde. Aquí dejo el código completo al que le he añadido la propiedad <code>_estado</code> para evitar que se pueda cumplir o fallar un Promise cuando ya está cumplido o fallado.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Promise</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">_callbacks</span> = [];
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">_onError</span> = [];
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">_estado</span> = <span class="hljs-string">'esperando'</span>;
}

<span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">then</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">callback, onError</span>) {
  <span class="hljs-comment">// Validamos el callback normal</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> callback !== <span class="hljs-string">'function'</span>)
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">"[Promise.then] El argumento 'callback' no es una función "</span> + <span class="hljs-keyword">typeof</span> callback);

  <span class="hljs-comment">// Validamos el callback de error. Como es opcional puede ser 'undefined' o una función</span>
  <span class="hljs-keyword">if</span> (onError &#x26;&#x26; <span class="hljs-keyword">typeof</span> onError !== <span class="hljs-string">'function'</span>)
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">"[Promise.then] El argumento 'onError' no es una función "</span> + <span class="hljs-keyword">typeof</span> onError);

  <span class="hljs-variable language_">this</span>.<span class="hljs-property">_callbacks</span>.<span class="hljs-title function_">push</span>(callback);
  <span class="hljs-comment">// Si no era undefined debe ser una función, porque ya lo validamos</span>
  <span class="hljs-keyword">if</span> (onError) <span class="hljs-variable language_">this</span>.<span class="hljs-property">_onError</span>.<span class="hljs-title function_">push</span>(onError);
};

<span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">done</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) {
  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">_estado</span> !== <span class="hljs-string">'esperando'</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'Intentando cumplir un promise que ya ha finalizado'</span>);

  <span class="hljs-variable language_">this</span>.<span class="hljs-property">_estado</span> = <span class="hljs-string">'cumplido'</span>;
  <span class="hljs-comment">// Guardamos los argumentos que se le ha pasado a .done()</span>
  <span class="hljs-keyword">var</span> args = <span class="hljs-variable language_">arguments</span>;
  <span class="hljs-keyword">var</span> callback;

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &#x3C; <span class="hljs-variable language_">this</span>.<span class="hljs-property">_callbacks</span>.<span class="hljs-property">length</span>; i++) {
    callback = <span class="hljs-variable language_">this</span>.<span class="hljs-property">_callbacks</span>[i];
    <span class="hljs-comment">// Y se los pasamos al callback</span>
    callback.<span class="hljs-title function_">apply</span>(<span class="hljs-literal">null</span>, args);
  }
};

<span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">fail</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) {
  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">_estado</span> !== <span class="hljs-string">'esperando'</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'Intentando hacer fallar un promise que ya ha finalizado'</span>);

  <span class="hljs-variable language_">this</span>.<span class="hljs-property">_estado</span> = <span class="hljs-string">'fallado'</span>;
  <span class="hljs-keyword">var</span> callback;

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &#x3C; <span class="hljs-variable language_">this</span>.<span class="hljs-property">_onError</span>.<span class="hljs-property">length</span>; i++) {
    callback = <span class="hljs-variable language_">this</span>.<span class="hljs-property">_onError</span>[i];
    <span class="hljs-title function_">callback</span>(error);
  }
};
</code></pre></article></div></body></html>