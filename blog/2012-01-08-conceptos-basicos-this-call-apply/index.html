<!DOCTYPE html><html lang="en"><head><meta charSet="UTF-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Conceptos B√°sicos Javascript: this, .call() y .apply() | A. Mat√≠as Quezada</title><style>
  *, *::before, *::after {
    box-sizing: border-box;
  }

  ul, ol {
    padding: 0;
  }

  body, h1, h2, h3, h4, p, ul, ol, li, figure, figcaption, blockquote, dl, dd {
    margin: 0;
  }

  body {
    min-height: 100vh;
    scroll-behavior: smooth;
    text-rendering: optimizeSpeed;
    line-height: 1.5;
  }

  ul, ol {
    list-style: none;
  }
  .md ul, .md ol {
    list-style: initial;
    padding: revert;
  }

  a:not([class]) {
    text-decoration-skip-ink: auto;
  }

  img {
    max-width: 100%;
    display: block;
  }

  article &gt; * + * {
    margin-top: 1em;
  }

  input, button, textarea, select {
    font: inherit;
  }

  @media (prefers-reduced-motion: reduce) {
    * {
      animation-duration: 0.01ms !important;
      animation-iteration-count: 1 !important;
      transition-duration: 0.01ms !important;
      scroll-behavior: auto !important;
    }
  }

  @import url(&#x27;https://fonts.googleapis.com/css2?family=Fira+Code:wght@400;700&amp;family=Lato:ital,wght@1,400;1,700&amp;family=Montserrat:wght@400;700&amp;display=swap&#x27;);

  :root {
    background-color: #263238;
    color: #FDFBF8;
    font-family: Lato, sans-serif;
    font-size: 18px;
  }

  header, h1, h2, h3, h4, h5, h6 {
    font-family: Montserrat, sans-serif;
  }

  a {
    color: #EFE751;
  }

  .md p {
    margin: 20px 0;
    text-align: justify;
  }

  code {
    font-family: Fira Code, monospace;
  }

  .md .code-block {
    display: block;
    font-family: Fira Code, monospace;
    width: var(--available-width);
    padding-bottom: 10px;
  }

  svg {
    fill: #FDFBF8;
  }
</style><style>
    [class*=shj-lang-]{white-space:pre;margin:10px 0;border-radius:10px;padding:30px 20px;background:white;color:#112;box-shadow:0 0 5px #0001;text-shadow:none;font: 18px Consolas,Courier New,Monaco,Andale Mono,Ubuntu Mono,monospace;line-height:24px;box-sizing:border-box;max-width:min(100%,100vw)}
    .shj-inline{margin:0;padding:2px 5px;display:inline-block;border-radius:5px}
    [class*=shj-lang-]::selection,
    [class*=shj-lang-] ::selection{background:#bdf5}
    [class*=shj-lang-]>div{display:flex;overflow:auto}
    [class*=shj-lang-]>div :last-child{flex:1;outline:none}
    .shj-numbers{padding-left:5px;counter-reset:line}
    .shj-numbers div{padding-right:5px}
    .shj-numbers div:before{color:#999;display:block;content:counter(line);opacity:.5;text-align:right;margin-right:5px;counter-increment:line}
    .shj-syn-cmnt{font-style:italic}
    .shj-syn-err,
    .shj-syn-kwd{color:#e16}
    .shj-syn-num,
    .shj-syn-class{color:#f60}
    .shj-numbers,
    .shj-syn-cmnt{color:#999}
    .shj-syn-insert,
    .shj-syn-str{color:#7d8}
    .shj-syn-bool{color:#3bf}
    .shj-syn-type,
    .shj-syn-oper{color:#5af}
    .shj-syn-section,
    .shj-syn-func{color:#84f}
    .shj-syn-deleted,
    .shj-syn-var{color:#f44}
    .shj-oneline{padding:12px 10px}
    .shj-lang-http.shj-oneline .shj-syn-kwd{background:#25f;color:#fff;padding:5px 7px;border-radius:5px}
    .shj-multiline.shj-mode-header{padding:20px}
    .shj-multiline.shj-mode-header:before{content:attr(data-lang);color:#58f;display:block;padding:10px 20px;background:#58f3;border-radius:5px;margin-bottom:20px}
    [class*=shj-lang-]{color:#abb2bf;background:#161b22}
    [class*=shj-lang-]:before{color:#6f9aff}
    .shj-syn-deleted,
    .shj-syn-err,
    .shj-syn-var{color:#e06c75}
    .shj-syn-section,
    .shj-syn-oper,
    .shj-syn-kwd{color:#c678dd}
    .shj-syn-class{color:#e5c07b}
    .shj-numbers,
    .shj-syn-cmnt{color:#76839a}
    .shj-syn-insert{color:#98c379}
    .shj-syn-type{color:#56b6c2}
    .shj-syn-num,
    .shj-syn-bool{color:#d19a66}
    .shj-syn-str,
    .shj-syn-func{color:#61afef}
    </style><style>.css-zi0qjt{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:justify;-webkit-justify-content:space-between;justify-content:space-between;}
.css-1p4f3y5{display:grid;padding-top:20px;gap:12px;}
.css-2nd93p{padding:20px 0;margin-bottom:20px;background-color:#1B2225;color:#FDFBF8;border-bottom:2px solid #586369;}@media (min-width: 769px){.css-2nd93p{position:-webkit-sticky;position:sticky;top:0;z-index:1;}}
.css-17rdaxl{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:justify;-webkit-justify-content:space-between;justify-content:space-between;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;}@media (min-width: 769px){.css-17rdaxl{-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;}}
.css-slvbys{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;gap:12px;}.css-slvbys a{color:#EFE751;-webkit-text-decoration:none;text-decoration:none;margin-left:12px;border-bottom:1px solid transparent;}.css-slvbys a.parent{border-bottom:1px solid #586369;}.css-slvbys a:hover{border-bottom:1px solid #EFE751;}
.css-1avicn7{font-size:24px;-webkit-text-decoration:none;text-decoration:none;color:#FDFBF8;}
.css-4hnq5z{--container-side-gap:1rem;--container-width:40rem;--container-sides-gap:calc(var(--container-side-gap) * 2);--available-width:min(
      calc(100vw - var(--container-sides-gap)),
      calc(var(--container-width) - var(--container-sides-gap))
    );max-width:var(--container-width);padding-left:var(--container-side-gap);padding-right:var(--container-side-gap);margin-left:auto;margin-right:auto;}@media (min-width: 769px){.css-4hnq5z{--container-width:50rem;--container-side-gap:5rem;}}@media (min-width: 1200px){.css-4hnq5z{--container-width:60rem;}}
.css-187qu0u{font-family:Montserrat,sans-serif;font-weight:700;font-size:32px;}
.css-a9renj{opacity:0.8;font-family:Fira Code,monospace;color:#FDFBF8;}</style></head><body class=""><header class="css-2nd93p "><div class="css-17rdaxl css-4hnq5z"><h2><a href="../.." class="css-1avicn7">A. Mat√≠as Quezada</a></h2><nav class="css-slvbys"><a href=".." class="">Blog</a><a href="../../career" class="">Career</a><a href="../../projects" class="">Projects</a><a href="../../es/blog/2012-01-08-conceptos-basicos-this-call-apply" class="">üá™üá∏</a></nav></div></header><div class="css-1p4f3y5 css-4hnq5z"><div class="css-zi0qjt"><h2 class="undefined css-187qu0u">Conceptos B√°sicos Javascript: this, .call() y .apply()</h2><time class="css-a9renj " dateTime="01/08/2012">Jan 8, 2012</time></div><article><div class="md"><p>Antes de continuar con el Patr√≥n Promise me gustar√≠a explicar en paralelo Conceptos B√°sicos de Javascript. Entendiendo que estamos hablando de Javascript como lenguaje y no vamos a hablar sobre conceptos b√°sicos del DOM o como abrir una nueva ventana en el navegador, sino detalles de Javascript puro, tanto en cliente como en servidor.</p>
<h3 id="de-d-nde-sale-_this_">De d√≥nde sale <em>this</em></h3>
<p>He pensado que ser√≠a un buen punto empezar por una curiosidad bastante desconocida para los reci√©n llegados a Javascript: La variable <code>this</code>, tambi√©n llamado el <code>scope</code> o m√°s correctamente <code>contexto</code> de la funci√≥n. En los lenguajes basados en clases m√°s extendidos (Java, C++, C#...) encontramos que <strong>los m√©todos de la clase siempre disponen de la variable <code>this</code> que nos permite acceder a nuestra propia instancia</strong> sobre la que se est√° ejecutando el m√©todo. Es decir, si tenemos la clase...</p>
<!-- end extract -->

<code class="code-block shj-lang-js"><div><div class="shj-numbers"><div></div><div></div><div></div><div></div><div></div><div></div></div><div><span class="shj-syn-kwd">class</span> <span class="shj-syn-class">MyClass</span> {
  <span class="shj-syn-class">String</span> myField;
  <span class="shj-syn-kwd">void</span> <span class="shj-syn-func">myMethod</span>() {
    <span class="shj-syn-kwd">this</span><span class="shj-syn-oper">.</span>myField;
  }
}</div></div>
</code>
<p>Veremos que en myMethod siempre tendremos <code>this</code> apuntando a una variable del tipo <code>MyClass</code> que contendr√° un campo <code>myField</code>. En Javascript √©sto no es as√≠, <strong>en Javascript todo son objetos</strong>, incluidas las funciones y m√©todos, ambos <strong>son instancias de <code>Function</code></strong>, y como tales no est√°n ligadas a un objeto en particular. Miremos el c√≥digo:</p>

<code class="code-block shj-lang-js"><div><div class="shj-numbers"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div><div><span class="shj-syn-kwd">function</span> <span class="shj-syn-func">myFunction</span>() {
  console<span class="shj-syn-oper">.</span><span class="shj-syn-func">log</span>(<span class="shj-syn-kwd">this</span><span class="shj-syn-oper">.</span>name);
}

<span class="shj-syn-kwd">var</span> objectA <span class="shj-syn-oper">=</span> {
  name<span class="shj-syn-oper">:</span> <span class="shj-syn-str">'Alice'</span><span class="shj-syn-oper">,</span>
  myMethod<span class="shj-syn-oper">:</span> myFunction<span class="shj-syn-oper">,</span>
};

<span class="shj-syn-kwd">var</span> objectB <span class="shj-syn-oper">=</span> {
  name<span class="shj-syn-oper">:</span> <span class="shj-syn-str">'Bob'</span><span class="shj-syn-oper">,</span>
  myMethod<span class="shj-syn-oper">:</span> myFunction<span class="shj-syn-oper">,</span>
};</div></div>
</code>
<p>Aqu√≠ tenemos dos objetos totalmente independientes y ambos tienen la propiedad <code>myMethod</code> apuntado a <code>myFunction</code> a pesar de que no tienen una clase en com√∫n m√°s que <code>Object</code>. Entonces cu√°l es <strong>el valor de this</strong> en <code>myFunction</code>? No es fijo, <strong>cambia seg√∫n como lo llamemos</strong>.</p>

<code class="code-block shj-lang-js">LOADING...
</code>
<p><a href="http://jsfiddle.net/amatiasq/YUX5B/" target="_blank">Pru√©bame</a></p>
<!--more Seguir leyendo ‚Üí -->
<p>Como vemos el valor de <code>this</code> cambia seg√∫n sobre que objeto lo llamemos. Bien, Javascript sabe que valor tiene que poner a <code>this</code> antes de llamar a una funci√≥n, pero nosotros necesitamos entenderlo para no encontrarnos con bugs imposibles de corregir. Para √©sto hay una regla de oro: <strong>el objeto <code>this</code> pasado a una funci√≥n es el objeto que est√° antes del punto que precede los par√©ntesis que invocan a la funci√≥n</strong>. Es decir, la llamada <code>objectA.myMethod()</code> la podr√≠amos dividir en cuatro partes: <em> <strong>objectA</strong>: El objeto que contiene la funci√≥n </em> <strong>. (punto)</strong>: Separa el objeto de su propiedad (la funci√≥n) <em> <strong>myMethod</strong>: Nombre de la funci√≥n </em> <strong>() (par√©ntesis)</strong>: Ejecutan la funci√≥n En √©ste caso vemos que</p>
<p><strong>antes del punto est√° <code>objectA</code></strong> por lo que ser√° <code>objectA</code> lo <strong>que se le pasar√° a la variable <code>this</code></strong> del m√©todo <code>myMethod</code>.</p>
<h3 id="casos-m-s-complejos">Casos m√°s complejos</h3>
<h4 id="m-s-de-un-punto">M√°s de un punto</h4>
<p>Ahora vamos a ver casos en los que tenemos m√°s o menos de un punto, es menos dif√≠cil de lo que parece. Para empezar, que pasa si usamos namespaces:</p>

<code class="code-block shj-lang-js"><div><div class="shj-numbers"><div></div></div><div>amq<span class="shj-syn-oper">.</span>test<span class="shj-syn-oper">.</span><span class="shj-syn-class">StringHelper</span><span class="shj-syn-oper">.</span><span class="shj-syn-func">firstToUpperCase</span>(<span class="shj-syn-str">'myname'</span>);</div></div>
</code>
<p>Aqu√≠ cu√°l es el valor de <code>this</code>? Si miramos la regla de oro veremos que solo el punto que precede a los par√©ntesis debe importarnos, por lo que tenemos:</p>

<ul>
<li><strong>amq.test.StringHelper</strong>: El objeto que contiene la funci√≥n</li>
<li><strong>. (punto)</strong>: Separa el objeto de su propiedad (la funci√≥n)</li>
<li><strong>firstToUpperCase</strong>: Nombre de la funci√≥n</li>
<li><strong>() (par√©ntesis)</strong>: Ejecutan la funci√≥n El valor de</li>
</ul>
<p><strong><code>this</code> siempre es el objeto que est√° antes del √∫ltimo punto</strong>, es decir, el objeto <strong>que contiene la funci√≥n</strong>.</p>
<h4 id="sin-puntos">Sin puntos</h4>
<p>Pero que pasa si no hay ning√∫n punto? si la funci√≥n no est√° en ning√∫n objeto?</p>

<code class="code-block shj-lang-js"><div><div class="shj-numbers"><div></div><div></div><div></div><div></div></div><div><span class="shj-syn-kwd">function</span> <span class="shj-syn-func">testScope</span>() {
  console<span class="shj-syn-oper">.</span><span class="shj-syn-func">log</span>(<span class="shj-syn-kwd">this</span>);
}
<span class="shj-syn-func">testScope</span>();</div></div>
</code>
<p>Aqu√≠ podr√≠amos pensar que <code>this</code> es <code>null</code> y tendr√≠a sentido pero no, Javascript define que una funci√≥n invocada sin contexto, el contexto debe ser el Objeto Global, que en el caso de un navegador ser√≠a <code>window</code>. Por lo que en <strong>una funci√≥n que no est√© contenida en ning√∫n objeto recibir√° el objeto global</strong> como <code>this</code>.</p>
<h3 id="callbacks">Callbacks</h3>
<p>Ya con toda √©sta base podemos abordar el problema de los callbacks, supongamos que tenemos una funci√≥n que hace un proceso as√≠ncrono y necesitamos pasarle un callback para que se ejecute cuando el proceso as√≠ncrono termine. Para el ejemplo pondremos que la tarea as√≠ncrona sea esperar un segundo</p>

<code class="code-block shj-lang-js"><div><div class="shj-numbers"><div></div><div></div><div></div><div></div><div></div></div><div><span class="shj-syn-kwd">function</span> <span class="shj-syn-func">esperarUnSegundo</span>(callback) {
  <span class="shj-syn-func">setTimeout</span>(<span class="shj-syn-kwd">function</span> () {
    <span class="shj-syn-func">callback</span>();
  }<span class="shj-syn-oper">,</span> <span class="shj-syn-num">1000</span>);
}</div></div>
</code>
<p>Perfecto, ya tenemos una funci√≥n que espera que pase un segundo y llama al callback, pero que pasa si la usamos de √©sta forma?</p>

<code class="code-block shj-lang-js"><div><div class="shj-numbers"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div><div><span class="shj-syn-kwd">var</span> alice <span class="shj-syn-oper">=</span> {
  nombre<span class="shj-syn-oper">:</span> <span class="shj-syn-str">'Alice'</span><span class="shj-syn-oper">,</span>
  cansarse<span class="shj-syn-oper">:</span> <span class="shj-syn-kwd">function</span> () {
    <span class="shj-syn-func">alert</span>(<span class="shj-syn-kwd">this</span><span class="shj-syn-oper">.</span>nombre <span class="shj-syn-oper">+</span> <span class="shj-syn-str">' se ha cansado de esperar'</span>);
  }<span class="shj-syn-oper">,</span>
};
<span class="shj-syn-func">esperarUnSegundo</span>(alice<span class="shj-syn-oper">.</span>cansarse);</div></div>
</code>
<p><a href="http://jsfiddle.net/amatiasq/erfJF/" target="_blank">Pru√©bame</a></p>
<p>Aqu√≠ tenemos un problema, al parecer <code>this.nombre</code> no es &quot;Alice&quot;. Porqu√©? Repasemos la regla de oro, <code>this</code> ser√° el objeto que est√° antes del punto que precede a los par√©ntesis que ejecutan la funci√≥n. Busquemos los par√©ntesis que ejecutan la funci√≥n:</p>

<code class="code-block shj-lang-js"><div><div class="shj-numbers"><div></div></div><div><span class="shj-syn-func">callback</span>();</div></div>
</code>
<p>Y vemos que no hay ning√∫n punto delante. <strong>La funci√≥n la hemos extra√≠do del objeto</strong> <code>alice</code>, pero al extraerla la hemos desvinculado de √©l y al llamarlo ya no se le pasa <code>alice</code> porque ya no se la llama con <code>alice.&lt;nombre del m√©todo&gt;</code> Entonces c√≥mo hacemos para que callback no pierda su contexto? para que mantenga el valor de <code>this</code> a <code>alice</code>?</p>
<h3 id="los-m-todos-de-function-">Los m√©todos de <code>Function</code></h3>
<p>Para √©sto vienen en nuestra ayuda los m√©todos de <code>Function</code>, como ya dijimos, <strong>las funciones son instancias de la clase <code>Function</code> y como tal tienen tambi√©n m√©todos propios</strong>. Los m√°s utilizados son <code>.call()</code> y <code>.apply()</code></p>
<h4 id="-call-imaginemos-que-tenemos-otra-vez-el-objeto-alice-y-que-guardamos-su-m-todo-en-una-variable-"><code>.call()</code> Imaginemos que tenemos otra vez el objeto <code>alice</code> y que guardamos su m√©todo en una variable.</h4>

<code class="code-block shj-lang-js"><div><div class="shj-numbers"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div><div><span class="shj-syn-kwd">var</span> alice <span class="shj-syn-oper">=</span> {
  nombre<span class="shj-syn-oper">:</span> <span class="shj-syn-str">'Alice'</span><span class="shj-syn-oper">,</span>
  cansarse<span class="shj-syn-oper">:</span> <span class="shj-syn-kwd">function</span> () {
    console<span class="shj-syn-oper">.</span><span class="shj-syn-func">log</span>(<span class="shj-syn-kwd">this</span><span class="shj-syn-oper">.</span>nombre);
  }<span class="shj-syn-oper">,</span>
};

<span class="shj-syn-kwd">var</span> myFunction <span class="shj-syn-oper">=</span> alice<span class="shj-syn-oper">.</span>cansarse;</div></div>
</code>
<p>Si llamamos a <code>myFunction</code> directamente lo estar√≠amos llamando sin contexto por lo el la variable <code>this</code> tendr√≠a el objeto global dentro de <code>myFunction</code>, como podemos hacer que ejecute <code>myFunction</code> pero pas√°ndole <code>alice</code> como <code>this</code>? Para √©sto tenemos las funciones <code>.call()</code> y <code>.apply()</code>, empecemos por la funci√≥n <code>.call()</code>.</p>
<p><strong>La funci√≥n <code>.call()</code> recibe los mismos argumentos que la funci√≥n mas uno, el valor que tendr√° <code>this</code> que se pasa antes que los dem√°s argumentos</strong>. Es decir, nuestra funci√≥n <code>myFunction</code> no recibe ning√∫n argumento as√≠ que si llamamos a su m√©todo <code>.call()</code> y le pasamos lo que queremos que sea <code>this</code> es decir, <code>alice</code> conseguiremos que el m√©todo funcione igual que si lo hubi√©semos llamado con <code>alice.cansarse</code></p>

<code class="code-block shj-lang-js"><div><div class="shj-numbers"><div></div></div><div>myFunction<span class="shj-syn-oper">.</span><span class="shj-syn-func">call</span>(alice);</div></div>
</code>
<p><a href="http://jsfiddle.net/amatiasq/kbr5t/" target="_blank">Pru√©bame</a></p>
<p>Ahora vamos a probar lo mismo con una funci√≥n que reciba argumentos:</p>

<code class="code-block shj-lang-js"><div><div class="shj-numbers"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div><div><span class="shj-syn-kwd">var</span> alice <span class="shj-syn-oper">=</span> {
  nombre<span class="shj-syn-oper">:</span> <span class="shj-syn-str">'Alice'</span><span class="shj-syn-oper">,</span>
  saludar<span class="shj-syn-oper">:</span> <span class="shj-syn-kwd">function</span> (amigo1<span class="shj-syn-oper">,</span> amigo2) {
    <span class="shj-syn-func">alert</span>(<span class="shj-syn-str">'Hola '</span> <span class="shj-syn-oper">+</span> amigo1 <span class="shj-syn-oper">+</span> <span class="shj-syn-str">' y '</span> <span class="shj-syn-oper">+</span> amigo2 <span class="shj-syn-oper">+</span> <span class="shj-syn-str">', yo soy '</span> <span class="shj-syn-oper">+</span> <span class="shj-syn-kwd">this</span><span class="shj-syn-oper">.</span>nombre);
  }<span class="shj-syn-oper">,</span>
};

<span class="shj-syn-kwd">var</span> myFunction <span class="shj-syn-oper">=</span> alice<span class="shj-syn-oper">.</span>saludar;
myFunction<span class="shj-syn-oper">.</span><span class="shj-syn-func">call</span>(alice<span class="shj-syn-oper">,</span> <span class="shj-syn-str">'Bob'</span><span class="shj-syn-oper">,</span> <span class="shj-syn-str">'Rob'</span>);</div></div>
</code>
<p><a href="http://jsfiddle.net/amatiasq/HZuPL/" target="_blank">Pru√©bame</a></p>
<p>Como se ve, hemos conseguido modificar el valor que tiene <code>this</code> cuando se ejecuta la funci√≥n, es decir el contexto.</p>
<h4 id="-apply-">.apply()</h4>
<p>El m√©todo <code>.apply()</code> act√∫a de forma bastante similar a <code>.call()</code>, pero con una variaci√≥n, solo <strong>recibe dos argumentos, el primero es el contexto de la funci√≥n</strong>, el valor de <code>this</code> <strong>y el segundo ser√° un array que contendr√° los argumentos que se le pasar√°n a la funci√≥n</strong>, veamos su uso en el ejemplo anterior:</p>

<code class="code-block shj-lang-js"><div><div class="shj-numbers"><div></div></div><div>myFunction<span class="shj-syn-oper">.</span><span class="shj-syn-func">apply</span>(alice<span class="shj-syn-oper">,</span> [<span class="shj-syn-str">'Bob'</span><span class="shj-syn-oper">,</span> <span class="shj-syn-str">'Rob'</span>]);</div></div>
</code>
<p><a href="http://jsfiddle.net/amatiasq/bSmeR/" target="_blank">Pru√©bame</a></p>
<p>Esto aunque en un principio parezca bastante in√∫til nos servir√° cuando, queriendo o no cambiar el contexto de una funci√≥n, <strong>querramos llamarla y no sepamos ni nos interese saber cu√°ntos argumentos tiene</strong>, supongamos que tenemos la funci√≥n <code>callWithAlice()</code> que llama a la funci√≥n <code>.saludar()</code> de <code>alice</code> y le pasa todos los argumentos que recibe.</p>
<p><strong>Nota 1:</strong> Para √©sto hace falta aclarar que el objeto <code>arguments</code> es una especie de array con los argumentos pasados a la funci√≥n, m√°s adelante profundizaremos en ello.</p>
<p><strong>Nota 2:</strong> En √©ste caso no queremos cambiar el contexto, pero como estamos llamando a <code>.apply()</code> tenemos que darle uno, por lo que le damos <code>alice</code> que es el contexto que ya ten√≠a.</p>

<code class="code-block shj-lang-js"><div><div class="shj-numbers"><div></div><div></div><div></div><div></div></div><div><span class="shj-syn-kwd">function</span> <span class="shj-syn-func">callWithAlice</span>() {
  alice<span class="shj-syn-oper">.</span>saludar<span class="shj-syn-oper">.</span><span class="shj-syn-func">apply</span>(alice<span class="shj-syn-oper">,</span> arguments);
}
<span class="shj-syn-func">callWithAlice</span>(<span class="shj-syn-str">'Rob'</span><span class="shj-syn-oper">,</span> <span class="shj-syn-str">'Bob'</span>);</div></div>
</code>
<p><a href="http://jsfiddle.net/amatiasq/VrESt/" target="_blank">Pru√©bame</a></p>
<h4 id="bonus-bind-">Bonus: .bind()</h4>
<p>Ahora que ya entendemos el contexto, <code>.call()</code> y <code>.apply()</code> sabremos que cuando pasemos una funci√≥n como callback si no queremos perder el contexto de la funci√≥n deberemos hacer:</p>

<code class="code-block shj-lang-js"><div><div class="shj-numbers"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div><div><span class="shj-syn-kwd">function</span> <span class="shj-syn-func">esperarUnSegundo</span>(callback) {
  <span class="shj-syn-func">setTimeout</span>(<span class="shj-syn-kwd">function</span>() {
    <span class="shj-syn-func">callback</span>();
  }<span class="shj-syn-oper">,</span> <span class="shj-syn-num">1000</span>);
});

<span class="shj-syn-func">esperarUnSegundo</span>(<span class="shj-syn-kwd">function</span>() {
  alice<span class="shj-syn-oper">.</span><span class="shj-syn-func">myMethod</span>();
});</div></div>
</code>
<p>O bien:</p>

<code class="code-block shj-lang-js"><div><div class="shj-numbers"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div><div><span class="shj-syn-kwd">function</span> <span class="shj-syn-func">esperarUnSegundo</span>(callback<span class="shj-syn-oper">,</span> context) {
  <span class="shj-syn-func">setTimeout</span>(<span class="shj-syn-kwd">function</span>() {
    callback<span class="shj-syn-oper">.</span><span class="shj-syn-func">call</span>(context);
  }<span class="shj-syn-oper">,</span> <span class="shj-syn-num">1000</span>);
});

<span class="shj-syn-func">esperarUnSegundo</span>(alice<span class="shj-syn-oper">.</span>myMethod<span class="shj-syn-oper">,</span> alice);</div></div>
</code>
<p>Pero √©sto puede ser un poco tedioso cuando manejas muchos callbacks de √©ste tipo, para ello se ha creado el m√©todo <code>.bind()</code>. Es un m√©todo de <code>Function</code> que devuelve otra funci√≥n. Confuso, verdad?</p>
<p><strong><code>.bind()</code> recibe un argumento, el contexto que se le podr√° a la funci√≥n sobre la que se aplica el <code>.bind()</code> y devolver√° una funci√≥n</strong> que cuando sea llamada ejecutar√° la funci√≥n original con el contexto que se le pas√≥ a <code>.bind()</code>. Lo veremos mejor con un ejemplo:</p>

<code class="code-block shj-lang-js"><div><div class="shj-numbers"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div><div><span class="shj-syn-kwd">var</span> alice <span class="shj-syn-oper">=</span> {
  nombre<span class="shj-syn-oper">:</span> <span class="shj-syn-str">'Alice'</span><span class="shj-syn-oper">,</span>
  saludar<span class="shj-syn-oper">:</span> <span class="shj-syn-kwd">function</span> () {
    console<span class="shj-syn-oper">.</span><span class="shj-syn-func">log</span>(<span class="shj-syn-str">'Hola! Soy '</span> <span class="shj-syn-oper">+</span> <span class="shj-syn-kwd">this</span><span class="shj-syn-oper">.</span>nombre);
  }<span class="shj-syn-oper">,</span>
};

<span class="shj-syn-kwd">var</span> myFunction <span class="shj-syn-oper">=</span> alice<span class="shj-syn-oper">.</span>saludar<span class="shj-syn-oper">.</span><span class="shj-syn-func">bind</span>(alice);
<span class="shj-syn-func">myFunction</span>();</div></div>
</code>
<p><a href="http://jsfiddle.net/amatiasq/NUWCy/" target="_blank">Pru√©bame</a></p>
<p>Lo que hemos hecho en la l√≠nea 8 es crear una funci√≥n que cuando sea invocada llamar√° a <code>saludar</code> y le pasar√° <code>alice</code> como contexto.</p>
<h3 id="y-ya-est-">Y ya est√°!</h3>
<p>Con √©ste repaso ya deber√≠amos ser capaces de entender la parte m√°s complicada para un reci√©n llegado a Javascript, la modificaci√≥n del contexto. Es una t√©cnica que requiere mucha pr√°ctica, pero detr√°s de la cual se esconde la mitad del potencial de Javascript y como tal, tambi√©n nos abre los ojos a muchos bugs que de otra forma ser√≠an imposibles de entender.</p>
<p>De hecho, para los que les gusta romperse la cabeza como yo, les dejo un caramelo: Todas las funciones tienen los m√©todos <code>.call()</code>, <code>.apply()</code> y <code>.bind()</code>, es cierto. Pero √©stos m√©todos tambi√©n son funciones, eso significa que podemos hacer √©sto? Que resultado tendr√≠a? Se los dejo a ustedes ;)</p>

<code class="code-block shj-lang-js"><div><div class="shj-numbers"><div></div></div><div>alice<span class="shj-syn-oper">.</span>saludar<span class="shj-syn-oper">.</span>call<span class="shj-syn-oper">.</span>call<span class="shj-syn-oper">.</span>call<span class="shj-syn-oper">.</span>call<span class="shj-syn-oper">.</span>apply<span class="shj-syn-oper">.</span><span class="shj-syn-func">bind</span>();</div></div>
</code>
<p>Y que pasa si llamo a uno de √©stos m√©todos y no le paso scope?</p>

<code class="code-block shj-lang-js"><div><div class="shj-numbers"><div></div></div><div>alice<span class="shj-syn-oper">.</span>saludar<span class="shj-syn-oper">.</span><span class="shj-syn-func">call</span>(<span class="shj-syn-num">null</span>);</div></div>
</code>
<p>Espero que haya sido claro y conciso, pero me temo que ha sido m√°s de lo primero que de lo segundo. Pronto tendr√© otro art√≠culo sobre Conceptos B√°sicos de Javascript. Saludos.</p>
</div></article></div></body></html>