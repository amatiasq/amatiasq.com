<!DOCTYPE html><html lang="en"><head><meta charSet="UTF-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>potato</title><style>
  /* Box sizing rules */
  *, *::before, *::after {
    box-sizing: border-box;
  }

  /* Remove default padding */
  ul, ol {
    padding: 0;
  }

  /* Remove default margin */
  body, h1, h2, h3, h4, p, ul, ol, li, figure, figcaption, blockquote, dl, dd {
    margin: 0;
  }

  /* Set core body defaults */
  body {
    min-height: 100vh;
    scroll-behavior: smooth;
    text-rendering: optimizeSpeed;
    line-height: 1.5;
  }

  /* Remove list styles on ul, ol elements with a class attribute */
  ul, ol {
    list-style: none;
  }

  /* A elements that don&#x27;t have a class get default styles */
  a:not([class]) {
    text-decoration-skip-ink: auto;
  }

  /* Make images easier to work with */
  img {
    max-width: 100%;
    display: block;
  }

  /* Natural flow and rhythm in articles by default */
  article &gt; * + * {
    margin-top: 1em;
  }

  /* Inherit fonts for inputs and buttons */
  input, button, textarea, select {
    font: inherit;
  }

  /* Remove all animations and transitions for people that prefer not to see them */
  @media (prefers-reduced-motion: reduce) {
    * {
      animation-duration: 0.01ms !important;
      animation-iteration-count: 1 !important;
      transition-duration: 0.01ms !important;
      scroll-behavior: auto !important;
    }
  }

  @import url(&#x27;https://fonts.googleapis.com/css2?family=Inter:wght@400;700&amp;display=swap&#x27;);

  :root {
    background-color: #1B2430;
    color: #FDFBF8;
    font-family: Inter, Helvetica;
    font-size: 18px;
  }

  a {
    color: #A8E0FF;
  }

  .md p {
    margin: 20px 0;
    text-align: justify;
  }
</style><style></style></head><body class=""><div class="md"><blockquote>
<p>NOTA: Este artículo está centrado en un tema que ya comenté en <a href="http://blog.amatiasq.com/2014/03/construccion-de-objetos/">el post anterior</a>, pero de una forma más organizada y centrada, algunos fragmentos están extraídos del post anterior para mayor claridad.</p>
</blockquote>
<h2 id="constructores-en-javascript">Constructores en Javascript</h2>
<p>He hablado antes de la limitación de los constructores javascript y sobre todo de la complejidad de extenderlos</p>

<pre><code class="lang-js">function Person(name) {
  this.name = name;
}
Person.prototype.methodA = function() { ... };

function Employee(name, position) {
  Person.call(this, name);
  this.position = position;
}
Employee.prototype = Object.create(Person.prototype);
Employee.prototype.methodB = function() { ... };
</code></pre>
<p>Esto es un asunto que trae de cabeza a la mayoría de la gente que programa javascript, la dificiltad que conlleva crear una simple &quot;clase&quot; hasta el punto que en la siguiente versión del ECMAScript (el estándar en el que está basado Javascript) han incluído una forma más sencilla de hacer lo mismo: la palabra clave <code>class</code></p>

<pre><code class="lang-js">class Person {
  constructor(name) {
    this.name = name;
  }
  methodA() {}
}

class Employee extends Person {
  constructor(name, position) {
    super(name);
    this.position = position;
  }
  methodB() {}
}
</code></pre>
<p><a target="_blank" href="http://www.es6fiddle.net/hsq7hzw6/">Pruébame</a></p>
<p>Aunque he visto a mucha gente emocionada pensando que ECMAScript 6 traerá clases reales tengo que decir que este código no hace ni más ni menos que lo que hace el primer código. Y es muy importante saberlo porque aunque prezcan classes como las de Java o C++, en este caso siguen siendo objetos usando <a href="http://blog.amatiasq.com/2012/01/javascript-conceptos-basicos-herencia-por-prototipos/">herencia por prototipos</a> y esconderlo solo servirá para no saber porqué el código no funciona como esperamos.</p>
<p>En cualquier caso vemos que definir tipos en javascript es complicado y la solución propuesta por el equipo de ECMA no es, en mi opinión, la más adecuada.</p>
<h2 id="orientado-a-objetos">Orientado a objetos</h2>
<p>Creo que el problema se aloja en la definición que dimos en un principio a &quot;Programación Orientada a Objetos&quot; (Object Oriented Programming, OOP) ya que los primeros lenguajes OOP creaban objetos usando clases y otras herramientas, y aunque los objetos son la base del sistema la estructura está dada por las clases. Lo que sería Programación Orientada a Objetos con Clases.</p>
<!--more Seguir leyendo → -->
<p>Después recibimos otros lenguajes que también se definian como &quot;Programación Orientados a Objetos&quot; pero enfocado de otra forma, entre ellos javascript. En este caso el lenguaje no tiene clases sino que todo son objetos y la estructura se crea mediante prototipos, todo objeto puede ser el prototipo de otro objeto y esto significa que si B prototipa a A todas las propiedades que A tenga también existirán en B. Esto es lo que llamo Programación Orientada a Objetos con Prototipos.</p>
<p>Me he cruzado con mucha gente que piensa que la Programación Orientada a Objetos no es posible sin clases y que si Javascript no tiene clases no puede denominarse orientado a objetos. Como en todo debate entre geeks acabamos en la wikipedia:</p>
<blockquote>
<p>La programación orientada a objetos o POO (OOP según sus siglas en inglés) es un paradigma de programación que usa los objetos en sus interacciones, para diseñar aplicaciones y programas informáticos. Está basado en varias técnicas, incluyendo herencia, cohesión, abstracción, polimorfismo, acoplamiento y encapsulamiento.</p>
</blockquote>
<p>En resumen, un lenguaje orientado a objetos es el que tiene objetos (brillante conclusión) y cumple una serie de técnicas (herencia, cohesión, abstracción, polimorfismo...) que en el caso de Java se hace mediante clases y en el caso de Javascript se hace mediante prototipos.</p>
<h2 id="los-inicios-de-javascript">Los inicios de Javascript</h2>
<p>Javascript en sus inicios se llamó LiveScript, cuenta la leyenda que por aquella época Java estaba teniendo mucho éxito y por marketing se decidió llamar al nuevo lenguaje JavaScript. También cuenta que por el mismo motivo a última hora se decidió modificar el lenguaje para parecerse más a Java añadiendo, entre otras funcionalidades, el operador <code>new</code> para que pareciera tener clases.</p>
<p>Hay algo muy curioso en los constructores Javascript, que en el fondo son simples funciones, y es que todas las funciones javascript tienen la propiedad <code>prototype</code> que por defecto trae un objeto que solo tiene una propiedad, la propiedad <code>constructor</code> que es el propio constructor.</p>

<pre><code class="lang-js">function Testing() {}
console.log(Testing.prototype.constructor === Testing);

var proto = Testing.prototype;
console.log(proto.constructor.prototype === proto);
</code></pre>
<h2 id="constructores-vs-objetos-prototipo">Constructores vs objetos prototipo</h2>
<p>Esto me hace pensar que quizás la intención original de los objetos en javascript no era tener constructores que contienen prototipos sino tener prototipos que contienen constructores. Es decir: en lugar de...</p>

<pre><code class="lang-js">function MyType() {
  this.id = 1;
}
MyType.prototype.methodA = function() { ... }
</code></pre>
<p>Hacer esto...</p>

<pre><code class="lang-js">var MyType = {
  constructor: function() {
    this.id = 1;
  },
  methodA: function() { ... },
};
</code></pre>
<p>Vaya! No parece una forma mucho más sencilla de declarar tipos? [Aquí][5] podemos comparar el mismo tipo escrito con constructores y con este paradigma y juzguen ustedes mismos. Y que pasa cuando intentamos invocar al constructor? hay que usar <code>.call()</code> o <code>.apply()</code> para pasarle this?</p>

<pre><code class="lang-js">var instancia = Object.create(MyType);
instancia.constructor();
</code></pre>
<p>BOOM! Constructor ya recibe this porque es invocado directamente en la instancia! No es exageradamente sencillo y lógico desde éste punto de vista?</p>
<p>Además por accidente hemos quitado de en medio la función constructora y lo que tenemos es un simple objeto, el elemento más básico de la programación orientada a objetos. Es decir, para declarar un tipo solo tenemos que crear un objeto, para prototipar un objeto solo necesitamos un paso</p>

<pre><code class="lang-js">var SubType = Object.create(MyType);
</code></pre>
<p>No estamos obligados, a diferenia del primer caso, a crear un nuevo constructor para crear un subtipo, por la herencia por prototipos tenemos el mismo constructor que <code>MyType</code></p>

<pre><code class="lang-js">console.log(SubType.constructor === MyType.constructor);
// true
</code></pre>
<p><a target="_blank" href="http://jsfiddle.net/amatiasq/VRKYv/">Pruébame</a></p>
<p>Y la mejor parte, que pasa si queremos crear un tipo sin constructor? No hay problema.</p>

<pre><code class="lang-js">var MyType = {};
console.log(MyType.constructor); // Object
</code></pre>
<p><a target="_blank" href="http://jsfiddle.net/amatiasq/yGJLL/">Pruébame</a></p>
<h2 id="ecmascript-6">ECMAScript 6</h2>
<p>Este paradigma se parece bastante a la forma de crear clases en ECMAScript 6</p>

<pre><code class="lang-js">class MyType {
  constructor() {
    this.id = 1;
  }
  methodA() { ... }
}
</code></pre>
<p>Que alguno dirá, si, pero con las clases de ECMAScript 6 podemos extender clases, llamar al método padre con <code>super</code> y nos ahorramos poner <code>function</code>... Pero esas no son funcionalidades de las clases de ECMAScript 6, esas son funcionalidades <a href="https://github.com/lukehoban/es6features#enhanced-object-literals">de todos los objetos</a> en ECMAScript 6.</p>

<pre><code class="lang-js">// Clase ECMAScript 6
class Employee extends Person {
  constructor(name, postition) {
    super(name);
    this.position = postition;
  }
  methodA() { ... }
}

// Objeto en ECMAScript 6 estándar
var Employee = {
  __proto__: Person,

  constructor() {
    super(name)
    this.id = 1;
  },
  methodA() { ... }
};
</code></pre>
<p>Las diferencias entre una clase ECMAScript 6 y un objeto en ECMAScript 6 son mínimas, pero mientras que una clase nos hace pensar que <code>Employee</code> se comportará como una clase Java cuando no es así, un objeto es simplemente eso, un objeto y todos somos capaces de entender como se comporta un objeto, no? (si no que haces leyendo esto? o.o)</p>
<p>Pero dejemos ECMAScript 6 de lado por ahora, que aún tiene que transcurrir tiempo antes de que podamos usarlo en serio.</p>
<h2 id="instanciaci-n">Instanciación</h2>
<p>Hasta aquí era la definicion del tipo, pero como creamos una instancia? Primero tendríamos que plantearnos que es una instancia, si no tenemos clases podemos tener instancias? Según la wikipedia</p>
<blockquote>
<p>En el paradigma de la orientación a objetos, una instancia (en inglés, instance) se refiere a una realización específica de una clase o prototipo determinados.</p>
</blockquote>
<p>Pero, al menos a mi, no importa mucho la palabra; el tema es que nosotros creamos objetos para que hagan de prototipos y queremos crear &quot;instancias&quot; de estos prototipos. La forma de prototipar un objeto es usando <code>Object.create()</code></p>

<pre><code class="lang-js">var instance = Object.create(MyType);
</code></pre>
<p>Pero, un momento... Esto es exactamente lo mismo que hicimos para crear un subtipo, no? Si. Entonces en que se diferencia una instancia de un subtipo? En general, nada. <strong>Una instancia ES un subtipo</strong>. Pero en la mayoría de los casos las &quot;instancias&quot; tienen una necesidad que los subtipos no tienen: en una instancia se invoca al constructor, en un subtipo no.</p>

<pre><code class="lang-js">var MyType = {
  constructor: function () {
    this.id = 1;
  },
};

// Crear sub-tipo
var SubType = Object.create(MyType);

// Crear instancia
var instance = Object.create(MyType);
instance.constructor();
</code></pre>
<p>Esta similitud entre una instancia y un SubTipo nos ayuda a entender hasta que punto en el fondo Javascript es muy, muy sencillo: todo son objetos; no hay diferencia entre un tipo y una instancia porque la diferencia es conceptual.</p>
<p>Esto es muy útil para entender la sencillez y el corazón de Javascript, pero es un poco tedioso tener que hacer dos pasos para instanciar, podríamos simplificarlo?</p>
<h2 id="-type-new-es-el-nuevo-new-"><code>Type.new()</code> es el nuevo <code>new</code></h2>
<p>Lo cierto es que podríamos, podemos hacer una función que haga este proceso:</p>

<pre><code class="lang-js">function createInstance(Type) {
  var instance = Object.create(Type);
  instance.constructor();
  return instance;
}

var Type = {
  constructor: function () {
    this.id = 1;
  },
};

var instance1 = createInstance(Type);

var TypeWithoutConstructor = {};
var instance2 = createInstance(TypeWithoutConstructor);
</code></pre>
<p><a target="_blank" href="http://jsfiddle.net/amatiasq/Jry2Z/">Pruébame</a></p>
<p>Y que pasa si en lugar de llamarla <code>createInstance</code> la llamamos <code>$new</code> por ejemplo?</p>

<pre><code class="lang-js">var instance = $new(MyType);
</code></pre>
<p>Empieza a parecer similar, solo nos faltaría cambiar la funcion <code>$new</code> para pasarle parámetros al constructor</p>

<pre><code class="lang-js">function $new(Type, params) {
  var instance = Object.create(Type);
  instance.constructor.apply(instance, params);
  return instance;
}

var Type = {
  constructor: function (name) {
    this.name = name;
  },
};

var instance = $new(Type, [&#39;bob&#39;]);
</code></pre>
<p><a target="_blank" href="http://jsfiddle.net/amatiasq/t8QCk/">Pruébame</a></p>
<p>Parece funcionar, pero solo para acabar de pulirlo, porqué no ponemos $new como método de Type? así podríamos pasarle los argumentos sin el array y como ECMAScript 5 nos permite usar palabras clave como propiedades de objeto podemos llamarlo simplemente <code>new</code>.</p>

<pre><code class="lang-js">var Type = {
  new: function () {
    var instance = Object.create(this);
    instance.constructor.apply(instance, arguments);
    return instance;
  },
  constructor: function (name) {
    this.name = name;
  },
};

var instance = Type.new(&#39;bob&#39;);
</code></pre>
<p><a target="_blank" href="http://jsfiddle.net/amatiasq/x3qM4/">Pruébame</a></p>
<p>Y tenemos una forma que podemos usar con ECMAScript 5 para crear tipos e instancias de forma sencilla. Pero que diferencia hay entre esto y hacer un <code>new</code>? A parte de la ya mencionada simplicidad para crear y extender tipos, tiene más ventajas, principalmente porque nos permite controlar más exactamente <strong>cómo</strong> se crea un objeto que en algunos casos es conveniente cambiarlo (en la mayoría no), pero excede el alcance de éste post.</p>
<h2 id="conclusi-n">Conclusión</h2>
<p>Después de pasarme los últimos años probando <a href="https://gist.github.com/amatiasq/4038135">mil</a> <a href="https://gist.github.com/amatiasq/5215294">y</a> <a href="https://gist.github.com/amatiasq/5254098">una</a> <a href="https://gist.github.com/amatiasq/5619166">formas</a> <a href="https://gist.github.com/amatiasq/6270563">de</a> <a href="https://github.com/amatiasq/LifeJS/blob/master/lib/animal.js">crear</a> <a href="https://github.com/amatiasq/-legacy-BRIAP/blob/master/src/core/base.js">y</a> <a href="https://github.com/amatiasq/-legacy-bio/blob/master/src/core/Base.js">extender</a> <a href="https://github.com/amatiasq/jsbase/blob/master/src/extend.js">&quot;clases&quot;</a> <a href="https://github.com/amatiasq/-legacy-Life/blob/master/lib/physic/Force.dart">para</a> <a href="https://github.com/amatiasq/glib/blob/master/core/base.js">encontrar</a> <a href="https://github.com/amatiasq/lulas/blob/master/src/core/extend.js">la</a> forma más sencilla, rápida y elegante, muchas de ellas registradas en este blog; me quedo con <a href="https://gist.github.com/amatiasq/7892749">ésta</a>. La lección que me dio javascript es que no es conveniente luchar contra su naturaleza, si queremos usar javascript y no morir en el intento lo más razonable es usar javascript y no tratarlo en contra de su naturaleza.</p>
<p>Aún está por verse pero creo que este sistema incluso puede competir cara a cara con las &quot;clases&quot; de ECMAScript 6, pero en cualquier caso la conversión entre un tipo creado por constructor y uno creado con este sistema es muy sencilla</p>
<p>Por ejemplo, convertir un tipo creado con este sistema a constructor para usarlo con <code>new</code>:</p>

<pre><code class="lang-js">var MyType = {
  myMethod: function() { ... },
};

function MyConstructor() {
  MyType.constructor.apply(this, arguments);
}
MyConstructor.prototype = MyType;
</code></pre>
<p><a target="_blank" href="http://jsfiddle.net/amatiasq/tGD7G/">Pruébame</a></p>
<p>O convertir un constructor a este paradigma:</p>

<pre><code class="lang-js">function MyConstructor() {
  this.value = 1;
}
MyConstructor.prototype.myMethod = function() { ... };

var MyType = MyConstructor.prototype;
// y si queres añadir new...
MyType.new = $new;
</code></pre>
<p><a target="_blank" href="http://jsfiddle.net/amatiasq/5R4z2/">Pruébame</a></p>
<h2 id="inicializador">Inicializador</h2>
<p>Para finalizar un bonus, después de toda esta travesía me he dado cuenta que el constructor, que para javascript parece tan importante, no lo es tanto. Si nos paramos a mirar el constructor vemos que es una simple función</p>

<pre><code class="lang-js">function MyType() { ... }
</code></pre>
<p>No tiene nada de especial, incluso podemos invocarla como una función y no construye nada. Entonces quién construye? <code>new</code>. Es el operador <code>new</code> el que crea el nuevo objeto y luego invoca el método llamado &quot;constructor&quot;, que no se diferencia en nada de cualquier otro método que podría tener el objeto.</p>
<p>Por como yo lo veo, la función del constructor es más inicializar que construir, debe encargarse de inicializar las propiedades del objeto, no construir. Visto así es evidente que el nombre &quot;constructor&quot; no es apropiado, en mi caso prefiero la denominación &quot;initializer&quot; o simplemente &quot;init&quot;, como Backbone ya hace en sus objetos.</p>
<p>Por eso en mis proyectos cuando utilizo este paradigma, prefiero que mi función <code>$new</code> invoque el método <code>init</code> en lugar de llamar al método <code>constructor</code>.</p>

<pre><code class="lang-js">function $new() {
  var obj = Object.create(this);
  obj.init.apply(obj, arguments);
  return obj;
}

var MyType = {
  new: $new,
  init: function () {
    this.value = 1;
  },
};

var instance = MyType.new();
</code></pre>
<p><a target="_blank" href="http://jsfiddle.net/amatiasq/7h7Te/">Pruébame</a></p>
</div></body></html>