<!DOCTYPE html><html lang="es"><head><meta charset="utf-8"><!-- <link rel="icon" type="image/svg+xml" href="/favicon.svg" /> --><meta name="viewport" content="width=device-width"><title>A. Mat√≠as Quezada</title><style>pre code.hljs{display:block;overflow-x:auto;padding:1em}code.hljs{padding:3px 5px}/*!
  Theme: GitHub Dark
  Description: Dark theme as seen on github.com
  Author: github.com
  Maintainer: @Hirse
  Updated: 2021-05-15

  Outdated base version: https://github.com/primer/github-syntax-dark
  Current colors taken from GitHub's CSS
*/.hljs{color:#c9d1d9;background:#0d1117}.hljs-doctag,.hljs-keyword,.hljs-meta .hljs-keyword,.hljs-template-tag,.hljs-template-variable,.hljs-type,.hljs-variable.language_{color:#ff7b72}.hljs-title,.hljs-title.class_,.hljs-title.class_.inherited__,.hljs-title.function_{color:#d2a8ff}.hljs-attr,.hljs-attribute,.hljs-literal,.hljs-meta,.hljs-number,.hljs-operator,.hljs-variable,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-id{color:#79c0ff}.hljs-regexp,.hljs-string,.hljs-meta .hljs-string{color:#a5d6ff}.hljs-built_in,.hljs-symbol{color:#ffa657}.hljs-comment,.hljs-code,.hljs-formula{color:#8b949e}.hljs-name,.hljs-quote,.hljs-selector-tag,.hljs-selector-pseudo{color:#7ee787}.hljs-subst{color:#c9d1d9}.hljs-section{color:#1f6feb;font-weight:700}.hljs-bullet{color:#f2cc60}.hljs-emphasis{color:#c9d1d9;font-style:italic}.hljs-strong{color:#c9d1d9;font-weight:700}.hljs-addition{color:#aff5b4;background-color:#033a16}.hljs-deletion{color:#ffdcd7;background-color:#67060c}pre code.hljs{--_code-margin: var(--code-margin, 1.5em);white-space:pre;background-color:#000;margin:var(--_code-margin) calc(var(--_code-margin) * -1);padding:var(--_code-margin);border-radius:8px}pre code.hljs>.hljs-comment{color:#999}code:not(.hljs){padding:0 .3em .1em;border-radius:5px;background-color:#0000004d}.md{display:grid;gap:24px}.md :is(h1,h2,h3,h4,h5,h6),.md li+li{margin-top:16px}.md :is(ul,pre,code,p){margin-top:0!important;margin-bottom:0!important}.md p{text-align:justify}.md blockquote{border-left:2px solid var(--color-text);margin-left:0;padding-left:1em}
.tag-list{display:flex;gap:.5em;flex-wrap:wrap;list-style:none;margin:0;padding:0}:root{--grid-transparent-width: 960px}
</style>
<link rel="stylesheet" href="/_astro/_slug_.6d0c3eca.css" /><script type="module">CSS.paintWorklet?.addModule("/dot-mesh.js");
</script></head><body class="content-grid"><script defer>
  function closeHamburger() {
    document.querySelector('hamburger-button')?.removeAttribute('active');
  }
</script><script type="module" defer>export const tagName = 'hamburger-button';

export const template = `
  <div class="bar"></div>
  <div class="bar"></div>
  <div class="bar"></div>

  <style>
    :host {
      cursor: pointer;
  
      --_color: var(--color, black);
      --_width: var(--width, 2em);
      --_thickness: var(--thickness, 3px);
      --_spacing: var(--spacing, 7px);
      --_opacity: var(--opacity, 0.5);
  
      --translation-x: calc(var(--_thickness) + var(--_spacing));
    }
  
    .bar {
      width: var(--_width);
      height: var(--_thickness);
      background-color: var(--_color);
      margin: var(--_spacing) 0;
      opacity: var(--_opacity);
  
      will-change: transform, opacity;
      transition: 0.4s;
      transition-property: transform, opacity;
    }
  
    :host(:hover) .bar {
      opacity: 1;
    }
  
    :host([active]) .bar:first-of-type {
      transform: translate(0, var(--translation-x)) rotate(45deg);
    }
  
    :host([active]) .bar:nth-child(2) {
      opacity: 0;
    }
  
    :host([active]) .bar:last-of-type {
      transform: translate(0, calc(var(--translation-x) * -1)) rotate(-45deg);
    }
  </style>
`;

export class HamburgerButton extends HTMLElement {
  #shadowRoot;

  constructor() {
    super();

    this.#shadowRoot = this.attachShadow({ mode: 'open' });
    this.#shadowRoot.innerHTML = template;
  
    this.bars = this.shadowRoot.querySelectorAll(".bar");
    this.toggle = this.toggle.bind(this);
  }

  connectedCallback() {
    this.addEventListener("click", this.toggle);
  }
  disconnectedCallback() {
    this.addEventListener("click", this.toggle);
  }

  toggle() {
    this.toggleAttribute("active");

    const event = new CustomEvent('toggle', {
      detail: {
        active: this.hasAttribute("active")
      }
    });

    this.dispatchEvent(event);
  }
}

customElements.define('hamburger-button', HamburgerButton);</script><hamburger-button><template shadowrootmode="open"><!-- don't fold me  -->
  <div class="bar"></div>
  <div class="bar"></div>
  <div class="bar"></div>

  <style>
    :host {
      cursor: pointer;
  
      --_color: var(--color, black);
      --_width: var(--width, 2em);
      --_thickness: var(--thickness, 3px);
      --_spacing: var(--spacing, 7px);
      --_opacity: var(--opacity, 0.5);
  
      --translation-x: calc(var(--_thickness) + var(--_spacing));
    }
  
    .bar {
      width: var(--_width);
      height: var(--_thickness);
      background-color: var(--_color);
      margin: var(--_spacing) 0;
      opacity: var(--_opacity);
  
      will-change: transform, opacity;
      transition: 0.4s;
      transition-property: transform, opacity;
    }
  
    :host(:hover) .bar {
      opacity: 1;
    }
  
    :host([active]) .bar:first-of-type {
      transform: translate(0, var(--translation-x)) rotate(45deg);
    }
  
    :host([active]) .bar:nth-child(2) {
      opacity: 0;
    }
  
    :host([active]) .bar:last-of-type {
      transform: translate(0, calc(var(--translation-x) * -1)) rotate(-45deg);
    }
  </style>
</template></hamburger-button><nav class="amq-header full-width"><div><div class="internal-links"><a class="nav-link" href="#projects" onclick="closeHamburger();">Proyectos</a><a class="nav-link" href="#experiments" onclick="closeHamburger();">Experimentos</a><a class="nav-link" href="#blog" onclick="closeHamburger();"> Blog</a><a class="nav-link" href="#talks" onclick="closeHamburger();">Charlas</a><a class="nav-link" href="#career" onclick="closeHamburger();">Experiencia</a></div><div class="external-links"><a target="_blank" href="https://github.com/amatiasq"><svg aria-label="Github icon" width="32" height="32" viewBox="0 0 98 96" xmlns="http://www.w3.org/2000/svg">
    <path fill-rule="evenodd" clip-rule="evenodd"
        d="M48.854 0C21.839 0 0 22 0 49.217c0 21.756 13.993 40.172 33.405 46.69 2.427.49 3.316-1.059 3.316-2.362 0-1.141-.08-5.052-.08-9.127-13.59 2.934-16.42-5.867-16.42-5.867-2.184-5.704-5.42-7.17-5.42-7.17-4.448-3.015.324-3.015.324-3.015 4.934.326 7.523 5.052 7.523 5.052 4.367 7.496 11.404 5.378 14.235 4.074.404-3.178 1.699-5.378 3.074-6.6-10.839-1.141-22.243-5.378-22.243-24.283 0-5.378 1.94-9.778 5.014-13.2-.485-1.222-2.184-6.275.486-13.038 0 0 4.125-1.304 13.426 5.052a46.97 46.97 0 0 1 12.214-1.63c4.125 0 8.33.571 12.213 1.63 9.302-6.356 13.427-5.052 13.427-5.052 2.67 6.763.97 11.816.485 13.038 3.155 3.422 5.015 7.822 5.015 13.2 0 18.905-11.404 23.06-22.324 24.283 1.78 1.548 3.316 4.481 3.316 9.126 0 6.6-.08 11.897-.08 13.526 0 1.304.89 2.853 3.316 2.364 19.412-6.52 33.405-24.935 33.405-46.691C97.707 22 75.788 0 48.854 0z"
        fill="#fff">
    </path>
</svg></a><a target="_blank" href="https://www.linkedin.com/in/amatiasq/"><?xml version="1.0" encoding="utf-8"?>
<!-- Uploaded to: SVG Repo, www.svgrepo.com, Generator: SVG Repo Mixer Tools -->
<svg aria-label="LinkedIn Icon" width="32" height="32" viewBox="4 4 16 16" xmlns="http://www.w3.org/2000/svg">
    <path
        d="M18.72 3.99997H5.37C5.19793 3.99191 5.02595 4.01786 4.86392 4.07635C4.70189 4.13484 4.55299 4.22471 4.42573 4.34081C4.29848 4.45692 4.19537 4.59699 4.12232 4.75299C4.04927 4.909 4.0077 5.07788 4 5.24997V18.63C4.01008 18.9901 4.15766 19.3328 4.41243 19.5875C4.6672 19.8423 5.00984 19.9899 5.37 20H18.72C19.0701 19.9844 19.4002 19.8322 19.6395 19.5761C19.8788 19.32 20.0082 18.9804 20 18.63V5.24997C20.0029 5.08247 19.9715 4.91616 19.9078 4.76122C19.8441 4.60629 19.7494 4.466 19.6295 4.34895C19.5097 4.23191 19.3672 4.14059 19.2108 4.08058C19.0544 4.02057 18.8874 3.99314 18.72 3.99997ZM9 17.34H6.67V10.21H9V17.34ZM7.89 9.12997C7.72741 9.13564 7.5654 9.10762 7.41416 9.04768C7.26291 8.98774 7.12569 8.89717 7.01113 8.78166C6.89656 8.66615 6.80711 8.5282 6.74841 8.37647C6.6897 8.22474 6.66301 8.06251 6.67 7.89997C6.66281 7.73567 6.69004 7.57169 6.74995 7.41854C6.80986 7.26538 6.90112 7.12644 7.01787 7.01063C7.13463 6.89481 7.2743 6.80468 7.42793 6.74602C7.58157 6.68735 7.74577 6.66145 7.91 6.66997C8.07259 6.66431 8.2346 6.69232 8.38584 6.75226C8.53709 6.8122 8.67431 6.90277 8.78887 7.01828C8.90344 7.13379 8.99289 7.27174 9.05159 7.42347C9.1103 7.5752 9.13699 7.73743 9.13 7.89997C9.13719 8.06427 9.10996 8.22825 9.05005 8.3814C8.99014 8.53456 8.89888 8.6735 8.78213 8.78931C8.66537 8.90513 8.5257 8.99526 8.37207 9.05392C8.21843 9.11259 8.05423 9.13849 7.89 9.12997ZM17.34 17.34H15V13.44C15 12.51 14.67 11.87 13.84 11.87C13.5822 11.8722 13.3313 11.9541 13.1219 12.1045C12.9124 12.2549 12.7546 12.4664 12.67 12.71C12.605 12.8926 12.5778 13.0865 12.59 13.28V17.34H10.29V10.21H12.59V11.21C12.7945 10.8343 13.0988 10.5225 13.4694 10.3089C13.84 10.0954 14.2624 9.98848 14.69 9.99997C16.2 9.99997 17.34 11 17.34 13.13V17.34Z" />
</svg></a></div></div></nav><h1 class="article-title astro-4sgn5e7x">Rust</h1><ul class="tag-list md-tags astro-4sgn5e7x"></ul><article class="md astro-4sgn5e7x"><p>Decid√≠ probar <a href="https://www.rust-lang.org/">el lenguaje Rust</a> por varias razones:</p>
<ul>
<li><strong>WebAssembly</strong>: He estado buscando un lenguaje que me permita ejecutar c√≥digo eficiente en el navegador como WebAssembly y Javascript / Typescript no son buenos candidatos por el tipado d√©bil y el Colector de Basura (Garbage Collector).</li>
<li><strong>No hay Garbage Collector</strong>: hablando del GC, me gusta ejecutar <a href="https://amatiasq.com/projects/lulas/">simulaciones en la web</a> y el colector de basura tarde o temprano se convierte en un problema haciendoo la simulaci√≥n impredecible.</li>
<li><strong>Sistema de tipado</strong>: Tuve la suerte de aprender F# y me enamor√© de la forma en la que usa tipos, empiezas un programa definiendo los estados de la aplicaci√≥n en forma de tipos. La idea es muy buena pero todo eso se traduce a m√°s tipos que crear e instanciar en tiempo de ejecuci√≥n que a√±ade m√°s carga al colector de basura. El sistema de tipos de Rust toma las mejores ideas a la vez que elimina todos los tipos en tiempo de compilaci√≥n.</li>
<li><strong>Reputaci√≥n</strong>: Siguiendo las encuestas de la industria est√° claro que la gente que usa Rust encontr√≥ algo diferente en √©ste lenguaje, incluso <a href="https://www.zdnet.com/article/rust-in-the-linux-kernel-why-it-matters-and-whats-happening-next/">se est√° abriendo camino al kernel de Linux</a>.</li>
</ul>
<h2>El proyecto</h2>
<p>As√≠ que porqu√© no empezar con algo simple como <em>crear una aplicaci√≥n web que renderice un gr√°fico SVG</em>? üßë‚Äçüíª</p>
<p>Siguiendo <a href="https://www.youtube.com/playlist?list=PLZaoyhMXgBzoM9bfb5pyUOT3zjnaDdSEP">no boilerplate</a> encontr√© <a href="https://yew.rs/">Yew</a>, un framework para Rust inspirado en React:</p>
<pre><code class="hljs language-rs">[#function_component]
<span class="hljs-keyword">fn</span> <span class="hljs-title function_">MyComponent</span>(props: Props) {
  <span class="hljs-keyword">return</span> html!{
    &#x3C;div>{props.content}&#x3C;/div>
  };
}
</code></pre>
<p>Esto promete.</p>
<h2>Instalaci√≥n</h2>
<p>Para instalar Rust ejecut√© los siguientes comandos (para sistemas unix como Linux y Mac) como dicen en la <a href="https://yew.rs/docs/getting-started/introduction">documentaci√≥n de Yew</a></p>
<pre><code class="hljs language-bash"><span class="hljs-comment"># de https://rustup.rs/</span>
curl --proto <span class="hljs-string">'=https'</span> --tlsv1.2 -sSf https://sh.rustup.rs | sh

<span class="hljs-comment"># esto activa el comando rustup inmediatamente</span>
<span class="hljs-built_in">source</span> <span class="hljs-string">"<span class="hljs-variable">$HOME</span>/.cargo/env"</span>

<span class="hljs-comment"># instala algo sobre soporte para webassembly... creo</span>
rustup target add wasm32-unknown-unknown

<span class="hljs-comment">#¬†algunas dependencias que vamos a necesitar</span>
cargo install --locked trunk
cargo install cargo-generate
</code></pre>
<p>Entonces gener√© un proyecto con el comando <code>cargo generate</code></p>
<pre><code class="hljs language-bash">cargo generate --git https://github.com/yewstack/yew-trunk-minimal-template
</code></pre>
<h2>Primeras impresiones</h2>
<p>A primera vista el c√≥digo parece familiar,</p>
<pre><code class="hljs language-rs"><span class="hljs-comment">// main.rs</span>
<span class="hljs-keyword">mod</span> app;

<span class="hljs-keyword">use</span> app::App;

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
    yew::Renderer::&#x3C;App>::<span class="hljs-title function_ invoke__">new</span>().<span class="hljs-title function_ invoke__">render</span>();
}
</code></pre>
<pre><code class="hljs language-rs"><span class="hljs-comment">// app.rs</span>
<span class="hljs-keyword">use</span> yew::prelude::*;

<span class="hljs-meta">#[function_component(App)]</span>
<span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">app</span>() <span class="hljs-punctuation">-></span> Html {
    html! {
        &#x3C;main>
            &#x3C;img class=<span class="hljs-string">"logo"</span> src=<span class="hljs-string">"https://yew.rs/img/logo.png"</span> alt=<span class="hljs-string">"Yew logo"</span> />
            &#x3C;h1>{ <span class="hljs-string">"Hello World!"</span> }&#x3C;/h1>
            &#x3C;span class=<span class="hljs-string">"subtitle"</span>>{ <span class="hljs-string">"from Yew with "</span> }&#x3C;i class=<span class="hljs-string">"heart"</span> />&#x3C;/span>
        &#x3C;/main>
    }
}
</code></pre>
<p>Sintaxis estilo C, bastante similar a Typescript para ser honesto...</p>
<ul>
<li>el <code>#[loquesea]</code> parece atributos / decoradores</li>
<li>parece que <code>use algo</code> se usa para importar tipos y valores</li>
<li>me gusta lo ligera que es la sintaxis de funciones: <code>fn name() -> ReturnType</code></li>
<li>a √©stas alturas ya se que las funciones que terminan en <code>!</code>son meta-programaci√≥n, c√≥digo que genera c√≥digo en tiempo de compilaci√≥n</li>
</ul>
<p>Escuch√© en alg√∫n video que <strong>no poner punto y coma en la √∫ltima sentencia de un bloque es un <code>return</code> impl√≠cito</strong> as√≠ que <code>app()</code> devuelve el resultado de la macro <code>html!</code>.</p>
<h2>Primer archivo</h2>
<p>Los √∫nicos tipos personalizables de Rust son</p>
<h3><code>struct</code></h3>
<p>Es un contenedor de propiedades. Puede ser gen√©rico igual que en Typescript.</p>
<pre><code class="hljs language-rs"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyType</span>&#x3C;T> {
  a: T,
}

<span class="hljs-comment">// los m√©todos pueden a√±adirse despu√©s</span>
<span class="hljs-comment">// incluso pueden ser a√±adidos por m√≥dulos ajenos</span>
<span class="hljs-comment">// podemos tener multiples blockes impl para el mismo struct</span>
<span class="hljs-comment">// parecen no ser m√°s que funciones independientes</span>
<span class="hljs-comment">// con una sintaxis bonita para parecer m√©todos</span>
<span class="hljs-keyword">impl</span> <span class="hljs-title class_">MyType</span>&#x3C;T> {
  <span class="hljs-comment">// que hace &#x26; aqu√≠? a√∫n no lo s√© ü§∑</span>
  <span class="hljs-keyword">fn</span> <span class="hljs-title function_">myMethod</span>(&#x26;<span class="hljs-keyword">self</span>, x: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-></span> <span class="hljs-type">bool</span> { <span class="hljs-literal">true</span> }
}

<span class="hljs-comment">// los structs pueden ser tambien tuplas</span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Vector2</span>(<span class="hljs-type">i32</span>, <span class="hljs-type">i32</span>);

<span class="hljs-comment">// o incluso no tener items en absoluto!</span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Person</span>;
</code></pre>
<h3><code>enum</code></h3>
<p>Los enums son particularmente poderosos, definen tipos "uno de X" y cada opci√≥n puede tener valores dentro</p>
<pre><code class="hljs language-rs"><span class="hljs-comment">// este es parte de Rust</span>
<span class="hljs-keyword">enum</span> <span class="hljs-title class_">Option</span>&#x3C;T> {
  <span class="hljs-title function_ invoke__">Some</span>(T),
  <span class="hljs-literal">None</span>,
}

<span class="hljs-keyword">enum</span> <span class="hljs-title class_">Event</span> {
  Scroll,
  <span class="hljs-title function_ invoke__">KeyDown</span>(Key),
  Click { x: <span class="hljs-type">i32</span>, y: y32 },
}

<span class="hljs-comment">// si, pueden tener m√©todos tambi√©n ‚ù§Ô∏è</span>
<span class="hljs-keyword">impl</span> <span class="hljs-title class_">Event</span> {
  <span class="hljs-keyword">fn</span> <span class="hljs-title function_">something</span>(&#x26;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-></span> <span class="hljs-type">i32</span> { <span class="hljs-number">0</span> }
}
</code></pre>
<h3>De vuelta al proyecto</h3>
<p>No puedo esperar para definir el estado de mi aplicaci√≥n con tipos as√≠ que lo primero que hago es crear un archivo <code>types.rs</code> y crear un struct dentro, Github Copilot hace el resto por mi</p>
<pre><code class="hljs language-rs"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> {
  id: <span class="hljs-type">u64</span>, <span class="hljs-comment">// debi√≥ usar i32</span>
  node_type: NodeType,
  name: <span class="hljs-type">String</span>,
}

<span class="hljs-keyword">enum</span> <span class="hljs-title class_">NodeType</span> {
  Person,
  Place
}

<span class="hljs-comment">// error: los valores globales deben ser const x: Type</span>
<span class="hljs-comment">// pero no sabr√© eso por un rato</span>
<span class="hljs-keyword">let</span> <span class="hljs-variable">me</span> = Node {
  id: <span class="hljs-number">1</span>,
  node_type: NodeType::Person,
  name: <span class="hljs-string">"A. Mat√≠as Quezada"</span>,
}
</code></pre>
<p>Esto pinta bien, ahora vamos a importar este archivo y usar este valor pero... porqu√© "Ir a la definici√≥n" no funciona en VS Code?</p>
<h2>Integraci√≥n con el editor</h2>
<p>Cambio <code>main.rs</code> a un caso m√°s simple</p>
<pre><code class="hljs language-rs"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">test</span>() {}

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
    <span class="hljs-title function_ invoke__">test</span>();
}
</code></pre>
<p>Y no, VS Code no sabe donde encontrar la definici√≥n de <code>test</code> ü§¶. Se por <a href="https://youtu.be/ifaLk5v3W90">mis fuentes</a> que VS Code est√° integrado con Rust y he instalado un par de las extensiones m√°s populares as√≠ que porqu√© no funciona?</p>
<p>Resulta que la √∫nica extensi√≥n que necesitamos para trabajar con Rust es <code>rust-analyzer</code> y la tengo instalada e incluso la documentaci√≥n de <a href="https://code.visualstudio.com/docs/languages/rust">VS Code</a> dice que debe funcionar directamnete... Intent√© quitando las dem√°s extensiones de Rust, reiniciando VS Code, reiniciando la computadora, desactivando y re-activando la extensi√≥n y... espera! ahora funciona, y no se c√≥mo.</p>
<h2>Importando un archivo</h2>
<p>Bien, ahora vamos a importar ese archivo <code>types.rs</code>... debe ser algo como <code>use types::*</code>, cierto?</p>
<p><a href="https://doc.rust-lang.org/book/ch07-02-defining-modules-to-control-scope-and-privacy.html">Incorrecto!</a></p>
<p>Resulta que la palabra clave <code>use</code> solo crea un acceso directo (alias) para items ya existentes, no los importa.</p>
<p>Entonces para importar un archivo... vale, alguien en internet dice que debemos usar <code>mod nombre_de_archivo;</code> sin la extensi√≥n <code>.rs</code> pero eso no me funciona... vamos a respirar hondo.</p>
<pre><code class="hljs language-rs"><span class="hljs-comment">// main.rs</span>
<span class="hljs-comment">// en un archivo rust podemos definir un m√≥dulo interno</span>
<span class="hljs-keyword">mod</span> my_internal_module {
  <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">some_internal_function</span>() {}
}

my_internal_module::<span class="hljs-title function_ invoke__">some_internal_function</span>();
</code></pre>
<p>Y, en teor√≠a deber√≠amos ser capaces de mover el contenido de ese m√≥dulo a un archivo llamado <code>my_internal_module.rs</code> y cambiar la instrucci√≥n <code>mod</code> a <code>mod my_internal_module;</code> y eso deber√≠a funcionar, y lo hace... una vez.</p>
<p>Imaginemos la siguiente estructura de archivos:</p>
<pre><code class="hljs language-rs"><span class="hljs-comment">// src/main.rs</span>
<span class="hljs-keyword">mod</span> my_internal_module;

my_internal_module::<span class="hljs-title function_ invoke__">some_internal_function</span>();

<span class="hljs-comment">// src/my_internal_module.rs</span>
<span class="hljs-keyword">mod</span> another_module;

<span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">some_internal_function</span>() {
  another_module::<span class="hljs-title function_ invoke__">deepest_function</span>();
}

<span class="hljs-comment">// src/another_module.rs</span>
<span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">deepest_function</span>() {}
</code></pre>
<p>En este caso Rust busca <code>another_module</code> en <code>my_internal_module/another_module.rs</code>, aparentemente no podemos encadenar <code>mod</code>de esta forma. Aunque funciona si movemos todas las instrucciones <code>mod</code> al archivo <code>main.rs</code>.</p>
<pre><code class="hljs language-rs"><span class="hljs-comment">// src/main.rs</span>
<span class="hljs-keyword">mod</span> my_internal_module;
<span class="hljs-keyword">mod</span> another_module;

my_internal_module::<span class="hljs-title function_ invoke__">some_internal_function</span>();

<span class="hljs-comment">// src/my_internal_module.rs</span>
<span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">some_internal_function</span>() {
  another_module::<span class="hljs-title function_ invoke__">deepest_function</span>();
}

<span class="hljs-comment">// src/another_module.rs</span>
<span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">deepest_function</span>() {}
</code></pre>
<p>As√≠ que main se comporta como un √≠ndice y ra√≠z para importar archivos, supongo que tendr√© que tirar con esto hasta que aprenda m√°s. Termino <a href="https://github.com/amatiasq/learn-rust/blob/d69a056f1cb35723d504c48c58ee75fa51feecb1/src/main.rs#L1-L3">importando todos los archivos desde <code>main.rs</code></a>.</p>
<h2>Primeros errores</h2>
<h3>Feedback</h3>
<p>Mientras cambio el c√≥digo me doy cuenta que los errores no est√°n en el lugar correcto y solo se actualizan cuando guardo el archivo. Claro, este no es un lenguaje interpretado, es compilado as√≠ que necesita que guarde el archivo antes de intentar entender lo que he escrito (supongo). Al estar acostumbrado al feedback inmediato del ecosistema de Typescript esto me saca un poco de mi zona.</p>
<p>Tambi√©n parece que hay "capas" de errores, cuando resuelvo todos los errores del compilador un segundo tipo de errores aparecen inmediatamente por todo el c√≥digo y cuando los soluciono un mont√≥n de advertencias que no hab√≠an salido antes aparecen de pronto por todos lados.</p>
<p>Los errores son muy amables y explican exactamente d√≥nde ocurri√≥ el problema e incluso sugieren una soluci√≥n lo que es todo un detalle de parte del equipo del compilador de Rust.</p>
<h3>Valores globales</h3>
<p>Ahora que estoy importando archivos y tanto el compilador como el editor me muestran los errores veo que no puedo simplemente <code>let me = Node {...}</code> fuera de una funci√≥n. La forma correcta de hacer esto es con <code>const me: Node = Node {...}</code>. Porqu√© necesito escribir el tipo dos veces? no lo se, el compilador lo pidi√≥. Hay una forma de evitar eso? si encuentras la respuesta av√≠same.</p>
<h3>Strings are not <code>&#x26;str</code></h3>
<p>Ahora es cuando empiezo a encontrarme realmente perdido, en el struct <code>Node</code> declar√© la propiedad como <code>name: String</code> y cuando intento instanciar la struct con <code>name: "A. Mat√≠as Quezada"</code> soy inmediatamente abofeteado por el error: <code>expected String, found &#x26;str</code> <a href="https://youtu.be/1Z9yy0t2RGQ">WAT</a></p>
<pre><code> --> src/data.rs:6:11
  |
6 |     name: "A. Mat√≠as Quezada",
  |           ^^^^^^^^^^^^^^^^^^^- help: try using a conversion method: `.to_string()`
  |           |
  |           expected struct `String`, found `&#x26;str`
</code></pre>
<p>Copilot hab√≠a a√±adido <code>.to_string()</code> justo ah√≠ y lo borr√© porque pens√© que era redundante, pero oye, estamos aqu√≠ para aprender. Lo cambi√© a<code>name: "A. Mat√≠as Quezada".to_string()</code> de vuelta y pinta bien, todas las dem√°s strings del archivo siguen dando error pero guard√© el archivo y <em>esta l√≠nea</em> ya no da error. Procedo a a√±adir <code>.to_string()</code> a todos los dem√°s strings en el archivo, guardo y...</p>
<pre><code>error[E0015]: cannot call non-const fn `&#x3C;str as ToString>::to_string` in constants
 --> src/data.rs:6:31
  |
6 |     name: "A. Mat√≠as Quezada".to_string(),
</code></pre>
<p>Vale... No se que hacer ahora... y si... solo...</p>
<pre><code class="hljs language-rs"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> {
    id: <span class="hljs-type">u64</span>,
    node_type: NodeType,
    <span class="hljs-comment">// name: String,</span>
    name: &#x26;<span class="hljs-type">str</span>,
}
</code></pre>
<p>ü§û</p>
<pre><code>error[E0106]: missing lifetime specifier
  --> src/types.rs:19:15
   |
19 |     name: &#x26;str,
   |               ^ expected named lifetime parameter
   |
help: consider introducing a named lifetime parameter
   |
16 ~ struct Node&#x3C;'a> {
17 |     id: u64,
18 |     node_type: NodeType,
19 ~     name: &#x26;'a str,
   |

For more information about this error, try `rustc --explain E0106`.
</code></pre>
<p>Bueno, al menos me est√° diciendo que tengo que hacer, verdad? Solo tengo que a√±adir un... named lifetime parameter?... lo que sea eso.</p>
<pre><code class="hljs language-rs"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>&#x3C;<span class="hljs-symbol">'a</span>> {
    id: <span class="hljs-type">u64</span>,
    node_type: NodeType,
    <span class="hljs-comment">// name: String,</span>
    name: &#x26;<span class="hljs-symbol">'a</span> <span class="hljs-type">str</span>,
}
</code></pre>
<p>Vale esto no puede estar bien, vamos a guardar y ver...</p>
<pre><code>error[E0106]: missing lifetime specifier
  --> src/types.rs:30:20
   |
30 |     nodes: Vec&#x3C;Node>,
   |                    ^^^^ expected named lifetime parameter
   |
help: consider introducing a named lifetime parameter
   |
29 ~ struct Graph&#x3C;'a> {
30 ~     nodes: Vec&#x3C;Node&#x3C;'a>>,
   |

For more information about this error, try `rustc --explain E0106`.
</code></pre>
<p>Hm... vale, puedo hacer eso, tambi√©n tengo una funci√≥n <code>create_graph()</code> que probablemente necesite ser actualizada:</p>
<pre><code class="hljs language-rs"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">create_graph</span>&#x3C;<span class="hljs-symbol">'a</span>>() <span class="hljs-punctuation">-></span> Graph&#x3C;<span class="hljs-symbol">'a</span>> {
  Graph {
    nodes: <span class="hljs-built_in">vec!</span>[me]
  }
}
</code></pre>
<p>Bueno <a href="https://github.com/amatiasq/learn-rust/commit/1c9f5b740638eac27222a204fbec455e2cd6544a">hice algo!</a>.</p>
<h2>Notas finales</h2>
<ul>
<li>A primera vista Rust parece simple y familiar</li>
<li>Los errores del compilador son tan buenos como dicen</li>
<li>No hay <code>null</code>, es as√≠ de simple</li>
<li>La estructura de archivo se ve familiar viniendo de javascript, a primer nivel tenemos funciones exportadas y, opcionalmente, clases</li>
<li>El el c√≥digo es breve pero con muchos s√≠mbolos, no soy fan de <code>::</code> y <code>&#x26;</code> por todos lados y encontr√© <code>&#x3C;'a></code>  dif√≠cil de teclear</li>
<li>Rust no permite crear l√≥gica fuera de una funci√≥n y los valores global siguen reglas especiales: tienen que ser <code>const</code> o <code>static</code> (este √∫ltimo es mutable)</li>
<li>El lenguaje Rust es bastante fino y depende de librer√≠as para la mayor√≠a de comportamientos avanzados (async/await, http, threading...)</li>
<li>La forma de definir m√©todos es perfecta, similar a los extension methods de C#, permiten extender una clase de terceros sin tener acceso al c√≥digo</li>
<li>El archivo generado no contiene tipos, repito, el binario no sabe nada sobre tipos. Los tipos son solo una herramienta para el humano y el compilador</li>
<li>Hay muchas cosas sobre <code>lifecycle</code> que escapan mi entendimiento pero parece que podemos usar algo parecido a tipos gen√©ricos para recibir (de qui√©n llama a la funci√≥n) cu√°nto tiempo debe una variable permanecer en la memoria</li>
<li>Un <code>crate</code> es una unidad de compilaci√≥n, imag√≠nalo como una DLL, una aplicaci√≥n puede contener varios crates</li>
<li>La siguiente parada es <a href="https://doc.rust-lang.org/book/">Rust book</a></li>
</ul>
<p>Sobre funciones del lenguaje:</p>
<ul>
<li>Me encanta el sistema de macros que nos da maravillas como las listas <code>vec![1,2,3]</code></li>
<li><code>mod</code> puede ser usado para crear un m√≥dulo interno de un archivo o para cargar un archivo desde <code>main.rs</code></li>
<li><code>use</code> crea alias de namespaces y permite m√∫ltiples valores o <code>*</code>: <code>use namespace::module::{A,B,C}</code></li>
<li>Parece que hay varios tipos de strings: <code>String</code>, <code>&#x26;str</code>, m√°s?</li>
<li>El sistema de tipos es la mejor parte, me encanta que <code>struct</code> pueda ser una tupla o no contener ning√∫n item</li>
<li>No estoy seguro pero creo que las ramas de un <code>enum</code> son en realidad structs</li>
</ul>
<pre><code class="hljs language-rs"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyStruct1</span> { x: <span class="hljs-type">i32</span> }
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyStruct2</span>(<span class="hljs-type">i32</span>);
<span class="hljs-comment">// esto es como una interfaz</span>
<span class="hljs-comment">// sin miembros</span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyStruct3</span>;

<span class="hljs-keyword">enum</span> <span class="hljs-title class_">MyEnum</span> {
  <span class="hljs-comment">// exactamente el mismo c√≥digo</span>
  <span class="hljs-comment">// sin la palabra clave `struct`</span>
  MyStruct1 { x: <span class="hljs-type">i32</span> },
  <span class="hljs-title function_ invoke__">MyStruct2</span>(<span class="hljs-type">i32</span>),
  MyStruct3,
}
</code></pre>
<p>Quiz√°s deb√≠ empezar con un proyecto con el que est√© m√°s familiarizado... alguien dijo Lulas v38.0?</p>
<p>Come m√°s verduras</p></article></body></html>