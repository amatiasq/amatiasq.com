---
title: Rust
---

I've decided to try [rust language](https://www.rust-lang.org/) for several reasons:

- __WebAssembly__: I've been looking for a language that allows me to run performant code in the browser as WebAssembly and Javascript / Typescript are not good fit for the case because of the weak typing system and the Garbage Collector.
- __No garbage collector__: talking about GC, I love to run [simulations on the web](https://amatiasq.com/projects/lulas/) and garbage collector eventually becomes an issue by making the simulation unpredictable
- __Type system__: I was lucky enough to get to know F# and fell in love with it's way to use types, you start a program by defining the states of the application in it's type system. The root idea is really good but all of that translates to more types to create and instantiate at runtime which will also put more load on the Garbage Collector. Rust's type system takes the best ideas from it while removing all types at runtime.
- __Reputation__: Following the public surveys on the industry it's clear that people that use Rust have found something different in this language, it's even [getting into the Linux kernel](https://www.zdnet.com/article/rust-in-the-linux-kernel-why-it-matters-and-whats-happening-next/).

## The project

So why not start with something simple like _creating a web application that renders a graph in SVG_? üßë‚Äçüíª

Following [no boilerplate](https://www.youtube.com/playlist?list=PLZaoyhMXgBzoM9bfb5pyUOT3zjnaDdSEP) I found [Yew](https://yew.rs/), a React-like framework for rust:

```rs
[#function_component]
fn MyComponent(props: Props) {
  return html!{
    <div>{props.content}</div>
  };
}
```

Well this looks promising.

## Installation

To install Rust I ran the following commands (for unix systems like Linux and Mac) as stated in [Yew's documentation](https://yew.rs/docs/getting-started/introduction)

```bash
# from https://rustup.rs/
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh

# this enables rustup command immediately
source "$HOME/.cargo/env"

# install something about webassembly support... I guess
rustup target add wasm32-unknown-unknown

# some dependencies we're going to need
cargo install --locked trunk
cargo install cargo-generate
```

Then generated a new project with `cargo generate` command

```bash
cargo generate --git https://github.com/yewstack/yew-trunk-minimal-template
```

## First impressions

At first glance the code looks familiar,

```rs
// main.rs
mod app;

use app::App;

fn main() {
    yew::Renderer::<App>::new().render();
}
```

```rs
// app.rs
use yew::prelude::*;

#[function_component(App)]
pub fn app() -> Html {
    html! {
        <main>
            <img class="logo" src="https://yew.rs/img/logo.png" alt="Yew logo" />
            <h1>{ "Hello World!" }</h1>
            <span class="subtitle">{ "from Yew with " }<i class="heart" /></span>
        </main>
    }
}
```

C-like syntax, quite similar to Typescript to be honest...

- the `#[something]` look like attribute / decorators
- looks like `use something` is used to import types and values
- I like how light the function syntax is by requesting just `fn name() -> ReturnType`
- By now I know that functions ending with `!` are meta-programming, code generating code at compile-time

I heard in some video that __not having semicolon in the last statement of a block is implicit return__ so `app()` is returning the result of the `html!` macro.

## First file

Only custom types in Rust are

### `struct`
This is a container of properties of a given type. It can be generic exactly like Typescript.

```rs
struct MyType<T> {
  a: T,
}

// methods can be added later
// they can even be added by third-party modules
// we can have multiple impl blocks for the same struct
// they look like nothing more than stand-alone functions
// with nice syntax-sugar to look like methods
impl MyType<T> {
  // what does & do here? I don't know yet ü§∑
  fn myMethod(&self, x: i32) -> bool { true }
}

// structs can also be tuples
struct Vector2(i32, i32);

// or even have no items at all
struct Person;
```

### `enum`

Enums are particularly powerful, they define a "one of" type and each entry can have values inside

```rs
// this one is part of Rust
enum Option<T> {
  Some(T),
  None,
}

enum Event {
  Scroll,
  KeyDown(Key),
  Click { x: i32, y: y32 },
}

// yep, they can have methods too ‚ù§Ô∏è
impl Event {
  fn something(&self) -> i32 { 0 }
}
```


### Back to the project

I can't wait to define my application's state with types so first thing I do is create a new file `types.rs` and create a struct inside, Github Copilot takes the rest for me

```rs
struct Node {
  id: u64, // should have used i32
  node_type: NodeType,
  name: String,
}

enum NodeType {
  Person,
  Place
}

// error: global values have to be const x: Type
// but I won't know that for a while
let me = Node {
  id: 1,
  node_type: NodeType::Person,
  name: "A. Mat√≠as Quezada",
}
```

That looks good, now let's import this file and use this value but... why is VS Code "Go to definition" not working?

## Editor integration

I change `main.rs` to a simple case

```rs
fn test() {}

fn main() {
    test();
}
```

And no, VS Code doesn't know where to find `test` definition ü§¶. I know from [my source material](https://youtu.be/ifaLk5v3W90) that VS Code is integrated with Rust and I've installed a few of the most popular Rust extensions so why is this not working?

Turns out the only extension we need to work with Rust is `rust-analyzer` and I have it installed and even [VS Code](https://code.visualstudio.com/docs/languages/rust) documentation says it should work out of the box... Tried removing any other Rust extension I had, restarting VS Code, restarting the computer, disabling and re-enabling the extension and... wait! it works now, I don't know how.

## Importing a file

Ok now let's import that `types.rs` file... it should be something like `use types::*`, right?

[Wrong!](https://doc.rust-lang.org/book/ch07-02-defining-modules-to-control-scope-and-privacy.html)

Turns out `use` keyword only creates shortcuts (aliases) for existing items, it doesn't import them.

So to import a file... ok someone on the internet says you should use `mod filename;` without the `.rs` extension but that's not working for me... ok let's breath deeply.

```rs
// main.rs
// in a rust file we can define an inner module
mod my_internal_module {
  pub fn some_internal_function() {}
}

my_internal_module::some_internal_function();
```

And, in theory we should be able to move the content of that module to a file called `my_internal_module.rs` and change the `mod` instruction to `mod my_internal_module;` and that should work, and it does... once.

Consider the following file structure:

```rs
// src/main.rs
mod my_internal_module;

my_internal_module::some_internal_function();

// src/my_internal_module.rs
mod another_module;

pub fn some_internal_function() {
  another_module::deepest_function();
}

// src/another_module.rs
pub fn deepest_function() {}
```

In this case Rust looks up `another_module` in `my_internal_module/another_module.rs`, apparently we can't chain `mod` imports this way. It works if we move all `mod` instructions to the `main.rs` file though.

```rs
// src/main.rs
mod my_internal_module;
mod another_module;

my_internal_module::some_internal_function();

// src/my_internal_module.rs
pub fn some_internal_function() {
  another_module::deepest_function();
}

// src/another_module.rs
pub fn deepest_function() {}
```

So main behaves like an index file and root for imported files, I guess I'll have to go with this until I learn more. I ended up [importing all files from `main.rs`](https://github.com/amatiasq/learn-rust/blob/d69a056f1cb35723d504c48c58ee75fa51feecb1/src/main.rs#L1-L3).

## First errors

### Error feedback

As I'm changing the code I notice the errors aren't in the right place and only update when I save the file. Of course, this is not an interpreted language, it's a copiled one so it needs me to save before it tries to understand what I wrote (I suppose). Being used to the rapid feedback of the Typescript ecosystem this breaks my flow a bit.

Also looks like there are "layers" of errors, when I solve all of the compiler errors a second kind of errors pup up immediately all over the codebase and when I address those a bunch of warnings that haven't shown before suddently fill the place.

The errors are really kind and explain exactly where the issue happened and even suggest a solution for it which is a lovely detail from the Rust compiler team.

### Global values

Now that I'm importing the files and both the compiler and the editor are showing me the errors I see I can't just `let me = Node {...}` outside a function. The correct way to do this is with `const me: Node = Node {...}`. Why do I need to type the type name twice? I don't know, the compiler asked for it. Is there a way to avoid that? let me know if you find the answer.

### Strings are not `&str`

Now is where I start to get really lost, in `Node` struct I typed the property as `name: String` and when I try to instatiate the struct with `name: "A. Mat√≠as Quezada"` I'm immediately slapped by the error: `expected String, found &str` [WAT](https://youtu.be/1Z9yy0t2RGQ)

```
 --> src/data.rs:6:11
  |
6 |     name: "A. Mat√≠as Quezada",
  |           ^^^^^^^^^^^^^^^^^^^- help: try using a conversion method: `.to_string()`
  |           |
  |           expected struct `String`, found `&str`
```

Copilot had added `.to_string()` at the end of it and I removed it because I considered it redundant but, hey! we're here to learn. I change it back to `name: "A. Mat√≠as Quezada".to_string()` and it looks good, all other strings still fail but I save the file and no error is thrown in _this line_. I prompty add `.to_string()` to all other strings in the file, save aaaaaaaand...

```
error[E0015]: cannot call non-const fn `<str as ToString>::to_string` in constants
 --> src/data.rs:6:31
  |
6 |     name: "A. Mat√≠as Quezada".to_string(),
```

Ok... I don't know what to do now... what if... I just...

```rs
struct Node {
    id: u64,
    node_type: NodeType,
    // name: String,
    name: &str,
}
```

ü§û

```
error[E0106]: missing lifetime specifier
  --> src/types.rs:19:15
   |
19 |     name: &str,
   |               ^ expected named lifetime parameter
   |
help: consider introducing a named lifetime parameter
   |
16 ~ struct Node<'a> {
17 |     id: u64,
18 |     node_type: NodeType,
19 ~     name: &'a str,
   |

For more information about this error, try `rustc --explain E0106`.
```

Well at least it's telling me what to do, right? I just need to add a... named lifetime? parameter... whatever it is.

```rs
struct Node<'a> {
    id: u64,
    node_type: NodeType,
    // name: String,
    name: &'a str,
}
```

Ok this can't be right, let's save and see...

```
error[E0106]: missing lifetime specifier
  --> src/types.rs:30:20
   |
30 |     nodes: Vec<Node>,
   |                    ^^^^ expected named lifetime parameter
   |
help: consider introducing a named lifetime parameter
   |
29 ~ struct Graph<'a> {
30 ~     nodes: Vec<Node<'a>>,
   |

For more information about this error, try `rustc --explain E0106`.
```

Hm... ok I can do that, I also have a `create_graph()` function that probably needs to be updated:

```rs
fn create_graph<'a>() -> Graph<'a> {
  Graph {
    nodes: vec![me]
  }
}
```

Well [I did something!](https://github.com/amatiasq/learn-rust/commit/1c9f5b740638eac27222a204fbec455e2cd6544a).

---

Decid√≠ probar [el lenguaje Rust](https://www.rust-lang.org/) por varias razones:

- __WebAssembly__: He estado buscando un lenguaje que me permita ejecutar c√≥digo eficiente en el navegador como WebAssembly y Javascript / Typescript no son buenos candidatos por el tipado d√©bil y el Colector de Basura (Garbage Collector).
- __No hay Garbage Collector__: hablando del GC, me gusta ejecutar [simulaciones en la web](https://amatiasq.com/projects/lulas/) y el colector de basura tarde o temprano se convierte en un problema haciendoo la simulaci√≥n impredecible.
- __Sistema de tipado__: Tuve la suerte de aprender F# y me enamor√© de la forma en la que usa tipos, empiezas un programa definiendo los estados de la aplicaci√≥n en forma de tipos. La idea es muy buena pero todo eso se traduce a m√°s tipos que crear e instanciar en tiempo de ejecuci√≥n que a√±ade m√°s carga al colector de basura. El sistema de tipos de Rust toma las mejores ideas a la vez que elimina todos los tipos en tiempo de compilaci√≥n.
- __Reputaci√≥n__: Siguiendo las encuestas de la industria est√° claro que la gente que usa Rust encontr√≥ algo diferente en √©ste lenguaje, incluso [se est√° abriendo camino al kernel de Linux](https://www.zdnet.com/article/rust-in-the-linux-kernel-why-it-matters-and-whats-happening-next/).

## El proyecto

As√≠ que porqu√© no empezar con algo simple como _crear una aplicaci√≥n web que renderice un gr√°fico SVG_? üßë‚Äçüíª

Siguiendo [no boilerplate](https://www.youtube.com/playlist?list=PLZaoyhMXgBzoM9bfb5pyUOT3zjnaDdSEP) encontr√© [Yew](https://yew.rs/), un framework para Rust inspirado en React:

```rs
[#function_component]
fn MyComponent(props: Props) {
  return html!{
    <div>{props.content}</div>
  };
}
```

Esto promete.

## Instalaci√≥n

Para instalar Rust ejecut√© los siguientes comandos (para sistemas unix como Linux y Mac) como dicen en la [documentaci√≥n de Yew](https://yew.rs/docs/getting-started/introduction)

```bash
# de https://rustup.rs/
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh

# esto activa el comando rustup inmediatamente
source "$HOME/.cargo/env"

# instala algo sobre soporte para webassembly... creo
rustup target add wasm32-unknown-unknown

#¬†algunas dependencias que vamos a necesitar
cargo install --locked trunk
cargo install cargo-generate
```

Entonces gener√© un proyecto con el comando `cargo generate`

```bash
cargo generate --git https://github.com/yewstack/yew-trunk-minimal-template
```

## Primeras impresiones

A primera vista el c√≥digo parece familiar,

```rs
// main.rs
mod app;

use app::App;

fn main() {
    yew::Renderer::<App>::new().render();
}
```

```rs
// app.rs
use yew::prelude::*;

#[function_component(App)]
pub fn app() -> Html {
    html! {
        <main>
            <img class="logo" src="https://yew.rs/img/logo.png" alt="Yew logo" />
            <h1>{ "Hello World!" }</h1>
            <span class="subtitle">{ "from Yew with " }<i class="heart" /></span>
        </main>
    }
}
```

Sintaxis estilo C, bastante similar a Typescript para ser honesto...

- el `#[loquesea]` parece atributos / decoradores
- parece que `use algo` se usa para importar tipos y valores
- me gusta lo ligera que es la sintaxis de funciones: `fn name() -> ReturnType`
- a √©stas alturas ya se que las funciones que terminan en `!`son meta-programaci√≥n, c√≥digo que genera c√≥digo en tiempo de compilaci√≥n

Escuch√© en alg√∫n video que __no poner punto y coma en la √∫ltima sentencia de un bloque es un `return` impl√≠cito__ as√≠ que `app()` devuelve el resultado de la macro `html!`.

## Primer archivo

Los √∫nicos tipos personalizables de Rust son

### `struct`
Es un contenedor de propiedades. Puede ser gen√©rico igual que en Typescript.

```rs
struct MyType<T> {
  a: T,
}

// los m√©todos pueden a√±adirse despu√©s
// incluso pueden ser a√±adidos por m√≥dulos ajenos
// podemos tener multiples blockes impl para el mismo struct
// parecen no ser m√°s que funciones independientes
// con una sintaxis bonita para parecer m√©todos
impl MyType<T> {
  // que hace & aqu√≠? a√∫n no lo s√© ü§∑
  fn myMethod(&self, x: i32) -> bool { true }
}

// los structs pueden ser tambien tuplas
struct Vector2(i32, i32);

// o incluso no tener items en absoluto!
struct Person;
```

### `enum`

Los enums son particularmente poderosos, definen tipos "uno de X" y cada opci√≥n puede tener valores dentro

```rs
// este es parte de Rust
enum Option<T> {
  Some(T),
  None,
}

enum Event {
  Scroll,
  KeyDown(Key),
  Click { x: i32, y: y32 },
}

// si, pueden tener m√©todos tambi√©n ‚ù§Ô∏è
impl Event {
  fn something(&self) -> i32 { 0 }
}
```

### De vuelta al proyecto

No puedo esperar para definir el estado de mi aplicaci√≥n con tipos as√≠ que lo primero que hago es crear un archivo `types.rs` y crear un struct dentro, Github Copilot hace el resto por mi

```rs
struct Node {
  id: u64, // debi√≥ usar i32
  node_type: NodeType,
  name: String,
}

enum NodeType {
  Person,
  Place
}

// error: los valores globales deben ser const x: Type
// pero no sabr√© eso por un rato
let me = Node {
  id: 1,
  node_type: NodeType::Person,
  name: "A. Mat√≠as Quezada",
}
```

Esto pinta bien, ahora vamos a importar este archivo y usar este valor pero... porqu√© "Ir a la definici√≥n" no funciona en VS Code?

## Integraci√≥n con el editor

Cambio `main.rs` a un caso m√°s simple

```rs
fn test() {}

fn main() {
    test();
}
```

Y no, VS Code no sabe donde encontrar la definici√≥n de `test` ü§¶. Se por [mis fuentes](https://youtu.be/ifaLk5v3W90) que VS Code est√° integrado con Rust y he instalado un par de las extensiones m√°s populares as√≠ que porqu√© no funciona?

Resulta que la √∫nica extensi√≥n que necesitamos para trabajar con Rust es `rust-analyzer` y la tengo instalada e incluso la documentaci√≥n de [VS Code](https://code.visualstudio.com/docs/languages/rust) dice que debe funcionar directamnete... Intent√© quitando las dem√°s extensiones de Rust, reiniciando VS Code, reiniciando la computadora, desactivando y re-activando la extensi√≥n y... espera! ahora funciona, y no se c√≥mo.

## Importando un archivo

Bien, ahora vamos a importar ese archivo `types.rs`... debe ser algo como `use types::*`, cierto?

[Incorrecto!](https://doc.rust-lang.org/book/ch07-02-defining-modules-to-control-scope-and-privacy.html)

Resulta que la palabra clave `use` solo crea un acceso directo (alias) para items ya existentes, no los importa.

Entonces para importar un archivo... vale, alguien en internet dice que debemos usar `mod nombre_de_archivo;` sin la extensi√≥n `.rs` pero eso no me funciona... vamos a respirar hondo.

```rs
// main.rs
// en un archivo rust podemos definir un m√≥dulo interno
mod my_internal_module {
  pub fn some_internal_function() {}
}

my_internal_module::some_internal_function();
```

Y, en teor√≠a deber√≠amos ser capaces de mover el contenido de ese m√≥dulo a un archivo llamado `my_internal_module.rs` y cambiar la instrucci√≥n `mod` a `mod my_internal_module;` y eso deber√≠a funcionar, y lo hace... una vez.

Imaginemos la siguiente estructura de archivos:

```rs
// src/main.rs
mod my_internal_module;

my_internal_module::some_internal_function();

// src/my_internal_module.rs
mod another_module;

pub fn some_internal_function() {
  another_module::deepest_function();
}

// src/another_module.rs
pub fn deepest_function() {}
```

En este caso Rust busca `another_module` en `my_internal_module/another_module.rs`, aparentemente no podemos encadenar `mod`de esta forma. Aunque funciona si movemos todas las instrucciones `mod` al archivo `main.rs`.

```rs
// src/main.rs
mod my_internal_module;
mod another_module;

my_internal_module::some_internal_function();

// src/my_internal_module.rs
pub fn some_internal_function() {
  another_module::deepest_function();
}

// src/another_module.rs
pub fn deepest_function() {}
```

As√≠ que main se comporta como un √≠ndice y ra√≠z para importar archivos, supongo que tendr√© que tirar con esto hasta que aprenda m√°s. Termino [importando todos los archivos desde `main.rs`](https://github.com/amatiasq/learn-rust/blob/d69a056f1cb35723d504c48c58ee75fa51feecb1/src/main.rs#L1-L3).

## Primeros errores

### Feedback

Mientras cambio el c√≥digo me doy cuenta que los errores no est√°n en el lugar correcto y solo se actualizan cuando guardo el archivo. Claro, este no es un lenguaje interpretado, es compilado as√≠ que necesita que guarde el archivo antes de intentar entender lo que he escrito (supongo). Al estar acostumbrado al feedback inmediato del ecosistema de Typescript esto me saca un poco de mi zona.

Tambi√©n parece que hay "capas" de errores, cuando resuelvo todos los errores del compilador un segundo tipo de errores aparecen inmediatamente por todo el c√≥digo y cuando los soluciono un mont√≥n de advertencias que no hab√≠an salido antes aparecen de pronto por todos lados.

Los errores son muy amables y explican exactamente d√≥nde ocurri√≥ el problema e incluso sugieren una soluci√≥n lo que es todo un detalle de parte del equipo del compilador de Rust.

### Valores globales

Ahora que estoy importando archivos y tanto el compilador como el editor me muestran los errores veo que no puedo simplemente `let me = Node {...}` fuera de una funci√≥n. La forma correcta de hacer esto es con `const me: Node = Node {...}`. Porqu√© necesito escribir el tipo dos veces? no lo se, el compilador lo pidi√≥. Hay una forma de evitar eso? si encuentras la respuesta av√≠same.

### Strings are not `&str`

Ahora es cuando empiezo a encontrarme realmente perdido, en el struct `Node` declar√© la propiedad como `name: String` y cuando intento instanciar la struct con `name: "A. Mat√≠as Quezada"` soy inmediatamente abofeteado por el error: `expected String, found &str` [WAT](https://youtu.be/1Z9yy0t2RGQ)

```
 --> src/data.rs:6:11
  |
6 |     name: "A. Mat√≠as Quezada",
  |           ^^^^^^^^^^^^^^^^^^^- help: try using a conversion method: `.to_string()`
  |           |
  |           expected struct `String`, found `&str`
```

Copilot hab√≠a a√±adido `.to_string()` justo ah√≠ y lo borr√© porque pens√© que era redundante, pero oye, estamos aqu√≠ para aprender. Lo cambi√© a`name: "A. Mat√≠as Quezada".to_string()` de vuelta y pinta bien, todas las dem√°s strings del archivo siguen dando error pero guard√© el archivo y _esta l√≠nea_ ya no da error. Procedo a a√±adir `.to_string()` a todos los dem√°s strings en el archivo, guardo y...

```
error[E0015]: cannot call non-const fn `<str as ToString>::to_string` in constants
 --> src/data.rs:6:31
  |
6 |     name: "A. Mat√≠as Quezada".to_string(),
```

Vale... No se que hacer ahora... y si... solo...

```rs
struct Node {
    id: u64,
    node_type: NodeType,
    // name: String,
    name: &str,
}
```

ü§û

```
error[E0106]: missing lifetime specifier
  --> src/types.rs:19:15
   |
19 |     name: &str,
   |               ^ expected named lifetime parameter
   |
help: consider introducing a named lifetime parameter
   |
16 ~ struct Node<'a> {
17 |     id: u64,
18 |     node_type: NodeType,
19 ~     name: &'a str,
   |

For more information about this error, try `rustc --explain E0106`.
```

Bueno, al menos me est√° diciendo que tengo que hacer, verdad? Solo tengo que a√±adir un... named lifetime parameter?... lo que sea eso.

```rs
struct Node<'a> {
    id: u64,
    node_type: NodeType,
    // name: String,
    name: &'a str,
}
```

Vale esto no puede estar bien, vamos a guardar y ver...

```
error[E0106]: missing lifetime specifier
  --> src/types.rs:30:20
   |
30 |     nodes: Vec<Node>,
   |                    ^^^^ expected named lifetime parameter
   |
help: consider introducing a named lifetime parameter
   |
29 ~ struct Graph<'a> {
30 ~     nodes: Vec<Node<'a>>,
   |

For more information about this error, try `rustc --explain E0106`.
```

Hm... vale, puedo hacer eso, tambi√©n tengo una funci√≥n `create_graph()` que probablemente necesite ser actualizada:

```rs
fn create_graph<'a>() -> Graph<'a> {
  Graph {
    nodes: vec![me]
  }
}
```

Bueno [hice algo!](https://github.com/amatiasq/learn-rust/commit/1c9f5b740638eac27222a204fbec455e2cd6544a).
