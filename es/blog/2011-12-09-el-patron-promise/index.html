<!DOCTYPE html><html lang="es"><head><meta charSet="UTF-8"/><meta name="description" content="A. Matías Quezada&#x27;s personal website"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>El patrón Promise | A. Matías Quezada</title><style> *, ::before, ::after { box-sizing: border-box; } html { line-sizing: normal; } body { margin: 0; } [hidden] { display: none; } h1 { font-size: 2rem; } h2 { font-size: 1.5rem; } h3 { font-size: 1.17rem; } h4 { font-size: 1.00rem; } h5 { font-size: 0.83rem; } h6 { font-size: 0.67rem; } h1 { margin: 0.67em 0; } pre { white-space: pre-wrap; } hr { border-style: solid; border-width: 1px 0 0; color: inherit; height: 0; overflow: visible; } img, svg, video, canvas, audio, iframe, embed, object { display: block; vertical-align: middle; max-width: 100%; } audio:not([controls]) { display:none; } picture { display: contents; } source { display: none; } img, svg, video, canvas { height: auto; } audio { width: 100%; } img { border-style: none; } svg { overflow: hidden; } article, aside, details, figcaption, figure, footer, header, hgroup, main, nav, section { display: block; } [type='checkbox'], [type='radio'] { box-sizing: border-box; padding: 0; } @media (prefers-reduced-motion: reduce) { *, ::before, ::after { animation-name: none !important; transition: none !important; } } </style><style>@font-face { font-family: 'Inconsolata'; font-style: normal; font-weight: 400; font-stretch: normal; font-display: swap; src: url(https://fonts.gstatic.com/s/inconsolata/v31/QldgNThLqRwH-OJ1UHjlKENVzkWGVkL3GZQmAwLYxYWI2qfdm7Lpp4U8aRo.ttf) format('truetype'); } @font-face { font-family: 'Inconsolata'; font-style: normal; font-weight: 700; font-stretch: normal; font-display: swap; src: url(https://fonts.gstatic.com/s/inconsolata/v31/QldgNThLqRwH-OJ1UHjlKENVzkWGVkL3GZQmAwLYxYWI2qfdm7Lpp2I7aRo.ttf) format('truetype'); } @font-face { font-family: 'Nunito'; font-style: normal; font-weight: 400; font-display: swap; src: url(https://fonts.gstatic.com/s/nunito/v24/XRXI3I6Li01BKofiOc5wtlZ2di8HDLshRTM.ttf) format('truetype'); } @font-face { font-family: 'Nunito'; font-style: normal; font-weight: 700; font-display: swap; src: url(https://fonts.gstatic.com/s/nunito/v24/XRXI3I6Li01BKofiOc5wtlZ2di8HDFwmRTM.ttf) format('truetype'); } @font-face { font-family: 'Nunito Sans'; font-style: normal; font-weight: 400; font-display: swap; src: url(https://fonts.gstatic.com/s/nunitosans/v12/pe0qMImSLYBIv1o4X1M8cfe6.ttf) format('truetype'); } @font-face { font-family: 'Nunito Sans'; font-style: normal; font-weight: 700; font-display: swap; src: url(https://fonts.gstatic.com/s/nunitosans/v12/pe03MImSLYBIv1o4X1M8cc8GBv5q.ttf) format('truetype'); } </style><style> :root { background-color: #263238; color: #FDFBF8; font-family: Nunito Sans, sans-serif; font-size: 18px; line-height: 1.5; letter-spacing: 0.5px; --color-primary: #00FBFF; } header, h1, h2, h3, h4, h5, h6 { font-family: Nunito, sans-serif; } a { color: var(--color-primary); text-decoration: none; } :root { --external-link: url("data:image/svg+xml;utf8, %3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' fill='%2300FBFF' stroke='COLOR' viewBox='0 0 24 24' %3E %3Cpath d='M6 17c2.269-9.881 11-11.667 11-11.667v-3.333l7 6.637-7 6.696v-3.333s-6.17-.171-11 5zm12 .145v2.855h-16v-12h6.598c.768-.787 1.561-1.449 2.339-2h-10.937v16h20v-6.769l-2 1.914z'/%3E %3C/svg%3E "); } a[href^="http"]:not([href^="https://repos.amatiasq.com"]):not(.no-external)::after { content: ''; margin-left: 0.5em; width: 0.8em; height: 0.8em; display: inline-block; background-image: var(--external-link); background-repeat: no-repeat; background-position: center; background-size: contain; } :where(.bouncy-box, article a) { position: relative; display: inline-block; --underline-width: 1px; --padding: 8; transform: scale(1) rotate(0); transition: transform 0.3s cubic-bezier(0.25, 0.1, 0, 2.05); } :where(.bouncy-box, article a):hover { transform: scale(1.1) rotate(0); } :where(.bouncy-box, article a):before { content: ''; position: absolute; z-index: -1; border-radius: 8px; opacity: 1; background: var(--color-primary); inset: calc(100% - var(--underline-width)) 0 0 0; height: var(--underline-width); transition-property: inset, opacity, height, background; transition-duration: 0.3s; transition-timing-function: cubic-bezier(0,.5,0,1); } :where(.bouncy-box, article a):hover:before { inset: calc(var(--padding) * -1px) calc(var(--padding) * -2px); background: black; opacity: 0.8; height: calc(100% + calc(var(--padding) * 2px)); } ol { padding: 0; } li { list-style: none; } code { font-family: Inconsolata, monospace; } svg { fill: #FDFBF8; } </style><style>.css-1r8v4cp{display:none;}@media (min-width: 769px){.css-1r8v4cp{--size:1.5rem;display:block;position:fixed;overflow:hidden;bottom:calc(var(--size) * -1);right:calc(var(--size) * -1);height:calc(var(--size) * 2);width:calc(var(--size) * 2);border-radius:var(--size);transition-duration:0.3s;transition-timing-function:cubic-bezier(0.25, 0.1, 0, 2.05);transtition-property:height,width;}.css-1r8v4cp:hover,.css-1r8v4cp:focus-within{--size:6rem;}.css-1r8v4cp:hover label,.css-1r8v4cp:focus-within label{-webkit-transform:rotate(0deg);-moz-transform:rotate(0deg);-ms-transform:rotate(0deg);transform:rotate(0deg);opacity:1;}.css-1r8v4cp input{background:transparent;margin:-10px;border:none;width:calc(var(--size) * 2);height:calc(var(--size) * 2);}.css-1r8v4cp label{opacity:0;background:rgba(0, 0, 0, 0.8);border-radius:16px;padding:0.3em 1em;position:fixed;bottom:2rem;right:7rem;color:var(--color-primary);font-weight:bold;-webkit-transform:rotate(90deg);-moz-transform:rotate(90deg);-ms-transform:rotate(90deg);transform:rotate(90deg);transform-origin:100% 1000%;-webkit-transition:-webkit-transform 0.3s,opacity 1s;transition:transform 0.3s,opacity 1s;}}
.css-13sgw9j{margin-top:10rem;overflow:hidden;}.css-13sgw9j #disqus_thread{margin-top:-50px;margin-bottom:-36px;}
.css-5a8vm2 .shj-inline{margin:0;padding:2px 5px;display:inline-block;border-radius:5px;}.css-5a8vm2 [class*=shj-lang-]::selection,.css-5a8vm2 [class*=shj-lang-] ::selection{background:#bdf5;}.css-5a8vm2 [class*=shj-lang-]>div{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;overflow:auto;}.css-5a8vm2 [class*=shj-lang-]>div :last-child{-webkit-flex:1;-ms-flex:1;flex:1;outline:none;}.css-5a8vm2 .shj-syn-cmnt{font-style:italic;}.css-5a8vm2 .shj-syn-err,.css-5a8vm2 .shj-syn-kwd{color:#e16;}.css-5a8vm2 .shj-syn-num,.css-5a8vm2 .shj-syn-class{color:#f60;}.css-5a8vm2 .shj-numbers,.css-5a8vm2 .shj-syn-cmnt{color:#999;}.css-5a8vm2 .shj-syn-insert,.css-5a8vm2 .shj-syn-str{color:#7d8;}.css-5a8vm2 .shj-syn-bool{color:#3bf;}.css-5a8vm2 .shj-syn-type,.css-5a8vm2 .shj-syn-oper{color:#5af;}.css-5a8vm2 .shj-syn-section,.css-5a8vm2 .shj-syn-func{color:#84f;}.css-5a8vm2 .shj-syn-deleted,.css-5a8vm2 .shj-syn-var{color:#f44;}.css-5a8vm2 .shj-oneline{padding:12px 10px;}.css-5a8vm2 .shj-lang-http.shj-oneline .shj-syn-kwd{background:#25f;color:#fff;padding:5px 7px;border-radius:5px;}.css-5a8vm2 .shj-multiline.shj-mode-header{padding:20px;}.css-5a8vm2 .shj-multiline.shj-mode-header:before{content:attr(data-lang);color:#58f;display:block;padding:10px 20px;background:#58f3;border-radius:5px;margin-bottom:20px;}.css-5a8vm2 [class*=shj-lang-]:before{color:#6f9aff;}.css-5a8vm2 .shj-syn-deleted,.css-5a8vm2 .shj-syn-err,.css-5a8vm2 .shj-syn-var{color:#e06c75;}.css-5a8vm2 .shj-syn-section,.css-5a8vm2 .shj-syn-oper,.css-5a8vm2 .shj-syn-kwd{color:#c678dd;}.css-5a8vm2 .shj-syn-class{color:#e5c07b;}.css-5a8vm2 .shj-numbers,.css-5a8vm2 .shj-syn-cmnt{color:#76839a;}.css-5a8vm2 .shj-syn-insert{color:#98c379;}.css-5a8vm2 .shj-syn-type{color:#56b6c2;}.css-5a8vm2 .shj-syn-num,.css-5a8vm2 .shj-syn-bool{color:#d19a66;}.css-5a8vm2 .shj-syn-str,.css-5a8vm2 .shj-syn-func{color:#61afef;}
.css-2bthvy{font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Helvetica,Arial,sans-serif,'Apple Color Emoji','Segoe UI Emoji';}.css-2bthvy li{list-style:initial;}.css-2bthvy ul,.css-2bthvy ol{margin:20px 0;padding:reset;}.css-2bthvy p{margin:20px 0;text-align:justify;}.css-2bthvy blockquote{border-left:5px solid #586369;margin-left:0;padding-left:1em;}.css-2bthvy code:not(.code-block){background-color:#161b22;padding:4px;border-radius:4px;}.css-2bthvy pre{--code-block-margin:3em;--code-block-padding:1em;--code-inline-padding:min(3em, var(--container-side-gap));margin:var(--code-block-margin) 0;padding:var(--code-block-padding) 0;position:relative;white-space:pre;}.css-2bthvy pre .code-block{display:block;width:var(--available-width);white-space:pre;text-shadow:none;font-size:18px;line-height:24px;box-sizing:border-box;max-width:var(--available-width);overflow-x:auto;color:#abb2bf;}.css-2bthvy pre::before{content:'';inset:calc(var(--code-block-padding) * -1) calc(var(--code-inline-padding) * -1);background:#161b22;border-radius:10px;box-shadow:0 0 5px #0001;position:absolute;z-index:-1;max-width:100vw;}
.css-84fmch{opacity:0.8;font-size:0.8em;font-family:Inconsolata,monospace;color:#FDFBF8;white-space:nowrap;}
.css-v6zv8e{font-family:Nunito,sans-serif;font-weight:700;font-size:32px;}
.css-relzm4{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:justify;-webkit-justify-content:space-between;justify-content:space-between;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;}@media (min-width: 769px){.css-relzm4{-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}}
.css-1gakiv5{color:white;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:baseline;-webkit-box-align:baseline;-ms-flex-align:baseline;align-items:baseline;letter-spacing:1px;white-space:nowrap;}.css-1gakiv5 abbr{display:-webkit-inline-box;display:-webkit-inline-flex;display:-ms-inline-flexbox;display:inline-flex;width:0.79em;overflow:hidden;-webkit-transition:width 0.3s ease;transition:width 0.3s ease;}.css-1gakiv5 abbr,.css-1gakiv5 span+span{margin-left:0.4em;}.css-1gakiv5:hover abbr{width:3.3em;}.css-1gakiv5:hover .dot{display:none;}
.css-1x2qc6k{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;gap:12px;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;margin:0;font-size:1.3em;}@media (min-width: 769px){.css-1x2qc6k{font-size:1.5em;}}
.css-147lofe{--container-side-gap:2rem;--container-width:40rem;--container-sides-gap:calc(var(--container-side-gap) * 2);--available-width:min(
      calc(100vw - var(--container-sides-gap)),
      calc(var(--container-width) - var(--container-sides-gap))
    );max-width:var(--container-width);padding-left:var(--container-side-gap);padding-right:var(--container-side-gap);margin-left:auto;margin-right:auto;}@media (min-width: 769px){.css-147lofe{--container-width:50rem;--container-side-gap:3rem;}}@media (min-width: 1200px){.css-147lofe{--container-width:60rem;}}
.css-x7nza2{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;gap:12px;}.css-x7nza2 a{color:var(--color-primary);margin-left:12px;border-bottom:1px solid transparent;-webkit-transform:translate(0px, 0px);-moz-transform:translate(0px, 0px);-ms-transform:translate(0px, 0px);transform:translate(0px, 0px);}.css-x7nza2 a.parent{border-bottom:1px solid #586369;}.css-x7nza2 a:hover{border-bottom:1px solid var(--color-primary);-webkit-transition:-webkit-transform 1s ease;transition:transform 1s ease;-webkit-transform:translate(0px, -3px);-moz-transform:translate(0px, -3px);-ms-transform:translate(0px, -3px);transform:translate(0px, -3px);}
.css-1x4ehqa{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:justify;-webkit-justify-content:space-between;justify-content:space-between;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;gap:20px;}@media (min-width: 769px){.css-1x4ehqa{-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;}}
.css-30tjyf{background-color:#161b22;color:#FDFBF8;border-bottom:2px solid #586369;padding:12px 0;-webkit-transition:padding 0.15s ease-in-out,font-size 0.15s ease-in-out;transition:padding 0.15s ease-in-out,font-size 0.15s ease-in-out;}@media (min-width: 769px){.css-30tjyf{position:-webkit-sticky;position:sticky;top:0;z-index:1;}}.css-30tjyf:not(.scrolled){padding:40px 0;font-size:1.2em;}
.css-1e8d7s{padding-bottom:4rem;}
.css-1p4f3y5{display:grid;padding-top:20px;gap:12px;}</style><script>const onDomLoaded = new Promise((resolve) =>
  addEventListener('DOMContentLoaded', resolve)
);

async function $(selector) {
  await onDomLoaded;
  return document.querySelector(selector);
}

async function $$(selector) {
  await onDomLoaded;
  return [...document.querySelectorAll(selector)];
}

onDomLoaded.then(() => {
  $ = (selector) => Promise.resolve(document.querySelector(selector));
  $$ = (selector) => Promise.resolve([...document.querySelectorAll(selector)]);
});


const externalLinkVariable = '--external-link';
const getExternalLinkBackground = function anonymous(color
) {

    function svgToUrl(svg) {
    const escaped = svg.replace(/</g, '%3C').replace(/>/g, '%3E').replace(/"/g, "'").replace(/(\s|\n)+/g, ' ').replace(/#/g, '%23');
    return `url("data:image/svg+xml;utf8,${escaped}")`;
}
    const svg = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    fill="COLOR"
    stroke="COLOR"
    viewBox="0 0 24 24"
  >
    <path d="M6 17c2.269-9.881 11-11.667 11-11.667v-3.333l7 6.637-7 6.696v-3.333s-6.17-.171-11 5zm12 .145v2.855h-16v-12h6.598c.768-.787 1.561-1.449 2.339-2h-10.937v16h20v-6.769l-2 1.914z"/>
  </svg>
`
    return svgToUrl(svg.replace('COLOR', color));
  
};
const PRIMARY_COLOR_KEY = 'amatiasq.com|color-primary';

async function changePrimaryColor(newColor) {
  if (!newColor) return;

  const root = document.documentElement.style;

  root.setProperty('--color-primary', newColor);
  root.setProperty(externalLinkVariable, getExternalLinkBackground(newColor));

  localStorage.setItem(PRIMARY_COLOR_KEY, newColor);

  const $picker = await $('#color-picker');
  $picker.value = newColor;
}

changePrimaryColor(localStorage.getItem(PRIMARY_COLOR_KEY));

        </script></head><body class=" css-1e8d7s"><script type="module" defer="">const scrollers = (await $$('[data-scrollclass]'))
  .map((x) => ({
    el: x,
    className: x.dataset.scrollclass,
    offset: x.dataset.scrolloffset || 0,
    tolerance: x.dataset.scrolltolerance || 0,
  }))
  .filter((x) => x.className);

const pendingScrollers = new Set(scrollers);

if (pendingScrollers.size) {
  addEventListener('scroll', () => {
    const scrolled = document.documentElement.scrollTop;

    for (const { el, className, offset, tolerance } of pendingScrollers) {
      const scrollDiff = scrolled - offset;

      if (Math.abs(scrollDiff) < tolerance) {
        return;
      }

      const hasClass = el.classList.contains(className);
      const shouldHaveClass = scrollDiff > 0;

      if (shouldHaveClass === hasClass) {
        return;
      }

      if (shouldHaveClass) {
        el.classList.add(className);
      } else {
        el.classList.remove(className);
      }
    }
  });
}
</script><header class="css-30tjyf " data-scrollclass="scrolled" data-scrolloffset="50" data-scrolltolerance="50"><div class="css-1x4ehqa css-147lofe"><h2 class="css-1x2qc6k"><a href="../.." class="css-1gakiv5 inactive"><span>{ </span><abbr>Adrian</abbr><span class="dot">.</span><span>Matías Quezada</span><span> }</span></a></h2><nav class="css-x7nza2"><a href=".." class="parent">Blog</a><a href="../../projects" class="">Proyectos</a><a href="../../career" class="">CV</a><a href="../../../blog/2011-12-09-el-patron-promise" class="">🇬🇧</a></nav></div></header><div class="css-1p4f3y5 css-147lofe"><h2 class="css-relzm4  css-v6zv8e">El patrón Promise<time class="css-84fmch " dateTime="09/12/2011">9 dic 2011</time></h2><article class="md css-2bthvy css-5a8vm2 "><blockquote>
<p>Actualización 19/3/2014: Finalmente los promises se han confirmado <a href="https://github.com/lukehoban/es6features#promises">para el estándar ECMAScript 6</a>, dentro de poco serán nativos en Javascript :D</p>
<p>Actualización 7/10/2016: Los promises <a href="https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Objetos_globales/Promesa">ya son estándar</a> y están implementados <a href="http://caniuse.com/#search=promises">en los navegadores</a>!!!</p>
</blockquote>
<h2 id="problema">PROBLEMA</h2>
<p>Recientemente he tenido que implementar un sistema MVC en Javascript para simplificar el desarrollo sobre una plataforma y me he encontrado con el problema de que las llamadas asíncronas a servidor rompían la simpleza del código, tras un análisis identifiqué cuatro problemas:</p>
<!-- end extract -->
<h4 id="1-ensuciar-la-api">1 - Ensuciar la API</h4>
<p>Todas las llamadas reciben un último argumento que es el callback:</p>

<pre><code class="code-block shj-lang-js"><span class="shj-syn-kwd">var</span> dir <span class="shj-syn-oper">=</span> <span class="shj-syn-kwd">new</span> <span class="shj-syn-class">Directory</span>(<span class="shj-syn-str">'file:///home/user/Desktop'</span>);
dir<span class="shj-syn-oper">.</span><span class="shj-syn-func">browse</span>(<span class="shj-syn-kwd">function</span> (dir<span class="shj-syn-oper">,</span> items) {
  <span class="shj-syn-cmnt">// ...
</span>});
</code></pre>
<p>Con ésto la API resulta confusa desde el punto de vista de la simpleza y de la semántica. Semánticamente una función recibe la información mínima indispensable para devolver un dato relacionado a lo que se le ha solicitado, como vemos no es el caso en métodos asíncronos:</p>

<pre><code class="code-block shj-lang-js"><span class="shj-syn-kwd">void</span> <span class="shj-syn-class">Directory</span><span class="shj-syn-oper">.</span><span class="shj-syn-func">browse</span>(<span class="shj-syn-class">Function</span> callback);
<span class="shj-syn-kwd">void</span> <span class="shj-syn-class">File</span><span class="shj-syn-oper">.</span><span class="shj-syn-func">getContent</span>(<span class="shj-syn-class">String</span> encoding<span class="shj-syn-oper">,</span> <span class="shj-syn-class">Function</span> callback);
<span class="shj-syn-kwd">void</span> <span class="shj-syn-class">File</span><span class="shj-syn-oper">.</span><span class="shj-syn-func">getPermission</span>(<span class="shj-syn-class">Function</span> callback);
</code></pre>
<!--more Seguir leyendo → -->
<h3 id="2-llamadas-anidadas">2 - Llamadas anidadas</h3>
<p>En muchas ocaciones deberemos ejecutar una llamada al acabar otra, ésto nos obliga a anidar callbacks:</p>

<pre><code class="code-block shj-lang-js"><span class="shj-syn-kwd">var</span> file <span class="shj-syn-oper">=</span> <span class="shj-syn-kwd">new</span> <span class="shj-syn-class">File</span>();
file<span class="shj-syn-oper">.</span><span class="shj-syn-func">isReadable</span>(<span class="shj-syn-kwd">function</span> (permission) {
  <span class="shj-syn-kwd">if</span> (permission) {
    file<span class="shj-syn-oper">.</span><span class="shj-syn-func">getContent</span>(<span class="shj-syn-kwd">function</span> (content) {
      <span class="shj-syn-cmnt">// do something with the content
</span>    });
  }
});
</code></pre>
<p>A medida que vamos añadiendo niveles de profundidad ésto se vuelve muy confuso.</p>
<h3 id="3-llamadas-concurrentes">3 - Llamadas concurrentes</h3>
<p>También necesitaremos realizar llamadas asíncronas paralelas y ejecutar una acción al acabar todas:</p>

<pre><code class="code-block shj-lang-js"><span class="shj-syn-kwd">var</span> isFile1Done <span class="shj-syn-oper">=</span> <span class="shj-syn-bool">false</span>;
<span class="shj-syn-kwd">var</span> isFile2Done <span class="shj-syn-oper">=</span> <span class="shj-syn-bool">false</span>;

<span class="shj-syn-kwd">function</span> <span class="shj-syn-func">testIsOver</span>() {
  <span class="shj-syn-kwd">if</span> (isFile1Done <span class="shj-syn-oper">&#38;&#38;</span> isFile2Done) {
    <span class="shj-syn-cmnt">// Both files loaded.
</span>  }
}

<span class="shj-syn-class">File</span><span class="shj-syn-oper">.</span><span class="shj-syn-kwd">get</span>(<span class="shj-syn-str">'http://www.somedomain.com/file1'</span><span class="shj-syn-oper">,</span> <span class="shj-syn-kwd">function</span> () {
  isFile1Done <span class="shj-syn-oper">=</span> <span class="shj-syn-bool">true</span>;
  <span class="shj-syn-func">testIsOVer</span>();
});
<span class="shj-syn-class">File</span><span class="shj-syn-oper">.</span><span class="shj-syn-kwd">get</span>(<span class="shj-syn-str">'http://www.somedomain.com/file2'</span><span class="shj-syn-oper">,</span> <span class="shj-syn-kwd">function</span> () {
  isFile2Done <span class="shj-syn-oper">=</span> <span class="shj-syn-bool">true</span>;
  <span class="shj-syn-func">testIsOVer</span>();
});
</code></pre>
<p>Como podemos ver algo tan sencillo como dos peticiones paralelas necesitan mucho código para manejarlas.</p>
<h3 id="4-gesti-n-de-errores">4 - Gestión de errores</h3>
<p>Es traumática la forma de gestionar errores mediante callbacks, el método más extendido que he visto ha sido el de nodejs, el primer argumento de cada callback es el objeto Error si es que hubo alguna excepción, lo que me parece horrible ya que cada función debe confirmar que su primer argumento es <code>undefined</code> para asegurar que no han habido errores:</p>

<pre><code class="code-block shj-lang-js"><span class="shj-syn-class">File</span><span class="shj-syn-oper">.</span><span class="shj-syn-kwd">get</span>(<span class="shj-syn-str">'http://www.somedomain.com/file2'</span><span class="shj-syn-oper">,</span> <span class="shj-syn-kwd">function</span> (error<span class="shj-syn-oper">,</span> file) {
  <span class="shj-syn-kwd">if</span> (error) {
    <span class="shj-syn-cmnt">// Show blue screen of death
</span>  }
  <span class="shj-syn-cmnt">// do something with file.
</span>});
</code></pre>
<h2 id="solucion">SOLUCION</h2>
<p>Queda claro que las peticiones asíncronas son necesarias en cliente y servidor ya que permiten al programa continuar trabajando mientras espera la respuesta a la petición, pero éstos problemas podrían dificultar la manutención del código. Y aquí es donde viene a ayudarnos el Patrón Promise. El patrón Promise asiste a una función que no puede devolver inmediatamente su resultado (es decir, una función asíncrona) y devuelve la promesa de que tendrá el resultado en un futuro (a lo que llamo cumplir la promesa :P). A nivel de implementación, una función devuelve un objeto <strong>Promise</strong> que gestionará por ella el callback. Veamos cómo soluciona nuestros problemas:</p>
<h4 id="1-claridad-en-los-m-todos">1 - Claridad en los métodos</h4>
<p>La función solo debe recibir la información necesaria para hacer la petición y devuelve la promesa de que esos datos llegarán.</p>

<pre><code class="code-block shj-lang-js"><span class="shj-syn-kwd">var</span> dir <span class="shj-syn-oper">=</span> <span class="shj-syn-kwd">new</span> <span class="shj-syn-class">Directory</span>(<span class="shj-syn-str">'file:///home/user/Desktop'</span>);
<span class="shj-syn-kwd">var</span> promise <span class="shj-syn-oper">=</span> dir<span class="shj-syn-oper">.</span><span class="shj-syn-func">browse</span>();
promise<span class="shj-syn-oper">.</span><span class="shj-syn-func">then</span>(<span class="shj-syn-kwd">function</span> (dir<span class="shj-syn-oper">,</span> items) {
  <span class="shj-syn-cmnt">// ...
</span>});
</code></pre>
<p>Y ésto aún lo podríamos mejorar llamando directamente a la función then sin guardar el promise en una variable:</p>

<pre><code class="code-block shj-lang-js"><span class="shj-syn-kwd">var</span> dir <span class="shj-syn-oper">=</span> <span class="shj-syn-kwd">new</span> <span class="shj-syn-class">Directory</span>(<span class="shj-syn-str">'file:///home/user/Desktop'</span>);
dir<span class="shj-syn-oper">.</span><span class="shj-syn-func">browse</span>()<span class="shj-syn-oper">.</span><span class="shj-syn-func">then</span>(<span class="shj-syn-kwd">function</span> (dir<span class="shj-syn-oper">,</span> items) {
  <span class="shj-syn-cmnt">// ...
</span>});
</code></pre>
<p>Y muchos dirán ¿qué diferencia hay entre ésto y el código que teníamos antes? Es sencillo, la diferencia está en quién maneja el callback. Con el código anterior cada función debía encargarse de comprobar si se le había pasado un callback válido y llamarlo al acabar su tarea con los argumentos necesarios. Ahora todo ése código está en la clase <code>Promise</code> y la función puede encargarse de aquello que le corresponde siempre que devuelva un promise y le notifique cuando termine. Finalmente la API queda bastante más clara:</p>

<pre><code class="code-block shj-lang-js"><span class="shj-syn-class">Promise</span><span class="shj-syn-oper">&lt;</span><span class="shj-syn-class">Array</span><span class="shj-syn-oper">&lt;</span><span class="shj-syn-class">File</span><span class="shj-syn-oper">&gt;&gt;</span> <span class="shj-syn-class">Directory</span><span class="shj-syn-oper">.</span><span class="shj-syn-func">browse</span>();
<span class="shj-syn-class">Promise</span><span class="shj-syn-oper">&lt;</span><span class="shj-syn-class">String</span><span class="shj-syn-oper">&gt;</span> <span class="shj-syn-class">File</span><span class="shj-syn-oper">.</span><span class="shj-syn-func">getContent</span>(<span class="shj-syn-class">String</span> encoding);
<span class="shj-syn-class">Promise</span><span class="shj-syn-oper">&lt;</span><span class="shj-syn-class">Boolean</span><span class="shj-syn-oper">&gt;</span> <span class="shj-syn-class">File</span><span class="shj-syn-oper">.</span><span class="shj-syn-func">getPermission</span>();
</code></pre>
<h3 id="2-llamadas-secuenciales">2 - Llamadas secuenciales</h3>
<p>El promise trae una sorpresa que no me esperaba, el método <code>then</code> de la clase <code>Promise</code> devuelve un nuevo <code>promise</code>. Para qué? para poder ejecutar código secuencialmente, veamoslo:</p>

<pre><code class="code-block shj-lang-js"><span class="shj-syn-kwd">var</span> file <span class="shj-syn-oper">=</span> <span class="shj-syn-kwd">new</span> <span class="shj-syn-class">File</span>();
file
  <span class="shj-syn-oper">.</span><span class="shj-syn-func">isReadable</span>()
  <span class="shj-syn-oper">.</span><span class="shj-syn-func">then</span>(<span class="shj-syn-kwd">function</span> (permission) {
    <span class="shj-syn-kwd">if</span> (permission) {
      <span class="shj-syn-kwd">return</span> file<span class="shj-syn-oper">.</span><span class="shj-syn-func">getContent</span>();
    }
  })
  <span class="shj-syn-oper">.</span><span class="shj-syn-func">then</span>(<span class="shj-syn-kwd">function</span> (content) {
    <span class="shj-syn-cmnt">// do something with the content
</span>  });
</code></pre>
<p>Qué es ésta locura? La idea es muy sencilla, pero es confusa porque la explicación utiliza demasiadas veces la palabra <code>Promise</code>, primero expandiremos el código para verlo más claro:</p>

<pre><code class="code-block shj-lang-js"><span class="shj-syn-kwd">var</span> file <span class="shj-syn-oper">=</span> <span class="shj-syn-kwd">new</span> <span class="shj-syn-class">File</span>();
<span class="shj-syn-kwd">var</span> promise1 <span class="shj-syn-oper">=</span> file<span class="shj-syn-oper">.</span><span class="shj-syn-func">isReadable</span>();

<span class="shj-syn-kwd">var</span> promise2 <span class="shj-syn-oper">=</span> promise1<span class="shj-syn-oper">.</span><span class="shj-syn-func">then</span>(<span class="shj-syn-kwd">function</span> (permission) {
  <span class="shj-syn-kwd">if</span> (permission) {
    <span class="shj-syn-kwd">var</span> promise3 <span class="shj-syn-oper">=</span> file<span class="shj-syn-oper">.</span><span class="shj-syn-func">getContent</span>();
    <span class="shj-syn-kwd">return</span> promise3;
  }
});

promise2<span class="shj-syn-oper">.</span><span class="shj-syn-func">then</span>(<span class="shj-syn-kwd">function</span> (content) {
  <span class="shj-syn-cmnt">// do something with the content
</span>});
</code></pre>
<p>Debemos intentar seguirlo poco a poco, la llamada a llamada <code>file.isReadable()</code> nos devuelve <code>promise1</code>, y cuando llamamos al método then de <code>promise1</code> nos devuelve <code>promise2</code>. Cuando <code>promise1</code> termina se ejecuta el callback pasado y se descubre que el callback devuelve un nuevo <code>Promise</code>, <code>promise3</code>. Cuando <code>promise3</code> se cumpla (es decir pase a estado &quot;done&quot;) también se cumplirá el <code>promise2</code> ejecutando el callback que le han pasado. En resumen, podemos seguir añadiendo callbacks que se ejecutarán al acabar el anterior encadenando llamadas a then.</p>
<h3 id="3-llamadas-paralelas">3 - Llamadas paralelas</h3>
<p>Además me planteé añadir la posibilidad de manejar llamadas paralelas desde <code>Promise</code>, puesto que ya hemos visto lo complejo que puede ser. Para ésto añadí el método <code>and</code> al Promise:</p>

<pre><code class="code-block shj-lang-js"><span class="shj-syn-class">File</span><span class="shj-syn-oper">.</span><span class="shj-syn-kwd">get</span>(<span class="shj-syn-str">'http://www.somedomain.com/file1'</span>)
  <span class="shj-syn-oper">.</span><span class="shj-syn-func">and</span>(<span class="shj-syn-class">File</span><span class="shj-syn-oper">.</span><span class="shj-syn-kwd">get</span>(<span class="shj-syn-str">'http://www.somedomain.com/file2'</span>))
  <span class="shj-syn-oper">.</span><span class="shj-syn-func">then</span>(<span class="shj-syn-kwd">function</span> () {
    <span class="shj-syn-cmnt">// Both files loaded.
</span>  });
</code></pre>
<p>Una vez más expandamos el código para ver más claramente que está sucediendo:</p>

<pre><code class="code-block shj-lang-js"><span class="shj-syn-kwd">var</span> promise1 <span class="shj-syn-oper">=</span> <span class="shj-syn-class">File</span><span class="shj-syn-oper">.</span><span class="shj-syn-kwd">get</span>(<span class="shj-syn-str">'http://www.somedomain.com/file1'</span>);
<span class="shj-syn-kwd">var</span> promise2 <span class="shj-syn-oper">=</span> <span class="shj-syn-class">File</span><span class="shj-syn-oper">.</span><span class="shj-syn-kwd">get</span>(<span class="shj-syn-str">'http://www.somedomain.com/file2'</span>);
<span class="shj-syn-kwd">var</span> promise3 <span class="shj-syn-oper">=</span> promise1<span class="shj-syn-oper">.</span><span class="shj-syn-func">and</span>(promise2);
promise3<span class="shj-syn-oper">.</span><span class="shj-syn-func">then</span>(<span class="shj-syn-kwd">function</span> () {
  <span class="shj-syn-cmnt">// Both files loaded.
</span>});
</code></pre>
<p>Al expandirlo es más fácil ver lo que sucede, todo <code>Promise</code> tiene un método <code>and</code> al que se le pasa otro <code>Promise</code>, y ésto devuelve un nuevo <code>Promise</code> que se cumplirá cuando los dos primeros estén cumplidos.</p>
<h3 id="4-callbacks-espec-ficos">4 - Callbacks específicos</h3>
<p>Finalmente el patrón Promise también trae una mejora al problema de la gestión de errores, aún no lo he mencionado pero el método <code>then</code> recibe dos argumentos: el primero el callback que será llamado cuando el Promise se cumpla, el segundo otro callback que será llamado si la ejecución asíncrona falla:</p>

<pre><code class="code-block shj-lang-js"><span class="shj-syn-class">File</span><span class="shj-syn-oper">.</span><span class="shj-syn-kwd">get</span>(<span class="shj-syn-str">'http://www.somedomain.com/file2'</span>)<span class="shj-syn-oper">.</span><span class="shj-syn-func">then</span>(
  <span class="shj-syn-kwd">function</span> (file) {
    <span class="shj-syn-cmnt">// do something with file.
</span>  }<span class="shj-syn-oper">,</span>
  <span class="shj-syn-kwd">function</span> (error) {
    <span class="shj-syn-cmnt">// Show blue screen of death
</span>  }<span class="shj-syn-oper">,</span>
);
</code></pre>
<p>Esto nos permite separar claramente la responsabilidad de cada función y nos libera de la carga de comprobar errores.</p>
<h2 id="conclusion">CONCLUSION</h2>
<p>Como vemos las llamadas secuenciales traen muchos inconvenientes, pero son principalmente consecuencias de no estar acostumbrados a la programación asíncrona, si lo estuviéramos tendríamos más en mente patrones como Promise que como vemos nos ayuda a afrontar una programación que ya de por sí es complicada. En próximos posts espero mostrar paso la implementación de una clase Promise, nos vemos en la próxima.</p>
</article><section class="css-13sgw9j"><div id="disqus_thread"></div><script type="module" defer="">
          var disqus_config=function(){
            this.page.url = `${location.origin}${location.pathname}`;
            this.page.identifier = '/blog/2011-12-09-el-patron-promise';
          };
          (function(){
            var d=document,s=d.createElement('script');
            s.src='https://amatiasq.disqus.com/embed.js';
            s.setAttribute('data-timestamp',+new Date());
            (d.head || d.body).appendChild(s);
          })();
        </script><noscript>Comments can&#x27;t be shown with Javascript disabled. Use a browser with Javascript to see them.</noscript></section></div><div class="css-1r8v4cp"><input type="color" id="color-picker" value="#00ffe1"/><label for="color-picker">Cambia el color principal!</label><script type="module" defer="">
          document.querySelector('#color-picker').addEventListener('input', (e) =>
            changePrimaryColor(e.target.value)
          );
        </script></div></body></html>