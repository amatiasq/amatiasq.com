<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="color-scheme" content="dark">
    <meta name="theme-color" content="#121212">
    <link rel="alternate" type="application/rss+xml" title="RSS Feed" href="/rss.xml">
    <link rel="icon" type="image/svg+xml" href="/favicon.svg">
    <title>Asincron칤a y el EventLoop | A. Mat칤as Quezada</title>
    
<meta name="astro-view-transitions-enabled" content="true">
<meta name="astro-view-transitions-fallback" content="animate">
<script type="module" src="/_astro/ClientRouter.astro_astro_type_script_index_0_lang.rasoniT7.js"></script>
  <link rel="stylesheet" href="/_astro/_slug_.eUhtq0iF.css">
<style>time:where(.astro-zcsldidg){font-family:ui-monospace,SF Mono,Menlo,Monaco,Courier New,monospace;font-size:.9em}
.md .code-block{position:relative;margin:1.5rem 0}.md pre{padding:1.25rem;border-radius:8px;overflow-x:auto;border:1px solid oklch(28% 0 0);margin:0}.md pre code{font-family:ui-monospace,SF Mono,Menlo,Monaco,Courier New,monospace;font-size:.875rem;line-height:1.6}.md :not(pre)>code{font-family:ui-monospace,SF Mono,Menlo,Monaco,Courier New,monospace;background:#090909;padding:.2em .4em;border-radius:4px;font-size:.9em;border:1px solid oklch(28% 0 0)}.md h2,.md h3{margin-top:2.5rem;margin-bottom:1rem}.md p{margin:1rem 0}.md blockquote{border-left:3px solid oklch(28% 0 0);margin:1.5rem 0;padding:.5rem 1rem;background:#090909;border-radius:0 8px 8px 0}.md blockquote p{margin:.5rem 0;color:#8f8f8f}.md ul,.md ol{padding-left:1.5rem;margin:1rem 0}.md li{margin:.5rem 0}.md hr{border:none;border-top:1px solid oklch(28% 0 0);margin:2rem 0}.md img{max-width:100%;height:auto;display:block;margin:1.5rem 0}.md pre span[style*="color:#6A737D"],.md pre span[style*="color:#8b949e"]{color:#54b05a!important;font-style:italic}.tags:where(.astro-hfj6urh3){list-style:none;padding:0;margin:1rem 0;display:flex;flex-wrap:wrap;gap:.5rem}li:where(.astro-hfj6urh3) .tag-link{background:#121212;border:1px solid oklch(28% 0 0);border-radius:4px;padding:.2rem .6rem;margin:0;font-size:.8rem;color:#9e9e9e;text-decoration:none;transition:all .15s ease;display:inline-block}li:where(.astro-hfj6urh3) .tag-link:hover{background:#222;border-color:var(--accent);color:var(--accent);transform:none}
@keyframes astroFadeInOut{0%{opacity:1}to{opacity:0}}@keyframes astroFadeIn{0%{opacity:0;mix-blend-mode:plus-lighter}to{opacity:1;mix-blend-mode:plus-lighter}}@keyframes astroFadeOut{0%{opacity:1;mix-blend-mode:plus-lighter}to{opacity:0;mix-blend-mode:plus-lighter}}@keyframes astroSlideFromRight{0%{transform:translate(100%)}}@keyframes astroSlideFromLeft{0%{transform:translate(-100%)}}@keyframes astroSlideToRight{to{transform:translate(100%)}}@keyframes astroSlideToLeft{to{transform:translate(-100%)}}@media (prefers-reduced-motion){::view-transition-group(*),::view-transition-old(*),::view-transition-new(*){animation:none!important}[data-astro-transition-scope]{animation:none!important}}
</style><style>[data-astro-transition-scope="astro-dsji2kxr-1"] { view-transition-name: title-2014-04-14-asincronia-y-el-eventloop; }@layer astro { ::view-transition-old(title-2014-04-14-asincronia-y-el-eventloop) { 
	animation-duration: 180ms;
	animation-timing-function: cubic-bezier(0.76, 0, 0.24, 1);
	animation-fill-mode: both;
	animation-name: astroFadeOut; }::view-transition-new(title-2014-04-14-asincronia-y-el-eventloop) { 
	animation-duration: 180ms;
	animation-timing-function: cubic-bezier(0.76, 0, 0.24, 1);
	animation-fill-mode: both;
	animation-name: astroFadeIn; }[data-astro-transition=back]::view-transition-old(title-2014-04-14-asincronia-y-el-eventloop) { 
	animation-duration: 180ms;
	animation-timing-function: cubic-bezier(0.76, 0, 0.24, 1);
	animation-fill-mode: both;
	animation-name: astroFadeOut; }[data-astro-transition=back]::view-transition-new(title-2014-04-14-asincronia-y-el-eventloop) { 
	animation-duration: 180ms;
	animation-timing-function: cubic-bezier(0.76, 0, 0.24, 1);
	animation-fill-mode: both;
	animation-name: astroFadeIn; } }[data-astro-transition-fallback="old"] [data-astro-transition-scope="astro-dsji2kxr-1"],
			[data-astro-transition-fallback="old"][data-astro-transition-scope="astro-dsji2kxr-1"] { 
	animation-duration: 180ms;
	animation-timing-function: cubic-bezier(0.76, 0, 0.24, 1);
	animation-fill-mode: both;
	animation-name: astroFadeOut; }[data-astro-transition-fallback="new"] [data-astro-transition-scope="astro-dsji2kxr-1"],
			[data-astro-transition-fallback="new"][data-astro-transition-scope="astro-dsji2kxr-1"] { 
	animation-duration: 180ms;
	animation-timing-function: cubic-bezier(0.76, 0, 0.24, 1);
	animation-fill-mode: both;
	animation-name: astroFadeIn; }[data-astro-transition=back][data-astro-transition-fallback="old"] [data-astro-transition-scope="astro-dsji2kxr-1"],
			[data-astro-transition=back][data-astro-transition-fallback="old"][data-astro-transition-scope="astro-dsji2kxr-1"] { 
	animation-duration: 180ms;
	animation-timing-function: cubic-bezier(0.76, 0, 0.24, 1);
	animation-fill-mode: both;
	animation-name: astroFadeOut; }[data-astro-transition=back][data-astro-transition-fallback="new"] [data-astro-transition-scope="astro-dsji2kxr-1"],
			[data-astro-transition=back][data-astro-transition-fallback="new"][data-astro-transition-scope="astro-dsji2kxr-1"] { 
	animation-duration: 180ms;
	animation-timing-function: cubic-bezier(0.76, 0, 0.24, 1);
	animation-fill-mode: both;
	animation-name: astroFadeIn; }</style><style>[data-astro-transition-scope="astro-vpr6a7he-2"] { view-transition-name: tag-javascript; }@layer astro { ::view-transition-old(tag-javascript) { 
	animation-duration: 180ms;
	animation-timing-function: cubic-bezier(0.76, 0, 0.24, 1);
	animation-fill-mode: both;
	animation-name: astroFadeOut; }::view-transition-new(tag-javascript) { 
	animation-duration: 180ms;
	animation-timing-function: cubic-bezier(0.76, 0, 0.24, 1);
	animation-fill-mode: both;
	animation-name: astroFadeIn; }[data-astro-transition=back]::view-transition-old(tag-javascript) { 
	animation-duration: 180ms;
	animation-timing-function: cubic-bezier(0.76, 0, 0.24, 1);
	animation-fill-mode: both;
	animation-name: astroFadeOut; }[data-astro-transition=back]::view-transition-new(tag-javascript) { 
	animation-duration: 180ms;
	animation-timing-function: cubic-bezier(0.76, 0, 0.24, 1);
	animation-fill-mode: both;
	animation-name: astroFadeIn; } }[data-astro-transition-fallback="old"] [data-astro-transition-scope="astro-vpr6a7he-2"],
			[data-astro-transition-fallback="old"][data-astro-transition-scope="astro-vpr6a7he-2"] { 
	animation-duration: 180ms;
	animation-timing-function: cubic-bezier(0.76, 0, 0.24, 1);
	animation-fill-mode: both;
	animation-name: astroFadeOut; }[data-astro-transition-fallback="new"] [data-astro-transition-scope="astro-vpr6a7he-2"],
			[data-astro-transition-fallback="new"][data-astro-transition-scope="astro-vpr6a7he-2"] { 
	animation-duration: 180ms;
	animation-timing-function: cubic-bezier(0.76, 0, 0.24, 1);
	animation-fill-mode: both;
	animation-name: astroFadeIn; }[data-astro-transition=back][data-astro-transition-fallback="old"] [data-astro-transition-scope="astro-vpr6a7he-2"],
			[data-astro-transition=back][data-astro-transition-fallback="old"][data-astro-transition-scope="astro-vpr6a7he-2"] { 
	animation-duration: 180ms;
	animation-timing-function: cubic-bezier(0.76, 0, 0.24, 1);
	animation-fill-mode: both;
	animation-name: astroFadeOut; }[data-astro-transition=back][data-astro-transition-fallback="new"] [data-astro-transition-scope="astro-vpr6a7he-2"],
			[data-astro-transition=back][data-astro-transition-fallback="new"][data-astro-transition-scope="astro-vpr6a7he-2"] { 
	animation-duration: 180ms;
	animation-timing-function: cubic-bezier(0.76, 0, 0.24, 1);
	animation-fill-mode: both;
	animation-name: astroFadeIn; }</style></head>
  <body>
    
  <header class="astro-np5jgbit">
  <a href="/es/" class="site-title astro-np5jgbit"><span class="a-matias-quezada astro-np5jgbit astro-2dpizvyk">
  <abbr class="astro-2dpizvyk">Adrian</abbr>
  <span class="dot astro-2dpizvyk">.</span>
  <span class="astro-2dpizvyk">Mat칤as Quezada</span>
</span></a>
  <nav class="astro-np5jgbit">
    <a href="/es/projects/" class="astro-np5jgbit">Projects</a>
    <span class="sep astro-np5jgbit">췅</span>
    <a href="/es/blog/" class="astro-np5jgbit">Blog</a>
    <span class="sep astro-np5jgbit">췅</span>
    <a href="/es/experiments/" class="astro-np5jgbit">Experiments</a>
    <span class="sep astro-np5jgbit">췅</span>
    <a href="/es/talks/" class="astro-np5jgbit">Talks</a>
    <span class="sep astro-np5jgbit">췅</span>
    <a href="/es/career/" class="astro-np5jgbit">Career</a>
    <span class="sep astro-np5jgbit">|</span>
    <a href="https://github.com/amatiasq" title="GitHub" class="icon-link astro-np5jgbit">
      <svg aria-label="GitHub" width="20" height="20" viewBox="0 0 98 96" xmlns="http://www.w3.org/2000/svg" class="astro-np5jgbit">
        <path fill-rule="evenodd" clip-rule="evenodd" d="M48.854 0C21.839 0 0 22 0 49.217c0 21.756 13.993 40.172 33.405 46.69 2.427.49 3.316-1.059 3.316-2.362 0-1.141-.08-5.052-.08-9.127-13.59 2.934-16.42-5.867-16.42-5.867-2.184-5.704-5.42-7.17-5.42-7.17-4.448-3.015.324-3.015.324-3.015 4.934.326 7.523 5.052 7.523 5.052 4.367 7.496 11.404 5.378 14.235 4.074.404-3.178 1.699-5.378 3.074-6.6-10.839-1.141-22.243-5.378-22.243-24.283 0-5.378 1.94-9.778 5.014-13.2-.485-1.222-2.184-6.275.486-13.038 0 0 4.125-1.304 13.426 5.052a46.97 46.97 0 0 1 12.214-1.63c4.125 0 8.33.571 12.213 1.63 9.302-6.356 13.427-5.052 13.427-5.052 2.67 6.763.97 11.816.485 13.038 3.155 3.422 5.015 7.822 5.015 13.2 0 18.905-11.404 23.06-22.324 24.283 1.78 1.548 3.316 4.481 3.316 9.126 0 6.6-.08 11.897-.08 13.526 0 1.304.89 2.853 3.316 2.364 19.412-6.52 33.405-24.935 33.405-46.691C97.707 22 75.788 0 48.854 0z" fill="currentColor" class="astro-np5jgbit"></path>
      </svg>
    </a>
    <a href="/en/blog/2014-04-14-asincronia-y-el-eventloop/" title="English" class="lang-switch astro-bzi5jpwk" data-lang="en">
  游섫릖
</a>



<script type="module">function n(){const t=document.querySelector(".lang-switch");if(!t)return;const a=t.dataset.lang,e=Intl.DateTimeFormat().resolvedOptions().timeZone.startsWith("America/");a==="en"?(t.textContent=e?"游쥟릖":"游섫릖",t.title="English"):(t.textContent=e?"游뷣릖":"游쀯릖",t.title="Espa침ol")}n();document.addEventListener("astro:after-swap",n);</script>
  </nav>
</header>
<hr class="astro-np5jgbit">
  <main>
    <article>
      <header>
        <h1 data-astro-transition-scope="astro-dsji2kxr-1">Asincron칤a y el EventLoop</h1>
        <time datetime="2014-04-14T00:00:00.000Z" class="astro-zcsldidg">14 abr 2014</time>
        <ul class="tags astro-hfj6urh3">
    <li class="astro-hfj6urh3">
        <a href="/es/tag/javascript/" class="tag-link astro-hfj6urh3">
          <span class="astro-hfj6urh3" data-astro-transition-scope="astro-vpr6a7he-2">
            Javascript
          </span>
        </a>
      </li>
  </ul>


      </header>
      <div class="md "><p>Me gustar칤a hacer un repaso al tema de la asincron칤a en Javascript porque me llama la atenci칩n que pese a tener casi 20 a침os es un tema que sigue madurando y he visto surgir buenas ideas recientemente.</p>
<h3>El event loop</h3>
<p>Primero lo primero, de donde sale la asincron칤a. Javascript es un lenguaje cuya ejecuci칩n se basa en lo que se llama <strong>event loop</strong> (bucle de eventos). El <em>event loop</em> es una cola donde se van a침adiendo los bloques de c칩digo que quieren ejecutarse, por ejemplo: cuando el navegador est치 renderizando el HTML de una p치gina y se encuentra un tag <code>&lt;script&gt;</code> el contenido de ese elemento se a침ade al <em>event loop</em> para que sea ejecutado tan pronto como sea posible.</p>
<!-- end extract -->

<p>Lo mismo ocurre cuando la p치gina ya est치 cargada y el usuario hace click. Si tenemos una funci칩n listener (tambi칠n llamado callback) escuchando los eventos click de un objeto esa funci칩n se a침ade a la cola del <em>event loop</em> para que el sistema lo ejecute tan pronto como sea posible.</p>
<p>De esta forma todos los bloques de c칩digo que se ejecutan en javascript han sido bloques de c칩digo que entraron a la cola del <em>event loop</em> y cuando lleg칩 su turno fueron ejecutados. Podemos entenderlo m치s f치cilmente si implementamos un falso event loop en Javascript:</p>
<div class="code-block"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">var</span><span style="color:#E1E4E8"> eventLoop </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">  _queue: [],</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0">  add</span><span style="color:#E1E4E8">: </span><span style="color:#F97583">function</span><span style="color:#E1E4E8"> (</span><span style="color:#FFAB70">fn</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#6A737D">    // a침adimos la funci칩n a la cola</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">._queue.</span><span style="color:#B392F0">push</span><span style="color:#E1E4E8">(fn);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">    // si est치 desocupado ejecutar la funci칩n</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">!</span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">.running) </span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">executeNext</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">  },</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0">  executeNext</span><span style="color:#E1E4E8">: </span><span style="color:#F97583">function</span><span style="color:#E1E4E8"> () {</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#E1E4E8"> (</span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">.running </span><span style="color:#F97583">||</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">._queue.</span><span style="color:#79B8FF">length</span><span style="color:#F97583"> ===</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">return</span><span style="color:#E1E4E8">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.running </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> true</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">    var</span><span style="color:#E1E4E8"> block </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">._queue.</span><span style="color:#B392F0">shift</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#B392F0">    block</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.running </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> false</span><span style="color:#E1E4E8">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">executeNext</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">  },</span></span>
<span class="line"><span style="color:#E1E4E8">};</span></span></code></pre></div><p><a target="_black" href="http://jsfiddle.net/amatiasq/k9ebk/">Pru칠bame</a></p>
<p>Esto significa que mientras un bloque est칠 ejecut치ndose ning칰n otro bloque de c칩digo puede estar ejecut치ndose a la vez. Pero si un proceso tarda mucho (como leer el disco, comunicarse con el servidor, esperar una determinada cantidad de tiempo...) lo que hacemos es pasarles una funci칩n que ser치 a침adida al <em>event loop</em> cuando el proceso acabe.</p>
<p>Cada &quot;bloque&quot; que el <em>event loop</em> ejecuta se llama &quot;un tick del event loop&quot;, de ah칤 el nombre de la funci칩n <code>process.nextTick</code> de NodeJS.</p>
<p>Una forma sencilla de controlar el <em>event loop</em> es mediante <code>setTimeout</code>, <code>setInterval</code> y <code>setImmediate</code>, podemos crear funciones similares que hagan la misma funcionalidad (simplificada) pero para nuestro <code>eventLoop</code>:</p>
<div class="code-block"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">function</span><span style="color:#B392F0"> mySetImmediate</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">fn</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#E1E4E8">  eventLoop.</span><span style="color:#B392F0">add</span><span style="color:#E1E4E8">(fn);</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">function</span><span style="color:#B392F0"> mySetTimeout</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">fn</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">milliseconds</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#6A737D">  // la unica forma de dejar pasar el tiempo</span></span>
<span class="line"><span style="color:#6A737D">  // es mediante el VERDADERO setTimeout ;)</span></span>
<span class="line"><span style="color:#B392F0">  setTimeout</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">function</span><span style="color:#E1E4E8"> () {</span></span>
<span class="line"><span style="color:#B392F0">    mySetImmediate</span><span style="color:#E1E4E8">(fn);</span></span>
<span class="line"><span style="color:#E1E4E8">  }, milliseconds);</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">function</span><span style="color:#B392F0"> mySetInterval</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">fn</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">milliseconds</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">  function</span><span style="color:#B392F0"> execute</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#B392F0">    fn</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#B392F0">    mySetTimeout</span><span style="color:#E1E4E8">(execute, milliseconds);</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0">  mySetTimeout</span><span style="color:#E1E4E8">(execute, milliseconds);</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre></div><p>Como se puede ver tanto setTimeout como setInterval esperan la cantidad de milisegundos definida y <strong>entonces a침aden</strong> el bloque al <em>event loop</em>, si el <em>event loop</em> est치 ocupado en ese momento puede tardar un poco m치s de lo esperado en ejecutarse nuestra funci칩n.</p>
<p>Entiendiendo esto es m치s f치cil entender porqu칠 Javascript funciona de la forma que funciona.</p>
<ul>
<li>Solo hay un bloque de c칩digo ejecutandose en cada momento</li>
<li>Los bloques se encolan</li>
<li>Se considera as칤ncrono a una secci칩n de c칩digo que ser치 ejecutada en un &quot;tick&quot; distinto</li>
</ul>
<div class="code-block"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">var</span><span style="color:#E1E4E8"> a </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 1</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#B392F0">setTimeout</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">function</span><span style="color:#E1E4E8"> () {</span></span>
<span class="line"><span style="color:#6A737D">  // esta funci칩n es as칤ncrona porque el tick que llama a setTimeout</span></span>
<span class="line"><span style="color:#6A737D">  // tiene que acabar antes que esta funci칩n sea invocada.</span></span>
<span class="line"><span style="color:#E1E4E8">  a </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 2</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">}, </span><span style="color:#79B8FF">100</span><span style="color:#E1E4E8">);</span></span></code></pre></div><p>En el caso de javascript para el navegador adem치s nos encontramos con que el <em>event loop</em> es compartido por Javascript y el motor de renderizado del navegador. Como el <em>event loop</em> solo puede ejecutar un bloque por vez resulta que si estamos ejecutando Javascript el navegador no puede renderizar la p치gina y vice versa, si la p치gina tarda mucho en renderizarse retrasar치 la ejecuci칩n del Javascript. Esto es as칤 porque desde Javascript podemos modificar el DOM y si el navegador intenta renderizar la p치gina mientras nosotros la modificamos tendr칤amos otro tipo de problemas peores.</p>
<p>Pero es importante tener esto en cuenta ya que un proceso Javascript que tarde demasiado &quot;congelar치&quot; la p치gina, no funcionar치n los clicks, scroll, ni siquiera los <code>:hover</code>.</p>
<h3>Un poco de historia</h3>
<p>Cuando Javascript fue desarrollado la comunicaci칩n as칤ncrona con el DOM se solucion칩 mediante eventos y tiene todo el sentido del mundo. Quieres saber cuando el usuario hace click en un elemento? Registra el evento y el navegador te avisar치, quieres saber cuando el usuario haga scroll? registra el evento!</p>
<p>El problema empez칩 cuando empezamos a usar eventos para cosas no tan claras, como eventos puntuales que solo se disparaban una vez:</p>
<div class="code-block"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#E1E4E8">window.</span><span style="color:#B392F0">addEventListener</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">'load'</span><span style="color:#E1E4E8">, </span><span style="color:#F97583">function</span><span style="color:#E1E4E8">() { </span><span style="color:#F97583">...</span><span style="color:#E1E4E8"> });</span></span>
<span class="line"><span style="color:#B392F0">someAjax</span><span style="color:#E1E4E8">().</span><span style="color:#B392F0">onready</span><span style="color:#F97583"> =</span><span style="color:#F97583"> function</span><span style="color:#E1E4E8">() { </span><span style="color:#F97583">...</span><span style="color:#E1E4E8"> };</span></span></code></pre></div><p>Incluso para controlar errores</p>
<div class="code-block"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#E1E4E8">xhr.</span><span style="color:#B392F0">onerror</span><span style="color:#F97583"> =</span><span style="color:#F97583"> function</span><span style="color:#E1E4E8">() { </span><span style="color:#F97583">...</span><span style="color:#E1E4E8"> };</span></span>
<span class="line"><span style="color:#E1E4E8">document.</span><span style="color:#B392F0">querySelector</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"script"</span><span style="color:#E1E4E8">).</span><span style="color:#B392F0">onerror</span><span style="color:#F97583"> =</span><span style="color:#F97583"> function</span><span style="color:#E1E4E8">() { </span><span style="color:#F97583">...</span><span style="color:#E1E4E8"> };</span></span></code></pre></div><p>Hasta para controlar un progreso (en APIs modernas incluso)</p>
<div class="code-block"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">var</span><span style="color:#E1E4E8"> reader </span><span style="color:#F97583">=</span><span style="color:#F97583"> new</span><span style="color:#B392F0"> FileReader</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">reader.</span><span style="color:#B392F0">onprogress</span><span style="color:#F97583"> =</span><span style="color:#F97583"> function</span><span style="color:#E1E4E8">() { </span><span style="color:#F97583">...</span><span style="color:#E1E4E8"> };</span></span></code></pre></div><p>Pero al no estar acostumbrados a trabajar con asincron칤a de esta forma no fuimos capaces de ver que estabamos usando una herramienta para todo, como dicen por ah칤 &quot;para un hombre con un martillo todo es un clavo&quot;.</p>
<p>En node decidieron adaptar el patr칩n &quot;Continuous Passing Style&quot;, que consiste en pasar callbacks a funciones as칤ncronas</p>
<div class="code-block"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#E1E4E8">fs.</span><span style="color:#B392F0">readFile</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"foo"</span><span style="color:#E1E4E8">, </span><span style="color:#F97583">function</span><span style="color:#E1E4E8">() { </span><span style="color:#F97583">...</span><span style="color:#E1E4E8"> });</span></span></code></pre></div><p>Y por suerte integraron <code>EventEmitter</code>, que permiti칩 crear APIs que usaran eventos sin m치s complejidad. Y lo que es mejor, incluyeron los streams, una forma de gesti칩n de asincron칤a creada para que podamos acceder a un recurso por partes. Con el tiempo llegaron los promises que fue lo primero que me hizo plantearme si est치bamos enfocando la asincron칤a de forma coherente.</p>
<p>En total he llegado a resumir los distintos tipos de asincron칤a en dos, ambos con la caracter칤stica de que necesitan gestionar tambi칠n errores:</p>
<ul>
<li><strong>Valor as칤ncrono</strong>: el callback se invoca una sola vez en el futuro</li>
<li><strong>Collecci칩n as칤ncrona</strong>: el callback se invoca una vez por cada elemento en la colecci칩n</li>
</ul>
<h3>Valor as칤ncrono</h3>
<p>En el primer caso tenemos un valor as칤ncrono, puede ser el valor devuelto por una funci칩n as칤ncrona o el valor puede ser nulo en cuyo caso simplemente funcionar칤a para detectar cuando el proceso ha finalizado. Este caso est치 cubierto por los Promises.</p>
<p>Desde mi punto de vista se trata de una especie de meta-programaci칩n, tenemos un valor (el promise) que sustituye al valor real para que podamos seguir con nuestra ejecuci칩n s칤ncrona.</p>
<div class="code-block"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">var</span><span style="color:#E1E4E8"> contentPromise </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> file.</span><span style="color:#B392F0">readContent</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#F97583">return</span><span style="color:#E1E4E8"> contentPromise;</span></span></code></pre></div><h3>Colecci칩n as칤ncrona</h3>
<p>Podemos verlo como un array as칤ncrono, que a medida que se le van a침adiendo elementos va invocando a su callback. En este grupo meter칤a a todo componente as칤ncrono que invoque a su callback m치s de una vez:</p>
<ul>
<li>Flujo de datos</li>
<li>Progreso</li>
<li>Eventos</li>
</ul>
<p>Una de las funcionalidades que m치s me gustan de <a href="https://www.dartlang.org/">Dart</a> es que <a href="https://www.dartlang.org/articles/improving-the-dom/#events">han sustitu칤do los eventos DOM por streams</a>, un peque침o detalle pero que es todo un cambio de concepto, los eventos DOM son una lista de tama침o indeterminado. Cada vez que el usuario hace click es como a침adir ese evento al stream de eventos click de ese elemento. Al ser un stream podemos escucharlo, filtrarlo, manipularlo... de la misma forma que hacemos con una colecci칩n. Incluso hay implementaciones que tienen m칠todos <code>.forEach</code> y <code>.filter</code> y <code>.map</code> cumpliendo la misma interfaz que el resto de colecciones.</p>
<p>Por otro lado los streams siguen siendo 칰tiles para su funcionalidad primera, entregarnos un contenido que vamos recibiendo por partes, es decir; en lugar de cargar un achivo de 1Gb en memoria, un stream nos lo va entregando en bloques m치s peque침os as칤 podemos trabajarlos y liberar memoria. Adem치s en casos como medidores de progresos encajan perfectamente, siendo cada actualizaci칩n del progreso un elemento del stream.</p>
<h3>Y todo junto</h3>
<blockquote>
<p>Nota: el c칩digo a continuaci칩n es adaptado de otros lenguajes y no existe en Javascript</p>
</blockquote>
<p>Incluso hay implementaciones muy completas que integran perfectamente los stream y los promises, podemos hacer de forma sencilla cosas como capturar el primer click en la pagina</p>
<div class="code-block"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#6A737D">// window.onClick instanceof Stream</span></span>
<span class="line"><span style="color:#F97583">var</span><span style="color:#E1E4E8"> firstClick </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> window.onClick.first;</span></span>
<span class="line"><span style="color:#E1E4E8">firstClick.</span><span style="color:#B392F0">then</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">function</span><span style="color:#E1E4E8">() { </span><span style="color:#F97583">...</span><span style="color:#E1E4E8"> });</span></span></code></pre></div><p>Comprobar si las primeras diez teclas han sido &quot;flecha derecha&quot;</p>
<div class="code-block"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">var</span><span style="color:#E1E4E8"> firstTenKeys </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> input.onKeyDown.</span><span style="color:#B392F0">take</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">10</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#F97583">var</span><span style="color:#E1E4E8"> keyRightTenTimes </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> firstTenKeys.</span><span style="color:#B392F0">every</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">function</span><span style="color:#E1E4E8"> (</span><span style="color:#FFAB70">event</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">  return</span><span style="color:#E1E4E8"> event.keyCode </span><span style="color:#F97583">===</span><span style="color:#79B8FF"> 39</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">});</span></span>
<span class="line"><span style="color:#E1E4E8">keyRightTenTimes.</span><span style="color:#B392F0">then</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">function</span><span style="color:#E1E4E8"> (</span><span style="color:#FFAB70">value</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">  if</span><span style="color:#E1E4E8"> (value) console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">'You like left arrow! :D'</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">});</span></span></code></pre></div><p>Capturar solo el tercer click en la p치gina</p>
<div class="code-block"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">var</span><span style="color:#E1E4E8"> thirdClick </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> input.onKeyDown.</span><span style="color:#B392F0">elementAt</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">3</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">thirdClick.</span><span style="color:#B392F0">then</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">function</span><span style="color:#E1E4E8"> (</span><span style="color:#FFAB70">event</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#E1E4E8">  console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">'You clicked three times :)'</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">});</span></span></code></pre></div><p>Obtener todo el contenido del archivo desde el stream, no hace falta un m칠todo especial</p>
<div class="code-block"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">var</span><span style="color:#E1E4E8"> stream </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> file.</span><span style="color:#B392F0">getReadStream</span><span style="color:#E1E4E8">()</span></span>
<span class="line"><span style="color:#F97583">var</span><span style="color:#E1E4E8"> fileContent </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> stream.</span><span style="color:#B392F0">join</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">''</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">fileContent.</span><span style="color:#B392F0">then</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">function</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">content</span><span style="color:#E1E4E8">) { </span><span style="color:#F97583">...</span><span style="color:#E1E4E8"> });</span></span></code></pre></div><p>O detectar el primer evento <code>readystatechange</code> en que el <code>readyState</code> sea <code>4</code>, convertirlo en promise y devolver la respuesta</p>
<div class="code-block"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">return</span><span style="color:#E1E4E8"> xhr.onReadyStateChange</span></span>
<span class="line"><span style="color:#E1E4E8">  .</span><span style="color:#B392F0">filter</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">function</span><span style="color:#E1E4E8"> (</span><span style="color:#FFAB70">event</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#E1E4E8"> xhr.readyState </span><span style="color:#F97583">===</span><span style="color:#79B8FF"> 4</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">  })</span></span>
<span class="line"><span style="color:#E1E4E8">  .first.</span><span style="color:#B392F0">then</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">function</span><span style="color:#E1E4E8"> () {</span></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#E1E4E8"> xhr.responseText;</span></span>
<span class="line"><span style="color:#E1E4E8">  });</span></span></code></pre></div><p>Unificar varias operaciones</p>
<div class="code-block"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#6A737D">// readFile returns promise</span></span>
<span class="line"><span style="color:#F97583">var</span><span style="color:#E1E4E8"> concat </span><span style="color:#F97583">=</span><span style="color:#F97583"> new</span><span style="color:#B392F0"> Stream</span><span style="color:#E1E4E8">([</span><span style="color:#B392F0">readFile</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">'./header.html'</span><span style="color:#E1E4E8">), </span><span style="color:#B392F0">readFile</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">'./content.html'</span><span style="color:#E1E4E8">), </span><span style="color:#B392F0">readFile</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">'./footer.html'</span><span style="color:#E1E4E8">)]);</span></span>
<span class="line"><span style="color:#E1E4E8">stream.</span><span style="color:#B392F0">listen</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">function</span><span style="color:#E1E4E8"> (</span><span style="color:#FFAB70">chunk</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#E1E4E8">  response.</span><span style="color:#B392F0">write</span><span style="color:#E1E4E8">(chunk);</span></span>
<span class="line"><span style="color:#E1E4E8">});</span></span></code></pre></div><p>Incluso cosas m치s complejas como detectar la primera acci칩n del usuario en la p치gina</p>
<div class="code-block"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#6A737D">// Promise.race devuelve un promise que se completar치</span></span>
<span class="line"><span style="color:#6A737D">// cuando el primer promise de la lista se complete</span></span>
<span class="line"><span style="color:#79B8FF">Promise</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">race</span><span style="color:#E1E4E8">([window.onClick.first, window.onKeyDown.first, window.onMouseMove.first]).</span><span style="color:#B392F0">then</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">function</span><span style="color:#E1E4E8"> (</span><span style="color:#FFAB70">event</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#E1E4E8">  console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">'El usuario ha disparado el evento '</span><span style="color:#F97583"> +</span><span style="color:#E1E4E8"> event.type);</span></span>
<span class="line"><span style="color:#E1E4E8">});</span></span></code></pre></div><p>Y hasta capturar el evento <code>load</code> de window aunque ya haya pasado:</p>
<div class="code-block"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#B392F0">setTimeout</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">function</span><span style="color:#E1E4E8"> () {</span></span>
<span class="line"><span style="color:#E1E4E8">  window.onLoad.</span><span style="color:#B392F0">first</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">function</span><span style="color:#E1E4E8"> () {</span></span>
<span class="line"><span style="color:#6A737D">    // Me van a invocar aunque el evento</span></span>
<span class="line"><span style="color:#6A737D">    // ya haya pasado :)</span></span>
<span class="line"><span style="color:#E1E4E8">  });</span></span>
<span class="line"><span style="color:#E1E4E8">}, </span><span style="color:#79B8FF">1000</span><span style="color:#F97583"> *</span><span style="color:#79B8FF"> 60</span><span style="color:#F97583"> *</span><span style="color:#79B8FF"> 60</span><span style="color:#E1E4E8">); </span><span style="color:#6A737D">// una hora</span></span></code></pre></div><h3>Resumen</h3>
<p>La gesti칩n de la asincron칤a, que siempre ha sido un caos, se simplifica de forma radical gracias a una buena combinaci칩n de Stream/Promises. Espero poder actualizar la entrada de los promises con los nuevos promises est치ndard de ECMAScript 6 :)</p>
<p>Conocen m치s patrones de gesti칩n de asincron칤a?</p>
</div>
    </article>
  </main>

  </body></html>